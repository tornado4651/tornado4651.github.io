<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【HEXO】Hello World</title>
    <url>/2019/01/01/hello-world/</url>
    <content><![CDATA[<blockquote>
<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#quick-start">Quick Start</a><ul>
<li><a href="#create-a-new-post">Create a new post</a></li>
<li><a href="#run-server">Run server</a></li>
<li><a href="#generate-static-files">Generate static files</a></li>
<li><a href="#deploy-to-remote-sites">Deploy to remote sites</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h2><span id="quick-start">Quick Start</span><a href="#quick-start" class="header-anchor"></a></h2><h3><span id="create-a-new-post">Create a new post</span><a href="#create-a-new-post" class="header-anchor"></a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3><span id="run-server">Run server</span><a href="#run-server" class="header-anchor"></a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span><a href="#generate-static-files" class="header-anchor"></a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span><a href="#deploy-to-remote-sites" class="header-anchor"></a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Lightroom入门01</title>
    <url>/2020/03/01/%E5%BD%B1%E8%A7%86%E3%80%81%E6%91%84%E5%83%8F%E3%80%81%E5%90%8E%E6%9C%9F/Lightroom01/</url>
    <content><![CDATA[<blockquote>
<p>LR的最基础入门记录，主要是使用方法和使用逻辑的纪录，没有什么摄影的相关专业知识</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#lr-he-ps-de-qu-bie">LR和PS的区别</a></li>
<li><a href="#lr-de-wen-jian-cao-zuo">LR的文件操作</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="lr-he-ps-de-qu-bie">LR和PS的区别</span><a href="#lr-he-ps-de-qu-bie" class="header-anchor"></a></h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">LR</th>
<th align="center">PS</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcsb6kypbmj30le0egtl8.jpg" alt="截屏2020-03-13下午2.58.03"></td>
<td align="center"><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcsb6mb7dzj30me0fgap6.jpg" alt="截屏2020-03-13下午2.58.34"></td>
</tr>
<tr>
<td align="center">功能</td>
<td align="center">主要用于后期色彩上的调整</td>
<td align="center">主要用于图片在形状、构图、结构等方面细致的调整（更为具体、功能更多）</td>
</tr>
<tr>
<td align="center">效率</td>
<td align="center">建立一个对图片的索引，在这个索引上进行编辑调试，速度快，效率高</td>
<td align="center">将原图完全导入到PS中进行编辑，功能更全，但是也会占用更多存储空间，硬件配置要求更高</td>
</tr>
</tbody></table>
<h1><span id="lr-de-wen-jian-cao-zuo">LR的文件操作</span><a href="#lr-de-wen-jian-cao-zuo" class="header-anchor"></a></h1><p>对于修图软件的文件处理方面，我最注重的一个基本原理就是对文件本体的操作，是复制到软件目录下操作？还是不调动原文件的基础上建立索引操作？什么样的操作对原图会有损害？什么样的操作会完全保留原图，以方便在操作不满意后找回原文件重新开始修改？</p>
<p>在LR中，导入照片页面的最顶部会有四种不同的导入方式，所以，再导入时一定要看清所选项，不要盲目导入</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcsfwqe66tj31hc0u0dm4.jpg" alt="截屏2020-03-13下午5.39.55"></p>
<ul>
<li>拷贝：保留原文件，并复制一份到目标文件夹下</li>
<li>移动：直接将原文件移动到目标文件夹下</li>
<li>添加：只建立和原文件的索引，不对原文件做任何操作</li>
</ul>
]]></content>
      <categories>
        <category>影视、摄像、后期</category>
      </categories>
      <tags>
        <tag>Lightroom</tag>
      </tags>
  </entry>
  <entry>
    <title>后期处理中的直方图和曲线图的使用</title>
    <url>/2020/03/04/%E5%BD%B1%E8%A7%86%E3%80%81%E6%91%84%E5%83%8F%E3%80%81%E5%90%8E%E6%9C%9F/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%92%8C%E6%9B%B2%E7%BA%BF%E5%9B%BE/</url>
    <content><![CDATA[<blockquote>
<p>在b站上看到一位很用心的up——“摄影师泰罗”讲解直方图、曲线图的原理和使用方法。感觉收获满满，终于弄懂了摄影中最为重要的两个概念，因此记录下来，随时查看。</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#b-zhan-de-shi-pin-jiao-xue">B站的视频教学</a></li>
<li><a href="#zhi-fang-tu">直方图</a><ul>
<li><a href="#pu-tong-zhi-fang-tu">普通直方图</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="b-zhan-de-shi-pin-jiao-xue">B站的视频教学</span><a href="#b-zhan-de-shi-pin-jiao-xue" class="header-anchor"></a></h1><p><a href="https://www.bilibili.com/video/av93534402" target="_blank" rel="noopener">直方图</a></p>
<iframe src="//player.bilibili.com/player.html?aid=93534402&cid=159697200&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><a href="https://www.bilibili.com/video/av94903103" target="_blank" rel="noopener">色调曲线</a></p>
<iframe src="//player.bilibili.com/player.html?aid=94903103&cid=162709322&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h1><span id="zhi-fang-tu">直方图</span><a href="#zhi-fang-tu" class="header-anchor"></a></h1><h2><span id="pu-tong-zhi-fang-tu">普通直方图</span><a href="#pu-tong-zhi-fang-tu" class="header-anchor"></a></h2><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcsh8z4t3aj308203h74l.jpg" alt="截屏2020-03-13下午6.26.55"></p>
<p>直方图的横坐标表示非常详细的亮度范围（0-255），左面最低，为黑色，右面最高，为白色，从左至右依次为：黑色-阴影-曝光度-高光-白色。而纵坐标表示每一个色彩的数量，即在图中的面积。</p>
<p>从上图这个例子中，可以看到左面的图像最高，右面几乎没有面积，因此可以判断出是一张风格暗色系的照片：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcshe0d7bpj31c00u0kbo.jpg" alt="公园夜"></p>
<p>多通道直方图：因为所有的照片都是根据“三原色RGB”所构建的，因此</p>
<p>直方图只是一种反应照片亮度的统计报告图，只是一种工具。我们可以很好的借助直方图查看调色效果，但它并不能作为一个调色工具使用、</p>
]]></content>
      <categories>
        <category>影视、摄像、后期</category>
      </categories>
      <tags>
        <tag>后期调色</tag>
      </tags>
  </entry>
  <entry>
    <title>献血记</title>
    <url>/2020/05/18/%E7%94%9F%E6%B4%BB%E9%9A%8F%E8%AE%B0/%E7%8C%AE%E8%A1%80%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>几日前，在南锣鼓巷南口的地铁站旁发现一家“南锣书店”，喜心望外。遂每日有空就来闲暇充电感受北京仅存的一些“安逸”。今午，出门后恰巧发现一辆献血车停在旁边，本是平凡小事，但内心有些不同的感觉，特此记录，一边日后回味。</p>
</blockquote>
<a id="more"></a>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gewi5tf0yvj30u01hcarf.jpg" alt="献血证"></p>
<p>首先表示，这的确是我人生中第一次献血。</p>
<p>但值得记录的并不是第一次献血的激动，新奇，兴奋。令我有了想记录下来的，是那种简单感——简单的决定，轻松的签字，自然的伸出胳膊，久违了。</p>
<p>这种自然，是那种丝毫没有被环境影响的自然，对我而言，做决定是需要理性思考的。这次献血就像是在街边漫步时偶然发现一个喜欢的小物件，买来，就好。</p>
<p>献血这件事在以前，我会纠结很久较深，周围人，网上，褒贬不一的评价都在发声，在老家那边每次路过都会第一想到这些评价，从而变得犹豫不决。即使有时内心对自己说“我想自己做一次发自内心的决定，不再受外界影响了！”，但很快就会意识到，这样的内心对话其实已经收到了影响。</p>
<p>而今天，从上车询问是否可以，到最后拔下针头缠上绷带，这些想法丝毫没有进入我的大脑，就像是在街上突然感觉口渴便买水饮下一样直接。原来心中追求的感觉根本无法追求，当他来到时，不会有丝毫察觉的！</p>
<p>直接的决定必定会对现代快节奏有计划的生活带来影响。今晚的练球计划也在走出献血车后的半个小时后，一拍脑门，无奈取消了。但我并不后悔，因为那种简单的感觉真是太难得了！！！</p>
]]></content>
      <categories>
        <category>生活随记</category>
      </categories>
  </entry>
  <entry>
    <title>b站视频文案摘抄</title>
    <url>/2020/08/30/%E7%94%9F%E6%B4%BB%E9%9A%8F%E8%AE%B0/b%E7%AB%99%E8%A7%86%E9%A2%91%E6%96%87%E6%A1%88%E6%91%98%E6%8A%84/</url>
    <content><![CDATA[<blockquote>
<p>视频原地址：忘记了。。。。找到再补充</p>
</blockquote>
<a id="more"></a>


<h1><span id="2020-nian-8-yue-6-ri">2020年8月6日</span><a href="#2020-nian-8-yue-6-ri" class="header-anchor"></a></h1><p>美国总统特朗普发布45天后禁用微信的行政命令，原文中这三个“any”，将打击范围与打击强度，都扩大到了史无前例的地步。</p>
<p>有趣的事，面对世界第一的直接制裁，腾讯公司却若无其事，只是将蛋的发布了一个“本公司正在审阅行政命令的影响”后便再无消息，BBC也用“shrug off”这个词来形容腾讯对待特朗普的态度，而这个词的意思，就是“满不在乎”。</p>
<p>但更有趣的事发生了，一周后，腾讯依旧没有反应，但是多家美国顶级公司却坐不住了，由苹果、迪士尼、福特、摩根士丹利等美国各行业资本巨鳄组成的利益集团，主动联合起来，地址没干过政府封杀微信，其实原因也很简单，因为美国政府封杀微信，会断了他们在中国的财路。</p>
<p><em>也就是说</em>：<strong>一个资本主义国家政府，居然被自己的资本背叛了，而背叛的原因，也是由于资本利益，而这个资本利益，还来自于一个社会主义国家……</strong></p>
<p>真是活久见了！</p>
<p>很多人都把如今的天灾全部归因到特朗普这一个人祸上，但我倒认为，现在全球紧张的局面，是中华民族复兴进程中，躲不过的劫难，逃不了的考验，没有川普，也会有广普、没有美国，也会有臭国。</p>
<p>正如前驻美大使周文重说的：中美关系再也回不到过去了。</p>
<p>中国，是一个在前十个世纪中，九个世纪都是GDP世界第一的国家，但人们总说，神之要流一次血，人们便不再相信，所以中华民族伟大复兴的道路，必定充满着艰难险阻，荆棘载途，暗礁险滩。</p>
<p>马丁亚科教授说，中国是唯一一个伪装成国家的文明，所以我们的复兴，一直都是在寻找属于自己的道路，所谓中国特色社会主义，就是在摸索中前进出来的，但这也同时意味着，我们没有标准答案、没有学习对象，并且一定会伴随着，无数旁观者的嘲弄与质疑。</p>
<p>如今，我们依然深切感受到，外部势力，已从无埋的舆论攻击与形象丑化，晋升为更加荒唐的政策打击与强制干预，但这种卑鄙行为的量变到质变，也反向透露着他们对于中华之崛起这个事实，与日俱增的焦急与紧迫。而面对如今这般的风云诡谲，作为白河夜船的年轻人，你我应该如何面对？</p>
<p>其实国家在川普上任的前两年，便早早提出了唯一的解决办法：</p>
<h1><span id="wen-hua-zi-xin">文化自信</span><a href="#wen-hua-zi-xin" class="header-anchor"></a></h1><p>自信是面对陌生与未知时最有效和正确的方式，也是我们中国人最该引以为豪的心态，这几十年来，我们努力重振破碎不堪的精神、充实散落遍地的尊严、重做挺直脊梁的国人、重续中华文明的不朽、就是为了重回我们最熟悉的世界巅峰，重起我们的风光而这个过程，也正是重拾文化自信的过程，而这种自信，本身也是源自中华文明暑期那年血泪凝聚的经验，更是承托中华文明能够继续走下去的坚实基础。</p>
<p>在湍急的水流中摸着石头过河，我们一边流血流泪，但也一边开花结果，在断言几千次，唱衰几万次的论调声朝中，我们依然自信的走出了71年的精彩光阴。</p>
<p>中国不仅养活了14亿人，还让这14亿人拥有生产劳动的身体，消费交易的能力、明辨是非的学识、团结一心的精神，也正是因为如此，我们才有可能让美国的政府与资本发生内讧，因为这14亿人，再次开始深刻影响着全球75亿人的生活，渗透进这颗蓝色星球的每一寸土地。</p>
<blockquote>
<p>我们从古以来，就有埋头苦干的人，有拼命硬干的人，有为民请命的人，有舍身求法的人，说中国人失掉了自信力，用以指一部分人则可，倘若加于全体，那简直是诬蔑。</p>
</blockquote>
<p>这就好比微博上的“iphone 与 微信”的投票，这根本就不需要选择</p>
<blockquote>
<p>要论中国人，必须不被荼在表面的自欺欺人的脂粉所诓骗，却看看他的筋骨和脊梁。自信力的有无，状元宰相的文章是不足为据的，要自己去看地底下。</p>
</blockquote>
<p>而这两句，鲁迅，真的说过。</p>
]]></content>
      <categories>
        <category>生活随记</category>
      </categories>
  </entry>
  <entry>
    <title>职业体验记录——“康宝莱营养师”</title>
    <url>/2020/05/16/%E7%94%9F%E6%B4%BB%E9%9A%8F%E8%AE%B0/%E8%81%8C%E4%B8%9A%E4%BD%93%E9%AA%8C%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E2%80%9C%E5%BA%B7%E5%AE%9D%E8%8E%B1%E8%90%A5%E5%85%BB%E5%B8%88%E2%80%9D/</url>
    <content><![CDATA[<blockquote>
<p>来到北京一个月后的某一天，丧气的我发呆在回家的地铁上，遇到了一个正在努力发展客户的小姐姐，处于内心对于认同感的渴求，我便主动加了他的微信，帮她完成了任务量。今天，她便邀请我参加了参加了他们的一个活动组织，我也正好借此机会了解了一直感到好奇的“现代销售行业”。</p>
<p>找到一间酒吧，坐下来慢慢回忆这一天的感悟并记下。</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#yi-wei-shi-me-hui-qu">一、为什么会去？</a></li>
<li><a href="#er-chu-gan-xiang">二、初感想</a></li>
<li><a href="#san-ju-ti-fen-xi">三、具体分析</a></li>
<li><a href="#si-zong-jie-fen-xi">四、总结分析</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="yi-wei-shi-me-hui-qu">一、为什么会去？</span><a href="#yi-wei-shi-me-hui-qu" class="header-anchor"></a></h1><p>一直以来，我的想法都是十分传统固化，喜欢追求事物的本质，所以对于过多包装的行业并不感冒，比如广告，销售，新媒体等。但现在不断扩张的眼界告诉我，我应该顶住自己的任性，用实际体验去了解自以为很懂的事物。</p>
<p>今天我便说服自己，以一种想要真正加入“组织”的心态，认真的去了解感受下这个行业。看看他们究竟在传销的皮肤外披上了多少层华丽的外衣，拔掉心中好奇的草，顺便在此给广大朋友说明白。</p>
<h1><span id="er-chu-gan-xiang">二、初感想</span><a href="#er-chu-gan-xiang" class="header-anchor"></a></h1><p>安利！这还是“安利模式”！这个词是我唯一能够联想到的。只不过是套上一些“好看的衣服”罢了……</p>
<h1><span id="san-ju-ti-fen-xi">三、具体分析</span><a href="#san-ju-ti-fen-xi" class="header-anchor"></a></h1><p>活动主题：健康餐品尝交流</p>
<p>活动形式及流程：</p>
<p>10:00开始入场，大家互相闲聊，社交   </p>
<p>12:00左右，主持小游戏活跃气氛 </p>
<p>13:00左右，开始主题活动，健康餐</p>
<p>13:40左右，强制收餐</p>
<p>14:00左右，开始进入正题，在楼里带领大家看看他们旗下的一些“分店”</p>
<h1><span id="si-zong-jie-fen-xi">四、总结分析</span><a href="#si-zong-jie-fen-xi" class="header-anchor"></a></h1>]]></content>
      <categories>
        <category>生活随记</category>
      </categories>
      <tags>
        <tag>职业体验</tag>
      </tags>
  </entry>
  <entry>
    <title>关于老师能力与教学环境关系的思考</title>
    <url>/2020/01/01/%E7%94%9F%E6%B4%BB%E9%9A%8F%E8%AE%B0/%E5%85%B3%E4%BA%8E%E6%95%99%E5%B8%88%E8%83%BD%E5%8A%9B%E4%B8%8E%E6%95%99%E5%AD%A6%E7%8E%AF%E5%A2%83%E5%85%B3%E7%B3%BB%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<blockquote>
<p>作为一个刚刚毕业不久的师大学生，在经历了四年的学生会、学院的“明争暗斗”，考研教育的纷繁选择，从网上自学编程框架的心烦意乱后，我对教育行业有了一些自己的想法，今天记录下来，既是为了抒发义愤，更是为了让自己冷静分析，希望自己迟迟暮年之时可以做一位合格的教育事业工作者，将自己的一生所学交给需要的人们。</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#yi-da-xue-lao-shi-de-liang-ji-fen-hua-qing-kuang">一、大学老师的两极分化情况</a></li>
<li><a href="#er-jin-pai-jiao-shi-de-jiao-xue-zhi-liang-shi-ru-he-bao-chi-xia-lai-de">二、金牌教师的教学质量是如何保持下来的？</a></li>
<li><a href="#san-zhen-zheng-de-jiao-yu-ying-gai-shi-shi-me-yang-de">三、真正的教育应该是什么样的</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="yi-da-xue-lao-shi-de-liang-ji-fen-hua-qing-kuang">一、大学老师的两极分化情况</span><a href="#yi-da-xue-lao-shi-de-liang-ji-fen-hua-qing-kuang" class="header-anchor"></a></h1><p>我曾在2018年的某条朋友圈中这样描述现在大学的教学环境——老师懒得教，学生懒得学。</p>
<p>进入大学后发现，普遍教学质量的相对严重下降，是我对高校生活最为反感的方面之一。当面对着一群打扮“幼稚”，外表懒散，目光呆滞，心不在焉玩手机的学生坐在台下‘应付’你的教案时，再好的老师也可能会被磨灭激情，开始‘应付’学生；当你踌躇满志的步入校园准备开启人生新篇章时，却发现抱有最大希望的老师却是那副毫不在意，无所事事，心无教学时，再优秀的学生也会终究放弃奋斗，碌碌无为。</p>
<p>但当我在准备了两年的备战考研后，我突然想到：为什么这些火遍全国的教育机构的金牌教师们却能如此吸引学生，让大家重新燃起了当初中学时代那股学习激情呢？我时常在想，如果大学的高数老师能把课程讲到这么细致，有理有据，该有多好啊！</p>
<p>因此，现在教师的普遍情况和学生一样，两极分化十分严重。</p>
<h1><span id="er-jin-pai-jiao-shi-de-jiao-xue-zhi-liang-shi-ru-he-bao-chi-xia-lai-de">二、金牌教师的教学质量是如何保持下来的？</span><a href="#er-jin-pai-jiao-shi-de-jiao-xue-zhi-liang-shi-ru-he-bao-chi-xia-lai-de" class="header-anchor"></a></h1><p>我最近开始在想，那些每门学科中都会有几位被学生口口相传的金牌教师，究竟是什么驱动着他们在教学的道路上如此努力坚持不懈呢？原因除了自身的努力教授外，我认为更重要的是环境优势，教育机构老师没有现实上课是消极的教学环境影响，即使有天价的“免授课程”，那么愿意支付高昂学费去学习的学生一定不会像普遍当代大学生那样消极</p>
<h1><span id="san-zhen-zheng-de-jiao-yu-ying-gai-shi-shi-me-yang-de">三、真正的教育应该是什么样的</span><a href="#san-zhen-zheng-de-jiao-yu-ying-gai-shi-shi-me-yang-de" class="header-anchor"></a></h1>]]></content>
      <categories>
        <category>生活随记</category>
        <category>想法 &amp; 思考</category>
      </categories>
      <tags>
        <tag>教育的意义</tag>
      </tags>
  </entry>
  <entry>
    <title>视频文字稿记录—“拉片实验室”：“深度解读电影圈常见概念”（上）</title>
    <url>/2020/06/13/%E5%BD%B1%E8%A7%86%E3%80%81%E6%91%84%E5%83%8F%E3%80%81%E5%90%8E%E6%9C%9F/%E8%A7%86%E9%A2%91%E6%96%87%E5%AD%97%E7%A8%BF%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%9C%E6%8B%89%E7%89%87%E5%AE%9E%E9%AA%8C%E5%AE%A4%E2%80%9D%EF%BC%9A%E2%80%9C%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BB%E7%94%B5%E5%BD%B1%E5%9C%88%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5%E2%80%9D%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>蒙太奇——用一个更容易看懂的词来解释，是“组接“，把画面A和画面B拼在一起，就形成了一个组接，有朋友可能会问，这玩意儿不是叫剪辑吗？这和蒙太奇有什么区别呢？</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#yuan-shi-pin-chu-chu">原视频出处</a></li>
<li><a href="#meng-tai-qi">蒙太奇</a><ul>
<li><a href="#xu-shi-meng-tai-qi">叙事蒙太奇</a><ul>
<li><a href="#ping-xing-meng-tai-qi">平行蒙太奇</a></li>
<li><a href="#jiao-cha-meng-tai-qi">交叉蒙太奇</a></li>
</ul>
</li>
<li><a href="#biao-yi-meng-tai-qi">表意蒙太奇</a><ul>
<li><a href="#xin-li-meng-tai-qi">心理蒙太奇</a></li>
<li><a href="#dui-bi-meng-tai-qi">对比蒙太奇</a></li>
<li><a href="#yin-yu-meng-tai-qi">隐喻蒙太奇</a></li>
</ul>
</li>
<li><a href="#li-xing-meng-tai-qi">理性蒙太奇</a><ul>
<li><a href="#za-shua-meng-tai-qi">杂耍蒙太奇</a></li>
</ul>
</li>
<li><a href="#zong-jie">总结</a></li>
</ul>
</li>
<li><a href="#lei-xing-pian">类型片</a><ul>
<li><a href="#da-zhi-pian-han-zhi-du">大制片厂制度</a></li>
<li><a href="#te-dian-yi-gao-du-de-shang-pin-hua">特点一：高度的商品化。</a></li>
<li><a href="#te-dian-er-mo-shi-hua">特点二：模式化</a></li>
<li><a href="#te-dian-san-er-yuan-xing">特点三：二元性</a></li>
<li><a href="#te-dian-si-ke-yu-jian-xing">特点四：可预见性</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="yuan-shi-pin-chu-chu">原视频出处</span><a href="#yuan-shi-pin-chu-chu" class="header-anchor"></a></h1><iframe src="//player.bilibili.com/player.html?aid=668492748&bvid=BV1ca4y1Y7nt&cid=201196469&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h1><span id="meng-tai-qi">蒙太奇</span><a href="#meng-tai-qi" class="header-anchor"></a></h1><p>蒙太奇——用一个更容易看懂的词来解释，是“组接“，把画面A和画面B拼在一起，就形成了一个组接，有朋友可能会问，这玩意儿不是叫剪辑吗？这和蒙太奇有什么区别呢？</p>
<p>先给大家看一件神奇的事情</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfqtk3kix5j30we0u0dje.jpg" alt="蒙太奇发音"></p>
<p>没错，在一开始，蒙太奇就是法语中剪辑的音译，从这一点看，说蒙太奇就是剪辑也没错。但是，在当下的语境中，二者的含义出现了分化，剪辑多为动词，指我们将镜头拼接在一起的动作；而蒙太奇是名次，指通过镜头的组接而产生含义的艺术表达方式。也就是说，我们通过剪辑这种操作，来达成蒙太奇这种结果。</p>
<p>又有观众可能会问，一部电影可能会有上千个镜头，为什么我们不说电影中出现了上千次蒙太奇？实际上，绝大多数常规化剪辑形成的镜头组接，我们都不能称之为蒙太奇，也有说法称之为“微观/中观蒙太奇”。比如找一个动作剪辑点，用两个镜头来表现一个连贯的动作。这种常见情况我们就不会说他是蒙太奇。</p>
<p>如今，蒙太奇已经形成了三大类相对固定的范式，也就是蒙太奇的三个分类：叙事蒙太奇、表意蒙太奇、理性蒙太奇。</p>
<h2><span id="xu-shi-meng-tai-qi">叙事蒙太奇</span><a href="#xu-shi-meng-tai-qi" class="header-anchor"></a></h2><p>先说第一大类：叙事蒙太奇</p>
<p>这类蒙太奇已交待故事情节为目的，按照事件发展逻辑来切分组织镜头，引导观众进行理解。叙事蒙太奇又可以进一步划分为几种类型，我这里讲最常被提到，也最常被混淆的两种：平行蒙太奇 ，交叉蒙太奇。</p>
<h3><span id="ping-xing-meng-tai-qi">平行蒙太奇</span><a href="#ping-xing-meng-tai-qi" class="header-anchor"></a></h3><p><strong>平行蒙太奇</strong>，指两条或两条以上人物线索并行的段落，并且，划重点！在这个段落内不发生相交。</p>
<p>影片《星际穿越》就大量利用了“平行蒙太奇”来进行双线叙事。以父亲为主角的宇宙线，和已女儿为主角的地球线，交替讲述并且一直没有汇聚到一点上。直到结束时，父亲才和濒临老死的女儿见面。</p>
<h3><span id="jiao-cha-meng-tai-qi">交叉蒙太奇</span><a href="#jiao-cha-meng-tai-qi" class="header-anchor"></a></h3><p><strong>交叉蒙太奇</strong>，同样指两条或两条以上的线索交替并行。和平行蒙太奇不同的是，两条线相交，汇集到一点上。另外，交叉蒙太奇的不同剧情线之间交替的速度一般比平行蒙太奇要快，以营造紧张刺激的观感。交叉蒙太奇的常见应用是“最后一分钟营救”。</p>
<p>这里再解释下这个概念：”最后一分钟营救“通常被认为首创于格里菲斯1915年作品——《一个国家的诞生》当中。另一个书法首创于《党同伐异》，至两条线的交叉叙事，在一条线中，A遭遇危险，即将发生难以挽回的后果。另一条线中，和A有一定关系的B正在付出努力，意图拯救A，画面在面临危险的A和努力拯救A的B之间来回切换，最终相交于一点，B成功的拯救了A，避免了后果的发生，这种建立在交叉蒙太奇基础上的剧情模式被称为“最后一分钟营救”。经过长期的影视制作实践，它被证明是一种行之有效的调动观众紧张情绪的模式，被广泛应用在动作片，警匪片，超级英雄等类型当中，且通常设置在影片的最后，形成全片最重要的剧情高潮。再用一个生动的案例去解释，频繁出现在古装偶像剧中的“刀下留人”也是“最后一分钟营救”的经典应用。此外，“最后一分钟营救”还能表达其他惊险刺激的情节，比如体育题材当中的压哨绝杀。</p>
<h2><span id="biao-yi-meng-tai-qi">表意蒙太奇</span><a href="#biao-yi-meng-tai-qi" class="header-anchor"></a></h2><p>第二大类，表意蒙太奇</p>
<p>顾名思义，这类蒙太奇的目的，不是为了叙事，而是通过镜头，场面或者段落之间的组接，表达特定的状态或情绪，传达创作者的观点。</p>
<p>表意蒙太奇当中我讲三类：心理蒙太奇、对比蒙太奇、和隐喻蒙太奇。</p>
<h3><span id="xin-li-meng-tai-qi">心理蒙太奇</span><a href="#xin-li-meng-tai-qi" class="header-anchor"></a></h3><p>心理蒙太奇，是指通过组接展现出人物的回忆、幻想、梦境等内心活动，是电影中常用的表现人物内心世界的手法。</p>
<h3><span id="dui-bi-meng-tai-qi">对比蒙太奇</span><a href="#dui-bi-meng-tai-qi" class="header-anchor"></a></h3><p>对比蒙太奇，指将一对反差较大的概念，比如大和小，动和静，贫穷和富有，生和死等组接在一起。发挥强调和突出的功能，今儿表达一些寓意和思想。</p>
<h3><span id="yin-yu-meng-tai-qi">隐喻蒙太奇</span><a href="#yin-yu-meng-tai-qi" class="header-anchor"></a></h3><p>隐喻蒙太奇，是表意蒙太奇中相对重要的一种，只用一类事物去类比另一种，是观众通过联想来解读两者之间的相似关系。最终达到表达观点的目的。以影片《南方车站的聚会》为例，周泽农的小弟常朝逃到动物园，警方得知消息出动抓捕。此时，出现了一段动物惊恐眼神的镜头和警队抓捕镜头的交叉剪辑，以动物园里的困兽来隐喻常朝和周泽农走投无路的处境。关于隐喻蒙太奇，有一点比较重要的是，用来隐喻的镜头需要能合理地安插到叙事当中，这也是上面这场戏安排在动物园的原因。如果没有这种交代，直接毫无铺垫的插入动物的镜头，就成为了理性蒙太奇，也就是接下来我们要介绍的。</p>
<h2><span id="li-xing-meng-tai-qi">理性蒙太奇</span><a href="#li-xing-meng-tai-qi" class="header-anchor"></a></h2><p>蒙太奇第三大类，理性蒙太奇</p>
<p>理性蒙太奇同样起到表意的作用，这类蒙太奇与苏联的蒙太奇学派，尤其是电影大师—爱森斯坦密切相关。理性蒙太奇指通过镜头的组接产生冲击，是观众从对视觉形象的认知上升到理性的认识，而镜头内部表达的内容甚至可以和剧情无关，是一种极其主观化的创作手法。</p>
<h3><span id="za-shua-meng-tai-qi">杂耍蒙太奇</span><a href="#za-shua-meng-tai-qi" class="header-anchor"></a></h3><p>理性蒙太奇中比较重要的是杂耍蒙太奇，又称为吸引力蒙太奇，多见于爱森斯坦的作品中，比如《罢工》《十月》《战舰波将金号》，杂耍蒙太奇通常以极快的速度进行组接，通过画面的不断堆积形成冲击力和吸引力。影片《十月》当中，导演在一个男人的镜头之后接上了一只机械孔雀正在开屏的画面，并在男人和孔雀之间来回切换，用以暗示男人的高傲自大。而且孔雀在剧情上没有任何交代，是凭空出现的，属于典型的“杂耍蒙太奇”，“杂耍蒙太奇”在功能上和隐喻蒙太奇有一定的重合，二者最大的差别，是组接的画面是否能合理的安插在叙事当中。由于理性蒙太奇的手法在很大程度上挑战了观众的观影习惯，人们越来越难以接受画面和声音元素的中断，因此，理性蒙太奇已经极少见于当代电影作品当中，甚至经常不被提到了。我看过的相对接近的一些片段出自影片《梦之安魂曲》当中，类似于杂耍蒙太奇。</p>
<h2><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h2><p>事实上，我们在评论电影的时候，一般只有在涉及到平行或者交叉蒙太奇的时候，才会说明具体类别，其他的情况，往往就直说蒙太奇这三个字。</p>
<p>对于蒙太奇，直到“叙事蒙太奇”和“表意蒙太奇”这两类概念，直到叙事蒙太奇中平行蒙太奇和交叉蒙太奇的意义和差别，就够用了。</p>
<h1><span id="lei-xing-pian">类型片</span><a href="#lei-xing-pian" class="header-anchor"></a></h1><h2><span id="da-zhi-pian-han-zhi-du">大制片厂制度</span><a href="#da-zhi-pian-han-zhi-du" class="header-anchor"></a></h2><p>说起类型片，离不开另一个概念—大制片厂制度，二十世纪二十年代前后，美国的电影生产逐渐被八家电影公司垄断。分别是：派拉蒙、米高梅、华纳兄弟、二十世纪福克斯、雷电华（五大），环球、联美和哥伦比亚（三小）。他们掌控了电影行业的整个链条，直接刺激了一种从制片到发行，再到放映的高度工业化生产模式的产生，即为“大制片厂制度”。</p>
<p>“大制片厂制度“的核心特征是制片人中心制以及流水线生产。制片人介入电影生产的各个环节，能够控制剧本，拍摄以及剪辑等各项事务。此外，电影公司内部也强调惊喜的分工。比如，一个编剧的部门，就会有专门提供想法，设计情节，涉及对话之类的细致分工。导演、演员、摄影、录音等部门也类似，集体收制片人的控制。在这样的情况下，导演的作用大幅削弱，电影创作中的艺术表达也退居次要，电影成为一种和工业产品类似的，在流水线上经历一个个环节拼装起来的商品。这种流水线商品能够获得成功的重要原因是观众的重要反馈，电影公司根据影片的票房表现来对影片进行评估，了解哪些内容是受到观众欢迎的，并且在后续的电影生产中不断强化和完善这些内容，也就导致了他们在叙事模式上的相似性。<strong>到这时，类型片的概念就形成了。</strong></p>
<p>由于<strong>类型片</strong>的流水线式生产，能大幅提高电影产品的生产效率，降低成本，而且迎合观众心理的电影产品又能够一直获取优秀的票房成绩。巨额的商业利润使好莱坞的类型片生产在三四十年代高度繁荣，在这个时间段，盛行的类型有：西部片、喜剧片、歌舞片、犯罪片、恐怖片等。这些类型也称为经典好莱坞时期的经典类型。</p>
<p>除了类型片的产生，大制片厂制度还带来了另一个结果—<strong>明星制</strong>的繁荣，为了弥补电影国语相似带来的弊端，电影公司使用一些深受观众喜爱，具有票房号召力的演员出演，来确保影片的票房成绩。</p>
<p>聊完了类型片的发轫和盛行，我们来看一看当时的类型片有哪些<strong>特点</strong>？</p>
<h2><span id="te-dian-yi-gao-du-de-shang-pin-hua">特点一：高度的商品化。</span><a href="#te-dian-yi-gao-du-de-shang-pin-hua" class="header-anchor"></a></h2><p>由于类型片的诞生就是电影公司为了最大化商业利润的产物，因此类型片都带有极其强烈的商业属性，本质上是满足电影观众消费需求的商品。</p>
<h2><span id="te-dian-er-mo-shi-hua">特点二：模式化</span><a href="#te-dian-er-mo-shi-hua" class="header-anchor"></a></h2><p>某一种类型片中的剧情设计都高度相似。比如西部片中常常是白人民众常常遭到暴力威胁，枪法高超的牛仔或者警官除暴安良，将敌人尽数歼灭。除了剧情，在人物塑造、场景设计、视觉形象等方面的安排上，类型片叶都保持了模式化。公式化的情节，定型化的人物，图解式的视觉形象，也别称为”类型片的三要素“。</p>
<h2><span id="te-dian-san-er-yuan-xing">特点三：二元性</span><a href="#te-dian-san-er-yuan-xing" class="header-anchor"></a></h2><p>类型片中往往建构了简单的二元对立。暴力和文明，邪恶和正直等元素在类型片中天然的对立起来，而大多不回去深究人物的复杂性，尤其是反派形象。</p>
<h2><span id="te-dian-si-ke-yu-jian-xing">特点四：可预见性</span><a href="#te-dian-si-ke-yu-jian-xing" class="header-anchor"></a></h2><p>指观众在走进影厅之前，就能通过片名，出演明星等信息来猜测出影片的大致情况。只看完影片的开头，就能猜测出影片的后续走向，甚至是结局。但观众在观影过程中还是会保持沉浸的状态，体验重复的快感。</p>
<p><strong>后来</strong>，到了五六十年代，由于电视开始对电影构成威胁。来自欧洲的新浪潮、新现实主义等风格的鹰派呢进入美国观众视野，同时，美国本土也出现了一些独立制片的电影作品，这些因素都对经典的好莱坞形成了很大冲击，传统的大制片厂制度在这个时期逐渐瓦解，导演在创作中的重要性大幅提升，艺术表达也引入电影制作。</p>
<p>在这样的情况下，类型片的概念也发生了细微的改变。从经典好莱坞时期大制片厂制度控制下的电影商品，成为更一般意义上的电影种类的划分。不过，当我们现在谈起类型片的时候，他的几个特点仍然有所保留，比如突出的商业属性，一定程度上还存在的模式化，二元性和可预见性等等，只是这种固定和重复相较好莱坞时期削弱很多。</p>
<p><strong>总体开看</strong>，每个年代流行的类型不同，往往是受到当时社会的政治经济条件，流行的文化思潮等因素影响的。此外，受到观众不断提高的故事消费需求的影响，单一的类型常常不再能满足观众的要求，类型融合的影片越来越多，以此来丰富信息量，超出观众的观影期待。</p>
]]></content>
      <categories>
        <category>影视、摄像、后期</category>
      </categories>
      <tags>
        <tag>影视</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Java工具类记录</title>
    <url>/2020/01/01/CODING/Java%E5%9F%BA%E7%A1%80/%E5%B8%B8%E7%94%A8Java%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#string">String</a></li>
<li><a href="#date">Date</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="string">String</span><a href="#string" class="header-anchor"></a></h1><h1><span id="date">Date</span><a href="#date" class="header-anchor"></a></h1>]]></content>
      <categories>
        <category>CODING</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要经常implements Serializable</title>
    <url>/2020/01/01/CODING/Java%E5%9F%BA%E7%A1%80/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81implements%20Serializable/</url>
    <content><![CDATA[<blockquote>
<p>我理解的implements Serializable作用</p>
</blockquote>
<div class="toc">

<!-- toc -->



<!-- tocstop -->

</div>
<a id="more"></a>

<p>implements Serializable的主要作用是将创建的类“序列化”，能够以二进制的方式输入和输出</p>
<p> 什么情况下需要序列化：</p>
<ol>
<li><p>当你想把的内存中的对象写入到硬盘的时候。</p>
</li>
<li><p>当你想用套接字在网络上传送对象的时候。</p>
</li>
<li><p>当你想通过RMI传输对象的时候。（RMI：Remote Method Invocation，远程方法调用）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>CODING</category>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>字符串操作</title>
    <url>/2020/06/09/CODING/Java%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#string-yu-stringbuffer-de-shi-yong">String 与StringBuffer的使用</a></li>
<li><a href="#string-yu-integer-de-hu-huan">String 与 Integer的互换</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="string-yu-stringbuffer-de-shi-yong">String 与StringBuffer的使用</span><a href="#string-yu-stringbuffer-de-shi-yong" class="header-anchor"></a></h1><p>创建StringBuffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer strbuf = <span class="keyword">new</span> StringBuffer(<span class="string">"xxxxx"</span>);</span><br></pre></td></tr></table></figure>

<p>借助StringBuffer反转字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"123456"</span>;</span><br><span class="line">str = <span class="keyword">new</span> StringBuffer(str).reverse().toString();</span><br></pre></td></tr></table></figure>

<h1><span id="string-yu-integer-de-hu-huan">String 与 Integer的互换</span><a href="#string-yu-integer-de-hu-huan" class="header-anchor"></a></h1><p><a href="https://blog.csdn.net/weixin_43972361/article/details/89575721" target="_blank" rel="noopener">String 与 Integer的互换</a></p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse下的tomcat启动失败（Server Tomcat v7.0 Server at localhost failed to start.）</title>
    <url>/2020/01/01/CODING/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/eclipse%E4%B8%8B%E7%9A%84tomcat%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%EF%BC%88Server%20Tomcat%20v7.0%20Server%20at%20localhost%20failed%20to%20start.%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>解决eclipse中在tomcat上运行项目时的报错：eclipse下的tomcat启动失败（Server Tomcat v7.0 Server at localhost failed to start.）。但并不是端口号占用</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#bao-cuo-huan-jing">报错环境</a></li>
<li><a href="#bao-cuo-ti-shi">报错提示</a></li>
<li><a href="#bao-cuo-yuan-yin">报错原因</a></li>
<li><a href="#jie-jue-ban-fa">解决办法</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="bao-cuo-huan-jing">报错环境</span><a href="#bao-cuo-huan-jing" class="header-anchor"></a></h1><p>eclipse中server的配置出错，具体因为什么操作导致的，不清除，只是在run as -&gt; Run On Server后出现“Server Tomcat v7.0 Server at localhost failed to start.”的提示，点击“Details”也是这种提示，导致无法运行项目。命令行查看了下端口号并没有占用，使用tomcat安装目录下的startup.sh 和shutdown.sh也可以正常启动停止服务器，说明问题肯定在eclipse的调用设置上。</p>
<h1><span id="bao-cuo-ti-shi">报错提示</span><a href="#bao-cuo-ti-shi" class="header-anchor"></a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Server Tomcat v7.0 Server at localhost failed to start.</span><br></pre></td></tr></table></figure>

<h1><span id="bao-cuo-yuan-yin">报错原因</span><a href="#bao-cuo-yuan-yin" class="header-anchor"></a></h1><p>暂时不明白，待更新……</p>
<h1><span id="jie-jue-ban-fa">解决办法</span><a href="#jie-jue-ban-fa" class="header-anchor"></a></h1><p>在mac OS下在使用terminal终端用命令行进入到<workspace>/.metadata/.plugins/org.eclipse.wst.server.core目录下，查看当前目录中的”temp*”文件夹，并全部删除，重新启动</workspace></p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>报错记录</category>
      </categories>
      <tags>
        <tag>exlipse报错</tag>
        <tag>tomcat启动失败</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记</title>
    <url>/2020/06/01/CODING/Java%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>重头学一遍！三个月内学完！夯实基础，细节!</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#ji-ben-gai-nian">基本概念</a><ul>
<li><a href="#bian-liang">变量</a></li>
<li><a href="#shu-ju-lei-xing">数据类型</a></li>
<li><a href="#luo-ji-yun-suan">逻辑运算</a></li>
</ul>
</li>
<li><a href="#chou-xiang-lei-he-jie-kou">抽象类和接口</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a> 

<p>[toc]</p>
<h1><span id="ji-ben-gai-nian">基本概念</span><a href="#ji-ben-gai-nian" class="header-anchor"></a></h1><h2><span id="bian-liang">变量</span><a href="#bian-liang" class="header-anchor"></a></h2><p>变量的概念：<code>概念</code></p>
<p>变量的作用：<code>作用</code></p>
<p>注意事项：<code>必须先声明，后赋值；</code></p>
<p>强类型语言：<code>体现在该语言规定了不同的数据类型</code></p>
<h2><span id="shu-ju-lei-xing">数据类型</span><a href="#shu-ju-lei-xing" class="header-anchor"></a></h2><p>数据类型分类：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg2docjyzvj30um0n0gnw.jpg" alt="截屏2020-06-23 下午6.01.55"></p>
<p>基本数据类型大小：</p>
<table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th align="center">长度</th>
<th align="center">表示范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">1字节 = 8bit位</td>
<td align="center">-2<sup>7</sup>—2<sup>7</sup>（-128 — 127）</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2字节</td>
<td align="center">-2<sup>15</sup> — 2<sup>15</sup>-1</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4字节</td>
<td align="center">-2<sup>31</sup> — 2<sup>31</sup>-1</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8字节</td>
<td align="center">-2<sup>63</sup> — 2<sup>63</sup>-1</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4字节</td>
<td align="center">-3.403E38 ~ 3.403E38</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8字节</td>
<td align="center">-1.798E308 ~ 1.798E308</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">2字节</td>
<td align="center">—</td>
</tr>
<tr>
<td align="center">booblean</td>
<td align="center">—</td>
<td align="center">—</td>
</tr>
</tbody></table>
<p>基本数据类型转换：</p>
<p>大接小，自动转换；小接大，强制转换。</p>
<p><strong>注：</strong></p>
<p><strong>当byte、char、short、三种类型做运算时（相互或自身都是），结果都被转换为int！</strong></p>
<p><strong>当有一变量是String类型时，一定做连接操作。</strong></p>
<p>整型常量默认int型，浮点类型默认double型。</p>
<h2><span id="luo-ji-yun-suan">逻辑运算</span><a href="#luo-ji-yun-suan" class="header-anchor"></a></h2><p><strong>“&amp;”和“&amp;&amp;”的区别：</strong>【以下的A、B可以指代表达式】</p>
<p>A &amp; B：左边无论真假，右边都进行运算；</p>
<p>A &amp;&amp; B：如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。</p>
<p><strong>“｜”和“｜｜”的区别：</strong>【以下的A、B可以指代表达式】</p>
<p>A ｜ B：左边无论真假，右边都进行运算；</p>
<p>A ｜｜ B：如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。</p>
<h1><span id="chou-xiang-lei-he-jie-kou">抽象类和接口</span><a href="#chou-xiang-lei-he-jie-kou" class="header-anchor"></a></h1><p>含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。<br>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。<br>下面比较一下两者的语法区别：<br>1.抽象类可以有构造方法，接口中不能有构造方法。<br>2.抽象类中可以有普通成员变量，接口中没有普通成员变量<br>3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。<br>\4. 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然<br>eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。<br>\5. 抽象类中可以包含静态方法，接口中不能包含静态方法<br>\6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。<br>\7. 一个类可以实现多个接口，但只能继承一个抽象类。<br>下面接着再说说两者在应用上的区别：<br>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用， </p>
<p>例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * serialVersionUID属性概述</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params"> HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"> <span class="comment">// 记录访问日志</span></span><br><span class="line"> <span class="comment">// 进行权限判断</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">true</span>)<span class="comment">// if条件里写的是“具有权限”</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> doService(request, response);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"> <span class="comment">// 记录异常信息</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params"> HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">BaseServlet</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * serialVersionUID属性概述</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params"> HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"> <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。<br>备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，最后再说两者的应用区别。<br>比较两者语法细节区别的条理是：先从一个类中的构造方法、普通成员变量和方法（包括抽象方法），静态变量和方法，继承性等6个方面逐一去比较回答，接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>项目结构记录</title>
    <url>/2020/01/01/CODING/Java%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<blockquote>
<p>这里总结各类项目的目录结构，方便理解查询</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#java-xiang-mu-jie-gou">Java 项目结构：</a></li>
<li><a href="#java-web-xiang-mu-jie-gou">Java Web项目结构：</a></li>
<li><a href="#maven-xiang-mu-jie-gou">Maven项目结构：</a></li>
<li><a href="#spring-boot-xiang-mu-jie-gou">Spring Boot项目结构</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="java-xiang-mu-jie-gou">Java 项目结构：</span><a href="#java-xiang-mu-jie-gou" class="header-anchor"></a></h1><p>什么都没有，只是简单的src目录即可，out目录为自动生成的同级输出目录</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gd35reqkaej3082052dg0.jpg" alt="基本项目结构"></p>
<h1><span id="java-web-xiang-mu-jie-gou">Java Web项目结构：</span><a href="#java-web-xiang-mu-jie-gou" class="header-anchor"></a></h1><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gd35t7v7sgj308b054q32.jpg" alt="JavaWeb项目结构"></p>
<h1><span id="maven-xiang-mu-jie-gou">Maven项目结构：</span><a href="#maven-xiang-mu-jie-gou" class="header-anchor"></a></h1><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gd35ukfw3gj308r04fjrf.jpg" alt="Maven项目结构"></p>
<h1><span id="spring-boot-xiang-mu-jie-gou">Spring Boot项目结构</span><a href="#spring-boot-xiang-mu-jie-gou" class="header-anchor"></a></h1>]]></content>
      <categories>
        <category>CODING</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>项目结构</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Spring actuator时启动不识别‘@’符号的问题.md</title>
    <url>/2020/07/06/CODING/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8Spring%20actuator%E6%97%B6%E5%90%AF%E5%8A%A8%E4%B8%8D%E8%AF%86%E5%88%AB%E2%80%98@%E2%80%99%E7%AC%A6%E5%8F%B7%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>在学习SrpingCloud 与微服务时，书中记录了一段使用Spring actuator监控项目健康状态的代码，但是在我照例配置好准备启动时，遇到如下问题，特此记录。</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#bao-cuo-huan-jing">报错环境</a></li>
<li><a href="#bao-cuo-ti-shi">报错提示</a></li>
<li><a href="#bao-cuo-yuan-yin">报错原因</a></li>
<li><a href="#jie-jue-ban-fa">解决办法</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="bao-cuo-huan-jing">报错环境</span><a href="#bao-cuo-huan-jing" class="header-anchor"></a></h1><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gghc2ixw8uj30gs02cq30.jpg" alt="截屏2020-07-06 下午4.29.59"></p>
<p>今天跟着《Spring Cloud与Docker微服务实践》创建书中的示例时，创建了如上图所示的两个微服务，<code>provider-user</code>用于</p>
<p>提供查询用户信息的服务，而<code>consumer-moive</code>用于向<code>provider-user</code>索取服务。</p>
<p>教程示例中为<code>provider-user</code>模块添加了Spring Actuator组件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之后我打算在<code>consumer-moive</code>模块中同样添加Spring Actuator组件支持。但是在配置<code>/info</code>端点信息时发生了报错，</p>
<p>ps: <code>provider-moive</code>模块能够正常启动。</p>
<h1><span id="bao-cuo-ti-shi">报错提示</span><a href="#bao-cuo-ti-shi" class="header-anchor"></a></h1><p>报错信息显示如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggjj4su7xsj31gc078q41.jpg" alt="截屏2020-07-08 上午11.33.38"></p>
<h1><span id="bao-cuo-yuan-yin">报错原因</span><a href="#bao-cuo-yuan-yin" class="header-anchor"></a></h1><p>从报错信息来看，是application.yml的配置文件中‘@’字符有错，但经过检查并没有中英文格式的问题，写法也是根据教程所写。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## INFO</span></span><br><span class="line"><span class="attr">info:</span> </span><br><span class="line">  <span class="attr">app:</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">@project.artifactId@</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">@project.build.sourceEncoding@</span></span><br><span class="line">    <span class="attr">java:</span></span><br><span class="line">      <span class="attr">source:</span> <span class="string">@java.version@</span></span><br><span class="line">      <span class="attr">target:</span> <span class="string">@java.version@</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggjj77goifj312o0gaju5.jpg" alt="截屏2020-07-08 下午2.07.52"></p>
<p>上次出现该问题时，只是偶然重试了几次后突然不再报错了，但这次新建项目后又一次报错，并没有找到问题根源，先注释掉。以后再找</p>
<h1><span id="jie-jue-ban-fa">解决办法</span><a href="#jie-jue-ban-fa" class="header-anchor"></a></h1>]]></content>
      <categories>
        <category>CODING</category>
        <category>报错记录</category>
      </categories>
      <tags>
        <tag>Spring actuator</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse的环境配置之导入运行时环境</title>
    <url>/2020/01/01/CODING/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/eclipse%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B9%8B%E5%AF%BC%E5%85%A5%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<blockquote>
<p>由于在eclipse中删除了一个本地服务配置而引起的报错</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#bao-cuo-huan-jing">报错环境</a></li>
<li><a href="#bao-cuo-nei-rong">报错内容</a></li>
<li><a href="#bao-cuo-yuan-yin">报错原因</a></li>
<li><a href="#jie-jue-ban-fa">解决办法</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="bao-cuo-huan-jing">报错环境</span><a href="#bao-cuo-huan-jing" class="header-anchor"></a></h1><p>在移除了工作区中的server后，某一个依赖的项目突然显示报错，并且在配置好重新下载的tomcat后也并没有自动取消报错。</p>
<h1><span id="bao-cuo-nei-rong">报错内容</span><a href="#bao-cuo-nei-rong" class="header-anchor"></a></h1><p>报错信息如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcb977k6prj315f02fjry.jpg" alt="错误提示1"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcb985b1umj30qj06kt9w.jpg" alt="错误提示2"></p>
<h1><span id="bao-cuo-yuan-yin">报错原因</span><a href="#bao-cuo-yuan-yin" class="header-anchor"></a></h1><p>根据报错错误窗口的提示来看，显然是没有找到tomcat提供的运行时环境javax.http.servlet.HttpServletRequest和javax.http.servlet.HttpServletResponse两个类（该项目没有使用maven构建工具）。于是顺着这个思路和错误提示中出现的build path提示，我在项目的properties中找到java build path，在其中的Librarys页面下添加上了之前因为删除本地server而丢失的依赖包，即可解决。</p>
<h1><span id="jie-jue-ban-fa">解决办法</span><a href="#jie-jue-ban-fa" class="header-anchor"></a></h1><p>右键项目名称，打开properties，在里面搜索“build path”，进如“java build path”，在Libraries窗口下添加项目</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcb9kq4sf1j30s70f9gnv.jpg" alt="截屏2020-02-27下午9.08.46"></p>
<p>选择“Add Library”添加依赖包，选择“Server Runtime”，在里面找到自己重新配置好的server环境即可。</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcb9mlopkcj30rx0ezjvg.jpg" alt="截屏2020-02-27下午9.10.00"></p>
<p>问题解决</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>报错记录</category>
      </categories>
      <tags>
        <tag>eclipse报错</tag>
        <tag>运行时环境</tag>
      </tags>
  </entry>
  <entry>
    <title>maven项目中的junit依赖变灰色无法使用的情况</title>
    <url>/2020/01/01/CODING/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/maven%E9%A1%B9%E7%9B%AE%E7%9A%84junit%E4%BE%9D%E8%B5%96%E5%8F%98%E7%81%B0%E8%89%B2%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<blockquote>
<p>在使用eclipse创建maven项目后，出现junit的jar包和hamcrest的jar包变为灰色的情况</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#wen-ti-miao-shu">问题描述</a></li>
<li><a href="#wen-ti-fen-xi">问题分析</a></li>
<li><a href="#jie-jue-ban-fa">解决办法</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="wen-ti-miao-shu">问题描述</span><a href="#wen-ti-miao-shu" class="header-anchor"></a></h1><p>创建maven项目后，出现junit的jar包和hamcrest的jar包变为灰色的情况。如下图</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcbbasuuapj30gw0ddtbm.jpg" alt="maven依赖"></p>
<p>并且在项目中也无法使用Junit进行@Test测试</p>
<p><img src="../../../../../Library/Application%20Support/typora-user-images/%E6%88%AA%E5%B1%8F2020-02-27%E4%B8%8B%E5%8D%8810.10.46.png" alt="截屏2020-02-27下午10.10.46"></p>
<h1><span id="wen-ti-fen-xi">问题分析</span><a href="#wen-ti-fen-xi" class="header-anchor"></a></h1><p>导致这个问题的原因是在maven工程的pom.xml文件中定义junit依赖时，scoup范围标签指定成了test，所以在前期编写时无法导入使用，只能在maven test生命周期中使用，与ide中配置的Libraries不同。所以只能用作maven test命令的时候使用</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcbbj8qh3jj30mv05q0tn.jpg" alt="截屏2020-02-27下午10.16.49"></p>
<h1><span id="jie-jue-ban-fa">解决办法</span><a href="#jie-jue-ban-fa" class="header-anchor"></a></h1><p>这里的结局办法有多种，根据每个人不同的编程风格而定</p>
<ol>
<li>最简单的方法，去掉pom文件中的<scope>test标签，直接使用，但这样的问题是打包时会将junit包一同打包进去。</scope></li>
<li>保留scope标签，在ide的build path环境配置Libraries中导入junit依赖，maven测试时使用maven提供的junit，编写程序测试时使用ide提供的junit。</li>
<li>养成良好的编程风格，并努力提升水平，只在必要的时候使用maven test进行测试。</li>
</ol>
]]></content>
      <categories>
        <category>CODING</category>
        <category>报错记录</category>
      </categories>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>使用jstl时出错</title>
    <url>/2020/01/01/CODING/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8jstl%E6%97%B6%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<blockquote>
<p>在项目的页面中使用到jstl这个工具，但是将项目部署到server上运行时却报错的总结</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#bao-cuo-miao-shu">报错描述</a></li>
<li><a href="#bao-cuo-yuan-yin">报错原因</a></li>
<li><a href="#jie-jue-ban-fa">解决办法</a></li>
<li><a href="#fu-tld-zhu-yu-jie-shi">附：TLD术语解释：</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="bao-cuo-miao-shu">报错描述</span><a href="#bao-cuo-miao-shu" class="header-anchor"></a></h1><p>在maven项目中配置了jstl工具后，并在启动项目时出现如下问题：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcbej9he1aj30nw06tn20.jpg" alt="img"></p>
<h1><span id="bao-cuo-yuan-yin">报错原因</span><a href="#bao-cuo-yuan-yin" class="header-anchor"></a></h1><p>第一次报错原因：pom.xml文件中对jstl引用错误</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcbibred8cj30j8072jrz.jpg" alt="jstl引用"></p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcbigxfvtrj30de09dgm7.jpg" alt="截屏2020-02-28上午2.14.12"></p>
<p>第二次报错原因：没有加入standard.jar</p>
<h1><span id="jie-jue-ban-fa">解决办法</span><a href="#jie-jue-ban-fa" class="header-anchor"></a></h1><p>在maven的依赖中写成如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp.jstl/jstl-api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/taglibs/standard --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1><span id="fu-tld-zhu-yu-jie-shi">附：TLD术语解释：</span><a href="#fu-tld-zhu-yu-jie-shi" class="header-anchor"></a></h1><p>标签库描述文件，如要在JSP页面中实现JSP标签，必须首先定义实现标签的类，然后在标签库描述文件（TLD）中，将写好的类映射成JSP标签,最后在JSP文件中使用定义好的标签，就可以生成动态的JSP内容。<br>作用：他把页面标签和后面的java类影射起来.减少了页面中的代码。使页面清晰。其实标签最后还是被解释成后台的Java代码。</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>报错记录</category>
      </categories>
  </entry>
  <entry>
    <title>报错&quot;javax.net.ssl.SSLException:Unrecognized SSL message,plaintext connection&quot;的解决方法</title>
    <url>/2020/07/20/CODING/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/%E6%8A%A5%E9%94%99%22javax.net.ssl.SSLException:Unrecognized%20SSL%20message,plaintext%20connection%22%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#bao-cuo-huan-jing">报错环境</a></li>
<li><a href="#bao-cuo-nei-rong">报错内容</a></li>
<li><a href="#bao-cuo-yuan-yin">报错原因</a></li>
<li><a href="#jie-jue-ban-fa">解决办法</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="bao-cuo-huan-jing">报错环境</span><a href="#bao-cuo-huan-jing" class="header-anchor"></a></h1><p>配置ElasticSearch的Search-Guard时，需要配置HttpHost，并进行ssl连接配置好后运行。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggyunpta42j30y80aut9u.jpg" alt="截屏2020-07-21 下午8.07.39"></p>
<h1><span id="bao-cuo-nei-rong">报错内容</span><a href="#bao-cuo-nei-rong" class="header-anchor"></a></h1><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggyunw5hrej318q0madjm.jpg" alt="截屏2020-07-21 下午7.52.36"></p>
<h1><span id="bao-cuo-yuan-yin">报错原因</span><a href="#bao-cuo-yuan-yin" class="header-anchor"></a></h1><p>根据Caused by提示信息查询后得知是SSL配置错误，具体部分为HttpHost中SCHEMA配置错误</p>
<h1><span id="jie-jue-ban-fa">解决办法</span><a href="#jie-jue-ban-fa" class="header-anchor"></a></h1><p>将SCHEMA的“https”请求改为“http”请求。</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>报错记录</category>
      </categories>
  </entry>
  <entry>
    <title>【转】解决log4j.xml问题http//jakarta.apache.org/log4j/ uri is not registered问题.md</title>
    <url>/2020/03/20/CODING/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/%E3%80%90%E8%BD%AC%E3%80%91%E8%A7%A3%E5%86%B3log4j.xml%E9%97%AE%E9%A2%98httpjakarta.apache.orglog4j%20uri%20is%20not%20registered%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>描述如题<br>原文链接:<a href="https://blog.csdn.net/john_f_lau/article/details/27098087" target="_blank" rel="noopener">https://blog.csdn.net/john_f_lau/article/details/27098087</a></p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#jie-jue-fang-fa">解决方法</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>配置log4j.xml出现<a href="http://jakarta.apache.org/log4j/" target="_blank" rel="noopener">http://jakarta.apache.org/log4j/</a> 红色提示：uri is not registered”的错误信息。</p>
<p>原始的log4j.xml配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="GB2312" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">log4j</span>:configuration <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"log4j.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">"http://jakarta.apache.org/log4j/"</span>  <span class="attr">debug</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1><span id="jie-jue-fang-fa">解决方法</span><a href="#jie-jue-fang-fa" class="header-anchor"></a></h1><p>具体修改如下所示。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="GB2312" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">log4j</span>:configuration <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/xml/doc-files/log4j.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">debug</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>报错记录</category>
      </categories>
      <tags>
        <tag>报错记录</tag>
        <tag>log4j</tag>
      </tags>
  </entry>
  <entry>
    <title>警告————使用maven创建Spring Boot父工程时遇到关于org.springframework.boot:spring-boot-maven-plugin的警告问题</title>
    <url>/2020/07/02/CODING/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8maven%E5%88%9B%E5%BB%BAspringboot%E7%88%B6%E5%B7%A5%E7%A8%8B%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>再跟着项目练习项目时遇到的关于org.springframework.boot:spring-boot-maven-plugin的警告，看着黄色感叹号很不顺眼，为了避免以后升级为Error，必须知根知底的解决掉它</p>
</blockquote>
<a id="more"></a>

<div class="toc">

<!-- toc -->

<ul>
<li><a href="#jing-gao-fa-sheng-huan-jing">警告发生环境</a></li>
<li><a href="#jing-gao">警告</a></li>
<li><a href="#yuan-yin-fen-xi">原因分析</a></li>
<li><a href="#jie-jue-fang-fa">解决方法</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="jing-gao-fa-sheng-huan-jing">警告发生环境</span><a href="#jing-gao-fa-sheng-huan-jing" class="header-anchor"></a></h1><p>很简单的一个项目父工程搭建</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gglwfnqvkoj30ku06gjsa.jpg" alt="项目结构"></p>
<p>刚搭建好，进行<code>mvn clean</code>命令后idea的控制台中出现了这样一个警告</p>
<h1><span id="jing-gao">警告</span><a href="#jing-gao" class="header-anchor"></a></h1><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gglwe6c12ej321g07ugnv.jpg" alt="警告提示"></p>
<h1><span id="yuan-yin-fen-xi">原因分析</span><a href="#yuan-yin-fen-xi" class="header-anchor"></a></h1><p>经过一段时间的查找分析，发现是因为在父工程的pom文件中虽然没有写入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样的父项目，但却在dependencyManagement依赖管理标签中写入了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样的依赖控制，所以maven也将该项目作为一个SpringBoot项目识别（即使没有任何代码，配置等），然而项目中并没有任何启动类，而“org.springframework.boot:spring-boot-maven-plugin”这个插件的首要作用就是在执行maven命令时找到启动类。</p>
<h1><span id="jie-jue-fang-fa">解决方法</span><a href="#jie-jue-fang-fa" class="header-anchor"></a></h1><p>1、既然是父工程，暂时不需要启动类，只是用作包的统一管理，所以完全可以在pom文件中将org.springframework.boot:spring-boot-maven-plugin的相关配置注释掉。</p>
<p>2、在父工程中写一个SpringBoot启动类，但是什么都不做。</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>报错记录</category>
      </categories>
      <tags>
        <tag>org.springframework.boot:spring-boot-maven-plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>网络模型记录与总结</title>
    <url>/2020/06/19/CODING/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>计算机的网络模型是现代计算机基础知识中的重点，光一个OSI模型就已经让人头疼了。</p>
<p>细致的了解报文和协议，对于开发的理解有相当大的帮助！</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#osi-mo-xing">OSI模型</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="osi-mo-xing">OSI模型</span><a href="#osi-mo-xing" class="header-anchor"></a></h1><p><img src="https://uploadfiles.nowcoder.com/images/20170424/635189_1493022497861_331007FBEFE6E1C0DDDEC3AA9B6C58E2" alt="OSI网络模型"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfxed74pcmg30az08mgli.gif" alt="OSI模型2"></p>
<ol>
<li>物理层： RJ45 、 CLOCK 、 IEEE802.3 （中继器，集线器，网关） <strong>-</strong> </li>
<li>数据链路： PPP 、 FR 、 HDLC 、 VLAN 、 MAC （网桥，交换机） <strong>-</strong> </li>
<li>网络层： IP 、 ICMP 、 ARP 、 RARP 、 OSPF 、 IPX 、 RIP 、 IGRP 、 （路由器） <strong>-</strong> </li>
<li>传输层： TCP 、 UDP 、 SPX <strong>-</strong> </li>
<li>会话层： NFS 、 SQL 、 NETBIOS 、 RPC <strong>-</strong> </li>
<li>表示层： JPEG 、 MPEG 、 ASII <strong>-</strong> </li>
<li>应用层： FTP 、 DNS 、 Telnet 、 SMTP 、 HTTP 、 WWW 、 NFS</li>
</ol>
]]></content>
      <categories>
        <category>CODING</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络模型</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式————代理模式</title>
    <url>/2020/03/06/CODING/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>代理模式同样也是在java项目中经常使用的设计模式之一</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#shi-me-shi-dai-li">什么是代理？</a></li>
<li><a href="#jing-tai-dai-li">静态代理</a></li>
<li><a href="#dong-tai-dai-li">动态代理</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="shi-me-shi-dai-li">什么是代理？</span><a href="#shi-me-shi-dai-li" class="header-anchor"></a></h1><p>代理是指<strong>“代理者”</strong>通过<strong>“被代理人”</strong>的授权，替“被代理人”做出某些行为和事件的过程</p>
<p>在生活中：</p>
<p>张三有一套多余的房子想要出租，找到中介，将房子交给中介机构出租，自己什么都不用管。这里的<strong>“张三”</strong>就是<strong>“被代理人”</strong>，<strong>“中介”</strong>就是<strong>“代理者”</strong>。中介可以在履行出租房屋的基础上，做一些如<code>出租前宣传，装修房屋、出租后回首打扫</code>这种在<code>出租房屋</code>这件事本身<strong>前和后</strong>做出一些其他事情。</p>
<p>在编程中：</p>
<p>假设A类有一个a方法，我们想要调用，普通的方法是通过A的实例化对象直接调用a方法。但是使用代理模式后：有一个AProxy类，内部可以调用A的a方法，我们使用的时候也不再直接调用a，而是借助Aproxy的实例化对象来调用a方法。这样一来，可以在a方法的前后新增一些有意义的操作。</p>
<p>而在具体的代码实现中，分为了<strong>“静态代理”</strong>，和<strong>“动态代理”</strong>。</p>
<h1><span id="jing-tai-dai-li">静态代理</span><a href="#jing-tai-dai-li" class="header-anchor"></a></h1><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gffaetl7jxj30r60dz74s.jpg" alt="代理模式UML图"></p>
<p>如上图所示，静态代理的主要实现方法在于：</p>
<p>代理类和真实类都实现了同一个接口，在此之上，代理类内部有一个“被代理类”的成员变量，并通过构造器对其初始化。以此实现调用真正的方法。</p>
<h1><span id="dong-tai-dai-li">动态代理</span><a href="#dong-tai-dai-li" class="header-anchor"></a></h1>]]></content>
      <categories>
        <category>CODING</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式————装饰者模式</title>
    <url>/2020/03/03/CODING/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>“装饰者模式”主要在为对象添加新个性，更改条件等操作的时候，使用“装饰”这一更有弹性的方式，避免了“继承”导致后期不灵活，代码量和关系臃肿，高耦合的缺点。</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#shi-me-shi-zhuang-shi-zhe-mo-shi">什么是“装饰者模式”</a></li>
<li><a href="#mo-shi-shi-xian-yuan-li">模式实现原理</a></li>
<li><a href="#ju-ti-shi-xian-li-zi">具体实现例子</a><ul>
<li><a href="#shi-ji-chang-jing-ju-li">实际场景举例</a></li>
<li><a href="#dai-ma-shi-xian">代码实现</a></li>
</ul>
</li>
<li><a href="#zhuang-shi-zhe-mo-shi-de-te-dian">装饰者模式的特点</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="shi-me-shi-zhuang-shi-zhe-mo-shi">什么是“装饰者模式”</span><a href="#shi-me-shi-zhuang-shi-zhe-mo-shi" class="header-anchor"></a></h1><p>通常一个目标类总会经过一段时间，出现现有功能不足以满足现有需求的情况，需要添加新的功能时，就需要用到装饰者模式，将新功能部分“灵活“的“装饰”到目标类上，而不是像以往只是简单的通过继承来丰富目标类，添加新功能。</p>
<h1><span id="mo-shi-shi-xian-yuan-li">模式实现原理</span><a href="#mo-shi-shi-xian-yuan-li" class="header-anchor"></a></h1><ol>
<li>首先，确定一个“目标类的基础类或者通用接口”，通过继承或实现创建一个装饰者的基础抽象类，以保证“装饰者类”和“目标类”有统一的根。</li>
<li>装饰者基类中只需定义好基础的装饰功能：目标基类成员变量，装饰构造方法，重写接口方法。</li>
<li>最后，通过继承装饰者基类创建多个装饰者类。</li>
<li>装饰者的使用方法：使用传参构造方法装饰目标类（参数中必须有目标类），并返回给目标类对象。</li>
</ol>
<h1><span id="ju-ti-shi-xian-li-zi">具体实现例子</span><a href="#ju-ti-shi-xian-li-zi" class="header-anchor"></a></h1><h2><span id="shi-ji-chang-jing-ju-li">实际场景举例</span><a href="#shi-ji-chang-jing-ju-li" class="header-anchor"></a></h2><p>假设需要编写一个咖啡店的系统，用于记录各类咖啡（美式，摩卡，卡布奇诺……），各种配料（糖，奶，豆丁…….）的实现。这个场景中，每一种咖啡都可以使用不同种类不同数量不同顺序的配料调配，如果每增加一种配料都要继承一次基础父类，那样就会变的十分臃肿，高耦合，且代码量剧增。而使用的“装饰者模式”，便能灵活的记录。</p>
<h2><span id="dai-ma-shi-xian">代码实现</span><a href="#dai-ma-shi-xian" class="header-anchor"></a></h2><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdc3vcmjgqj30zc0fsq5s.jpg" alt="代码结构"></p>
<p>基础类：饮品</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> HeadFirst.C_Decorator_Pattern.Basic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有饮品的基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="comment">//描述当前饮品</span></span><br><span class="line">    <span class="keyword">public</span> String description = <span class="string">"Unknown Beverage"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String desc)</span></span>&#123;</span><br><span class="line">        description = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查看这种饮品的价格</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>装饰者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> HeadFirst.C_Decorator_Pattern.Basic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有配料类的基础装饰者类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CondimentDecorator</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只写出一种咖啡饮品(DarkRoast)和两种配料(Milk、Mocha)来举例如何“装饰”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> HeadFirst.C_Decorator_Pattern.Beverage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> HeadFirst.C_Decorator_Pattern.Basic.Beverage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的咖啡品种：DarkRoast，通过继承饮品类实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DarkRoast</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在构造时定义对当前咖啡的描述</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DarkRoast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        description = <span class="string">"DarkRoast Coffee"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写当前咖啡的价格</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.89</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Milk</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> HeadFirst.C_Decorator_Pattern.Condiment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> HeadFirst.C_Decorator_Pattern.Basic.Beverage;</span><br><span class="line"><span class="keyword">import</span> HeadFirst.C_Decorator_Pattern.Basic.CondimentDecorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配料的具体实现：牛奶</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了装饰目标类，因此定义一个目标基类作为成员变量，方便装饰时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重点方法：使用传餐构造函数，实现"装饰功能"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Beverage beverage)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为目标类装饰上具体新功能，添加配料描述</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription()+<span class="string">"+Milk"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为目标类装饰上具体新功能，添加配料价格</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">0.4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mocha</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> HeadFirst.C_Decorator_Pattern.Condiment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> HeadFirst.C_Decorator_Pattern.Basic.Beverage;</span><br><span class="line"><span class="keyword">import</span> HeadFirst.C_Decorator_Pattern.Basic.CondimentDecorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配料的具体实现：摩卡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了装饰目标类，因此定义一个目标基类作为成员变量，方便装饰时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Beverage beverage;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重点方法：使用传餐构造函数，实现"装饰功能"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mocha</span><span class="params">(Beverage beverage)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//为目标类装饰上具体新功能，添加配料描述</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription()+<span class="string">"+Mocha"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//为目标类装饰上具体新功能，添加配料价格</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost()+<span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，使用装饰对象制作一杯加奶加摩卡的DarkRoast咖啡</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> HeadFirst.C_Decorator_Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> HeadFirst.C_Decorator_Pattern.Basic.Beverage;</span><br><span class="line"><span class="keyword">import</span> HeadFirst.C_Decorator_Pattern.Beverage.DarkRoast;</span><br><span class="line"><span class="keyword">import</span> HeadFirst.C_Decorator_Pattern.Beverage.Espresso;</span><br><span class="line"><span class="keyword">import</span> HeadFirst.C_Decorator_Pattern.Beverage.HouseBlend;</span><br><span class="line"><span class="keyword">import</span> HeadFirst.C_Decorator_Pattern.Condiment.Mocha;</span><br><span class="line"><span class="keyword">import</span> HeadFirst.C_Decorator_Pattern.Condiment.Soy;</span><br><span class="line"><span class="keyword">import</span> HeadFirst.C_Decorator_Pattern.Condiment.Whip;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StarbuzzCoffee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//注意这里要用多态的方式创建对象</span></span><br><span class="line">        Beverage darkRoast = <span class="keyword">new</span> DarkRoast();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//重点方法：使用装饰者的传参构造方法对咖啡进行装饰————增添配料</span></span><br><span class="line">        darkRoast = <span class="keyword">new</span> Mocha(darkRoast);</span><br><span class="line">        darkRoast = <span class="keyword">new</span> Milk(darkRoast);</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//通过打印描述和价格，可以看到装饰后的效果</span></span><br><span class="line">        System.out.println(darkRoast.description + <span class="string">" cost$"</span> + darkRoast.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="zhuang-shi-zhe-mo-shi-de-te-dian">装饰者模式的特点</span><a href="#zhuang-shi-zhe-mo-shi-de-te-dian" class="header-anchor"></a></h1><p>优点：灵活化，低耦合的实现了对目标类的功能添加</p>
<p>缺点，多次装饰可能出现问题</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式————单例模式</title>
    <url>/2020/03/05/CODING/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>单例模式，是设计模式的基础模式之一。有饿汉式、懒汉式、等方法</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#shi-me-shi-dan-li-mo-shi">什么是“单例模式”？</a></li>
<li><a href="#dan-li-mo-shi-de-shi-yong-chang-jing">“单例模式”的使用场景</a></li>
<li><a href="#dan-li-mo-shi-de-shi-xian-fang-shi">单例模式的实现方式</a><ul>
<li><a href="#e-han-shi-1-zhi-jing-tai-chang-liang-shi-bu-kao-lu-nei-cun-lang-fei-shi-tui-jian">饿汉式1（之静态常量式）——不考虑内存浪费时推荐</a></li>
<li><a href="#e-han-shi-2-zhi-jing-tai-dai-ma-kuai-shi">饿汉式2（之静态代码块式）</a></li>
<li><a href="#lan-han-shi-1-xian-cheng-bu-an-quan">懒汉式1（线程不安全）</a></li>
<li><a href="#lan-han-shi-2-xian-cheng-an-quan-synchronized">懒汉式2（线程安全,synchronized）</a></li>
<li><a href="#lan-han-shi-3-xian-cheng-an-quan-tong-bu-dai-ma-kuai">懒汉式3（线程安全，同步代码块）</a></li>
<li><a href="#shuang-chong-jian-cha-tui-jian">双重检查——推荐</a></li>
<li><a href="#jing-tai-nei-bu-lei-tui-jian">静态内部类——推荐</a></li>
<li><a href="#mei-ju-tui-jian">枚举——推荐</a></li>
</ul>
</li>
<li><a href="#dan-li-mo-shi-zai-jdk-zhong-de-shi-ji-ying-yong-ju-li">单例模式在JDK中的实际应用举例：</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="shi-me-shi-dan-li-mo-shi">什么是“单例模式”？</span><a href="#shi-me-shi-dan-li-mo-shi" class="header-anchor"></a></h1><p>单例模式，是指控制类的实例化对象，保证其只有一个。具体的实现方式有多种</p>
<h1><span id="dan-li-mo-shi-de-shi-yong-chang-jing">“单例模式”的使用场景</span><a href="#dan-li-mo-shi-de-shi-yong-chang-jing" class="header-anchor"></a></h1><p>当创建以下对象时，可以用到单例模式</p>
<ul>
<li>需要频繁进行删除和销毁的对象</li>
<li>创建对象时消耗较多资源（重量级对象），但又经常用到的对象</li>
<li>工具类对象</li>
<li>频繁访问数据库或者文件的对象（如数据源、session工厂等）</li>
</ul>
<h1><span id="dan-li-mo-shi-de-shi-xian-fang-shi">单例模式的实现方式</span><a href="#dan-li-mo-shi-de-shi-xian-fang-shi" class="header-anchor"></a></h1><h2><span id="e-han-shi-1-zhi-jing-tai-chang-liang-shi-bu-kao-lu-nei-cun-lang-fei-shi-tui-jian">饿汉式1（之静态常量式）——不考虑内存浪费时推荐</span><a href="#e-han-shi-1-zhi-jing-tai-chang-liang-shi-bu-kao-lu-nei-cun-lang-fei-shi-tui-jian" class="header-anchor"></a></h2><p>实现方法：在成员变量中直接实例化一个自身实例，并且将构造器私有化，避免外部new，最后提供一个公共方法获取实例。</p>
<p>代码举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * "饿汉式（之静态常量式）"的"单例模式"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将成员变量直接实例化</span></span><br><span class="line">    <span class="comment">// static保证单一，不会分配其他内存地址</span></span><br><span class="line">    <span class="comment">// final保证不会被改写</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">// 将构造器私有化，防止创建多个实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对外提供一个公共接口，获取实例</span></span><br><span class="line">    <span class="comment">// static修饰，保证能够调用静态成员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：这种写法比较简单，而且在类装载的时候就完成实例化。并且基于class loader机制避免了线程同步问题</p>
<p>缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果有多个方法，任意调用一个的时候就实现了类加载，不一定需要该类的实例化时，有可能导致内存浪费。</p>
<h2><span id="e-han-shi-2-zhi-jing-tai-dai-ma-kuai-shi">饿汉式2（之静态代码块式）</span><a href="#e-han-shi-2-zhi-jing-tai-dai-ma-kuai-shi" class="header-anchor"></a></h2><p>与静态常量式几乎相同，只不过将实例化步骤放在了静态代码块中实现，同样也是在类加载的时候，先执行静态代码块中的内容。</p>
<p>优缺点也同上面一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * "饿汉式（之静态代码块式）"的"单例模式"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将成员变量直接实例化</span></span><br><span class="line">    <span class="comment">// static保证单一，不会分配其他内存地址</span></span><br><span class="line">    <span class="comment">// final保证不会被改写</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 使用静态代码块生成实例对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将构造器私有化，防止创建多个实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对外提供一个公共接口，获取实例</span></span><br><span class="line">    <span class="comment">// static修饰，保证能够调用静态成员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="lan-han-shi-1-xian-cheng-bu-an-quan">懒汉式1（线程不安全）</span><a href="#lan-han-shi-1-xian-cheng-bu-an-quan" class="header-anchor"></a></h2><p>将自身的引用实例化过程放入到getInstance方法中实现，也就是什么时候调用该方法，什么时候实例化。与类加载脱离关系</p>
<p>注：线程不安全，只能用于单线程，因此实际开发中不使用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式单例模式，线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒汉式：提供一个共有的方法，当使用到该方法时，才去创建instance</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：实现了LazyLoading的效果</p>
<p>缺点：线程不安全，因为当A线程执行getInstance方法时，进入了if判读，但是还没执行new操作，B线程也进入了，这时就会产生多个实例。从而导致线程不安全</p>
<h2><span id="lan-han-shi-2-xian-cheng-an-quan-synchronized">懒汉式2（线程安全,synchronized）</span><a href="#lan-han-shi-2-xian-cheng-an-quan-synchronized" class="header-anchor"></a></h2><p>在第一种方式的基础上，加入synchronized锁，解决线程安全安全问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式单例模式，线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒汉式：提供一个共有的方法，当使用到该方法时，才去创建instance</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：改进了线程不安全的问题</p>
<p>缺点：效率低下，当有多个线程想要获得实例时，同时进入到getInstance方法进行同步，其实只需实例化代码一次就可以了，但是后面的还需要等待。</p>
<p>实际开发中并不使用该方法。</p>
<h2><span id="lan-han-shi-3-xian-cheng-an-quan-tong-bu-dai-ma-kuai">懒汉式3（线程安全，同步代码块）</span><a href="#lan-han-shi-3-xian-cheng-an-quan-tong-bu-dai-ma-kuai" class="header-anchor"></a></h2><p>该方法是对上一种的稍微改进，将synchronized从方法中提出，放做单独代码块的形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式单例模式，线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒汉式：提供一个共有的方法，当使用到该方法时，才去创建instance</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">        	<span class="keyword">synchronized</span>（Singleton<span class="class">.<span class="keyword">class</span>）</span>&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式表面看上去可以解决多线程等待同步的效率问题，但是实质上只是把同步的条件提升了，并没有实际的解决效率问题。</p>
<p>并且还可能创建出多个实例，不能使用！</p>
<h2><span id="shuang-chong-jian-cha-tui-jian">双重检查——推荐</span><a href="#shuang-chong-jian-cha-tui-jian" class="header-anchor"></a></h2><p>使用volatile关键字修饰实例成员变量，并且进行两次的if(instance == null)判断，开启双重检查：1、检查线程安全问题。2、解决懒加载问题。同时保证了效率。</p>
<p>特点：线程安全，延迟加载，效率较高！</p>
<p>实际开发中推荐使用这种单例设计模式！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用双重检查的懒加载单例模式！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注：volatile关键字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// a、b线程同时到达该处，同时需要获取实例</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// a、b同时进来，进行线程同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="comment">// a先进入，符合判断条件，获得实例</span></span><br><span class="line">                <span class="comment">// b后进入，不符合条件，直接返回instance</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="jing-tai-nei-bu-lei-tui-jian">静态内部类——推荐</span><a href="#jing-tai-nei-bu-lei-tui-jian" class="header-anchor"></a></h2><p>使用静态内部类包含住实例成员变量，借助类加载机制保证初始化实例时只有一个线程</p>
<p>静态内部类SingletonInstace在Singleton被加载时并不会立即实例化，而是在需要实例化时，调用getInstance方法时，才会装载内部类，从而完成实例化；而类的静态属性只会在第一次加载类的时候初始化，所以是借助了JVM帮助我们保证了线程的安全性，在类初始化的时候，别的线程无法进入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用静态内部类实现单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类，该类中有一个静态属性Singleton</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTAANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的共有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTAANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</p>
<h2><span id="mei-ju-tui-jian">枚举——推荐</span><a href="#mei-ju-tui-jian" class="header-anchor"></a></h2><p>使用枚举创建实例，达到单例模式的效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void doSth()&#123;</span><br><span class="line">        System.out.println(&quot;Do SomeThing......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="dan-li-mo-shi-zai-jdk-zhong-de-shi-ji-ying-yong-ju-li">单例模式在JDK中的实际应用举例：</span><a href="#dan-li-mo-shi-zai-jdk-zhong-de-shi-ji-ying-yong-ju-li" class="header-anchor"></a></h1><p>java.lang.Runtime类就是用到了饿汉式的单例模式</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gepkvfhpovj314a0kmn10.jpg" alt="java.lang.Runtime类源码"></p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式————工厂模式</title>
    <url>/2020/03/04/CODING/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>工厂模式是所有设计模式中出现频率超高的模式之一，Spring中也经常用到</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#shi-me-shi-gong-han-mo-shi">什么是“工厂模式”</a></li>
<li><a href="#shi-li-qian-ti">实例前提</a></li>
<li><a href="#jian-dan-gong-han-mo-shi">简单工厂模式</a></li>
<li><a href="#gong-han-fang-fa-mo-shi">工厂方法模式</a></li>
<li><a href="#chou-xiang-gong-han-mo-shi">抽象工厂模式</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="shi-me-shi-gong-han-mo-shi">什么是“工厂模式”</span><a href="#shi-me-shi-gong-han-mo-shi" class="header-anchor"></a></h1><p>顾名思义，工厂的主要职责是生产产品，所以放在java面向对象编程中，即是一种替代了传统的使用“new”关键字生产对象的模式。</p>
<p>这样做有何用处？为什么要用工厂模式代替new方式呢？使用简单的工厂模式，可以从中按照不同条件获取不同的对象</p>
<h1><span id="shi-li-qian-ti">实例前提</span><a href="#shi-li-qian-ti" class="header-anchor"></a></h1><p>在工厂模式的说明中，最有效的方法，</p>
<h1><span id="jian-dan-gong-han-mo-shi">简单工厂模式</span><a href="#jian-dan-gong-han-mo-shi" class="header-anchor"></a></h1><h1><span id="gong-han-fang-fa-mo-shi">工厂方法模式</span><a href="#gong-han-fang-fa-mo-shi" class="header-anchor"></a></h1><p>工厂方法（简单）模式是工厂模式的一种简单实现。利用继承的方法创建对象。</p>
<p>主要分为两大部分：创建者部(Creator)和产品部(Product)，创建者部先定义一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法模式让类把实例化推迟到子类。</p>
<h1><span id="chou-xiang-gong-han-mo-shi">抽象工厂模式</span><a href="#chou-xiang-gong-han-mo-shi" class="header-anchor"></a></h1><p>抽象工厂模式定义了一个创建对象的接口，用于创建相关或依赖对象的家族（如制作产品所需要的原材料），而不需要明确指定具体类。</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2020/06/19/CODING/%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/Git/</url>
    <content><![CDATA[<blockquote>
<p>Git在学计算机的道路上几乎没有被重视过（单独提出作为一门课程讲解），但是在实际工作和公司开发中无比重要。并且掌握好git的详细操作及其原理，可以使工作效率成倍提高。因此单独做一篇详细记录（使用 以及 原理），方便之后复习或查看。</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#git-ming-ling-ji-lu-biao">Git 命令记录表</a></li>
<li><a href="#git-si-xiang-ji-yuan-li">Git 思想及原理</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h1><span id="git-ming-ling-ji-lu-biao">Git 命令记录表</span><a href="#git-ming-ling-ji-lu-biao" class="header-anchor"></a></h1><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">含义</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">git clone</td>
<td align="center">从远程仓库克隆项目到本地</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">git add &lt;文件名&gt;</td>
<td align="center">添加文件到缓存区</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">git commit</td>
<td align="center">添加评价</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h1><span id="git-si-xiang-ji-yuan-li">Git 思想及原理</span><a href="#git-si-xiang-ji-yuan-li" class="header-anchor"></a></h1>]]></content>
      <categories>
        <category>CODING</category>
        <category>零散笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub搜索方式</title>
    <url>/2020/01/01/CODING/%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/GitHub%20%E6%90%9C%E7%B4%A2%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>记录一些在github上搜索的精准方法</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#an-zhao-name-sou-suo">按照 name 搜索</a><ul>
<li><a href="#kong-zhi-star-he-folk-shu">控制star和folk数</a></li>
</ul>
</li>
<li><a href="#an-zhao-readme-lai-sou-suo">按照README来搜索</a><ul>
<li><a href="#kong-zhi-star-he-folk-shu-1">控制star和folk数</a></li>
</ul>
</li>
<li><a href="#an-zhao-descriptin-sou-suo">按照descriptin搜索</a></li>
<li><a href="#zong-jie">总结</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h2><span id="an-zhao-name-sou-suo">按照 name 搜索</span><a href="#an-zhao-name-sou-suo" class="header-anchor"></a></h2><p>搜索项目名里面包含React的项目:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in:name React</span><br></pre></td></tr></table></figure>

<p>得到如下结果：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mhl3jb0j30u00b70tf.jpg" alt="img"></p>
<p>可以看到，这些搜索结果都是项目名里面带有<code>“React”</code>关键字的项目，但是项目数量依旧很多。</p>
<p>现在我们来约束一下</p>
<h3><span id="kong-zhi-star-he-folk-shu">控制star和folk数</span><a href="#kong-zhi-star-he-folk-shu" class="header-anchor"></a></h3><p>比如我再精确到项目的star数大于5000+：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in:name React stars:&gt;5000</span><br></pre></td></tr></table></figure>

<p>结果是这样的：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mhlkqwaj30u00b7mxu.jpg" alt="img"></p>
<p>搜索结果瞬间精确了很多，现在只有114个项目可供选择。当然我们一般不会把star数设置得这么高，一般设置个1000就差不多了。</p>
<p>同理，我们也可以按照fork的数量来进行搜索:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in:name React stars:&gt;5000 forks:&gt;3000</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mhodk1yj30u00b7wf6.jpg" alt="img"></p>
<p>你会发现，结果越来越精确！</p>
<h2><span id="an-zhao-readme-lai-sou-suo">按照README来搜索</span><a href="#an-zhao-readme-lai-sou-suo" class="header-anchor"></a></h2><p>搜索README.md里面包含React的项目:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in:readme React</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mhktes9j30u00b7aap.jpg" alt="img"></p>
<h3><span id="kong-zhi-star-he-folk-shu">控制star和folk数</span><a href="#kong-zhi-star-he-folk-shu" class="header-anchor"></a></h3><p>结果有这么多，那么我们再限制一下它的star数和fork数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in:readme React stars:&gt;3000 forks:&gt;3000</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mhmzlfnj30u00b774x.jpg" alt="img"></p>
<p>搜索结果一下子精确到了90个。这个时候你再去选择项目，就会变得容易很多。</p>
<h2><span id="an-zhao-descriptin-sou-suo">按照descriptin搜索</span><a href="#an-zhao-descriptin-sou-suo" class="header-anchor"></a></h2><p>假设我们现在要学习微服务的项目，我们搜索项目描述(description)里面包含微服务的项目:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in:description 微服务</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mhm16zqj30u00b7dge.jpg" alt="img"></p>
<p>结果有这么多，那我们接着增加一些筛选条件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in:description 微服务 language:python</span><br></pre></td></tr></table></figure>

<p>language:python的意思是我们把语言限制为python，我们来看看结果如何:</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mhmio3nj30u00b7q3j.jpg" alt="img"></p>
<p>搜索结果精确了很多。</p>
<p>假如在这些项目里面，我们想要找到最近才更新的项目，意思是更新时间就在最近，我们可以这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in:description 微服务 language:python pushed:&gt;2020-01-01</span><br></pre></td></tr></table></figure>

<p><code>pushed:&gt;2020-01-01</code>的意思是我们把项目的最后更新时间限制到2020-01-01，我们来看看结果如何:</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mhnwpxuj30u00b7t9a.jpg" alt="img"></p>
<p>搜索结果只有8个了，这几个项目就属于更新比较活跃的项目，这下再也不纠结了。更多原理与实践，可以在订阅号“码匠笔记”后台回复“原理与实践”，N+1篇热文免费获取。</p>
<h2><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h2><p>三种搜索区域</p>
<ul>
<li><p>in:name xxx // 按照项目名搜索</p>
</li>
<li><p>in:readme xxx // 按照README搜索</p>
</li>
<li><p>in:description xxx // 按照description搜索</p>
</li>
</ul>
<p>筛选条件</p>
<ul>
<li><p>stars:&gt;xxx // stars数大于xxx</p>
</li>
<li><p>forks:&gt;3000 // forks数大于xxx</p>
</li>
<li><p>language:xxx // 编程语言是xxx</p>
</li>
<li><p>pushed:&gt;YYYY-MM-DD // 最后更新时间大于YYYY-MM-DD</p>
</li>
</ul>
<p>以上就是我们在GitHub上面精准搜索项目的一些小技巧，希望对你有所帮助！</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>零散笔记</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2020/01/01/CODING/%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/Maven/</url>
    <content><![CDATA[<blockquote>
<p>Maven是一种构建化工具，最主要的功能是帮助我们管理jar包的依赖，以及对我们项目的编译、测试、部署等功能。这篇文章作为maven入门的总结，将集中介绍maven的相关概念和用法、配置等</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#maven-yue-ding-de-mu-lu-jie-gou">maven约定的目录结构</a><ul>
<li><a href="#bu-chong-2-eclipse-zhong-ju-ti-web-gong-cheng-shi-tu-de-ju-ti-jie-shi">补充2：eclipse中具体web工程视图的具体解释</a></li>
</ul>
</li>
<li><a href="#chang-yong-ming-ling">常用命令：</a></li>
<li><a href="#zuo-biao">坐标</a></li>
<li><a href="#cang-ku">仓库</a></li>
<li><a href="#maven-yi-lai-de-xiang-guan-wen-ti">maven依赖的相关问题</a><ul>
<li><a href="#yi-lai-fang-shi-de-pei-zhi">依赖方式的配置：</a></li>
<li><a href="#yi-lai-fang-shi-de-fan-wei">依赖方式的范围：</a></li>
<li><a href="#wen-ti-zong-jie">问题总结</a></li>
</ul>
</li>
<li><a href="#tong-yi-pei-zhi">统一配置</a></li>
<li><a href="#ji-cheng-xiang-mu">继承项目</a></li>
<li><a href="#ju-he-xiang-mu">聚合项目</a></li>
<li><a href="#maven-cang-ku-wang-zhi">Maven仓库网址</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="maven-yue-ding-de-mu-lu-jie-gou">maven约定的目录结构</span><a href="#maven-yue-ding-de-mu-lu-jie-gou" class="header-anchor"></a></h1><p>根目录（工程名）<br>——src目录<br>——|———-|main目录<br>——|———-|————｜java目录<br>——|———-|————｜resource目录<br>——|———-|test目录<br>——|———-|————｜java目录<br>——|———-|————｜resource目录<br>——target目录（mvn编译后自动生成的目录，存放.class和其他报告等文件）<br>—— <font color="Red">pom.xml</font></p>
<p>补充1:约定 &gt; </p>
<h2><span id="bu-chong-2-eclipse-zhong-ju-ti-web-gong-cheng-shi-tu-de-ju-ti-jie-shi">补充2：eclipse中具体web工程视图的具体解释</span><a href="#bu-chong-2-eclipse-zhong-ju-ti-web-gong-cheng-shi-tu-de-ju-ti-jie-shi" class="header-anchor"></a></h2><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc3dbwduwqj30o80fzmyh.jpg" alt="eclipse上的项目目录映射"></p>
<h1><span id="chang-yong-ming-ling">常用命令：</span><a href="#chang-yong-ming-ling" class="header-anchor"></a></h1><p>mvn clean:                清理</p>
<p>mvn compile:            编译主程序</p>
<p>mvn test:                    测试</p>
<p>man test-compile:    编译测试程序</p>
<p>mvn package:            打包（war、jar）</p>
<p>man install:                安装（mvn特有，将自己的项目安装到本地仓库中）</p>
<p>maven deploy：        自动部署到tomcat（需要配置构建插件）</p>
<p>mvn site:                    生成站点</p>
<h1><span id="zuo-biao">坐标</span><a href="#zuo-biao" class="header-anchor"></a></h1><p><strong>坐标规范：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>公司组织域名倒序 + 工程名<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>项目名<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>版本<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>根据坐标在仓库中找到jar包的具体路径：</strong></p>
<p>【groupId】/【artifaceId】/【version】/【artifactId】-【version】.jar</p>
<h1><span id="cang-ku">仓库</span><a href="#cang-ku" class="header-anchor"></a></h1><p>仓库的分类</p>
<ul>
<li>本地仓库：在自己电脑上部署的仓库</li>
<li>远程仓库：<ul>
<li>私服：在局域网中的Maven仓库</li>
<li>中央仓库：网络上的总仓库</li>
<li>中央仓库镜像：中央仓库在各个地区的镜像</li>
</ul>
</li>
</ul>
<h1><span id="maven-yi-lai-de-xiang-guan-wen-ti">maven依赖的相关问题</span><a href="#maven-yi-lai-de-xiang-guan-wen-ti" class="header-anchor"></a></h1><h2><span id="yi-lai-fang-shi-de-pei-zhi">依赖方式的配置：</span><a href="#yi-lai-fang-shi-de-pei-zhi" class="header-anchor"></a></h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>依赖名【默认compile】<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2><span id="yi-lai-fang-shi-de-fan-wei">依赖方式的范围：</span><a href="#yi-lai-fang-shi-de-fan-wei" class="header-anchor"></a></h2><table>
<thead>
<tr>
<th align="center">取值</th>
<th align="center">对主程序是否有效</th>
<th align="center">对测试程序是否有效</th>
<th align="center">是否参与打包</th>
<th align="center">是否参与部署</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">compile</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">spring-core</td>
</tr>
<tr>
<td align="center">test</td>
<td align="center">❌</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">junit</td>
</tr>
<tr>
<td align="center">provided</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">servlet-api.jar</td>
</tr>
</tbody></table>
<h2><span id="wen-ti-zong-jie">问题总结</span><a href="#wen-ti-zong-jie" class="header-anchor"></a></h2><p>依赖的冲突：provided范围的依赖是指在调试期间需要，但是服务器中自带，不能一同打包部署，否则会出现“NULLException”报错。</p>
<p>依赖的传递性：A项目所有compile类型依赖会给依赖A项目的B项目导入同样的依赖，而其他非compile类型则不会。</p>
<p>依赖的排除：若A项目依赖B项目，但当我们依赖A时不希望自动依赖B，就可以在A项目中的最后通过如下标签进行排除</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>依赖冲突：A项目在某一层依赖junit1.2.17，B项目在某一层中依赖junit 1.2.27，我的项目同时依赖A项目和B项目，那么junit的两个版本就有了冲突。路径长度不同的情况下，maven使用最短路径长度依赖，路径长度相同的情况下，maven优先继承配置文件中靠前的版本。</p>
<h1><span id="tong-yi-pei-zhi">统一配置</span><a href="#tong-yi-pei-zhi" class="header-anchor"></a></h1><p>pom.xml配置文件中可以使用properties管理统一的配置，方便统一修改，如Spring各个部分的统一版本号，字符编码等</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">自定义的标签名</span>&gt;</span>配置值<span class="tag">&lt;/<span class="name">自定义的标签名</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引用方法 --&gt;</span></span><br><span class="line">$&#123;自定义的标签名&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="ji-cheng-xiang-mu">继承项目</span><a href="#ji-cheng-xiang-mu" class="header-anchor"></a></h1><p>区别于properties中的统一配置，只能对一个模块中的依赖进行统一版本号等配置。但如果想要统一管理不同模块下的相同依赖的版本号等，就需要用到继承机制，即创建一个父模块，让所有的子模块都继承该父模块即可在父模块下统一管理某一个依赖，具体配置方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父项目下的pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>公司组织域名倒序 + 项目名<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>模块名<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>版本<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子项目下的pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 父工程坐标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>以当前项目为基准的父工程pom.xml文件的相对路径/<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之后在父项目中配置好具体的统一依赖后，子项目中所有的这个依赖便不再需要写明版本号了</p>
<h1><span id="ju-he-xiang-mu">聚合项目</span><a href="#ju-he-xiang-mu" class="header-anchor"></a></h1><p>聚合项目主要用于对多个项目进行统一maven操作，如打包，安装，部署等，一般情况下和继承关系一起配置在一个父项目中，但也可以分开，不是必须在同一个项目中，具体配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在总工程下配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">models</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">model</span>&gt;</span>要聚合的第一个项目的相对路径<span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">model</span>&gt;</span>要聚合的第二个项目的相对路径<span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">model</span>&gt;</span>要聚合的第三个项目的相对路径<span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">model</span>&gt;</span>......<span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">models</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样一来，直接在该总工程下进行maven命令即可一键安装等操作</p>
<h1><span id="maven-cang-ku-wang-zhi">Maven仓库网址</span><a href="#maven-cang-ku-wang-zhi" class="header-anchor"></a></h1><p>需要导入依赖坐标的时候就到这个网址查找具体的坐标怎么写</p>
<p><a href="https://mvnrepository.com/" target="_blank" rel="noopener">https://mvnrepository.com/</a></p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc4ezyxgghj31gp0u0au1.jpg" alt="截屏2020-02-21下午10.57.45"></p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>零散笔记</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Lombok记录</title>
    <url>/2020/01/01/CODING/%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/Lombok%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>Lombok的配置以及简单注释说明.</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#shi-yong-tiao-jian">使用条件</a></li>
<li><a href="#lombok-zhu-jie-xiang-jie">Lombok注解详解</a><ul>
<li><a href="#getter-he-setter"><strong>@Getter和@Setter</strong></a></li>
<li><a href="#tostring"><strong>@ToString</strong></a></li>
<li><a href="#equalsandhashcode"><strong>@EqualsAndHashCode</strong></a></li>
<li><a href="#nonnull"><strong>@NonNull</strong></a></li>
<li><a href="#noargsconstructor-requiredargsconstructor-allargsconstructor"><strong>@NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor</strong></a></li>
<li><a href="#data"><strong>@Data</strong></a></li>
<li><a href="#builder"><strong>@Builder</strong></a></li>
<li><a href="#log"><strong>@Log</strong></a></li>
<li><a href="#val"><strong>val</strong></a></li>
<li><a href="#cleanup"><strong>@Cleanup</strong></a></li>
</ul>
</li>
<li><a href="#zong-jie">总结</a></li>
<li><a href="#guan-wang">官网：</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="shi-yong-tiao-jian">使用条件</span><a href="#shi-yong-tiao-jian" class="header-anchor"></a></h1><p>在Repositories中搜索Lombok，安装后重启IDE即可</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mxwidcsj30u00g7752.jpg" alt="img"></p>
<p>在Maven或Gradle工程中添加依赖</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mxx6j3pj30u009gaan.jpg" alt="img"></p>
<h1><span id="lombok-zhu-jie-xiang-jie">Lombok注解详解</span><a href="#lombok-zhu-jie-xiang-jie" class="header-anchor"></a></h1><p>Lombok官网提供了许多注解，但是 “劲酒虽好，可不要贪杯哦”，接下来逐一讲解官网推荐使用的注解(有些注解和原有Java编写方式没太大差别的也没有在此处列举，如@ Synchronized等)</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6myxap8yj30u00cqdgn.jpg" alt="img"></p>
<h2><span id="getter-he-setter"><strong>@Getter和@Setter</strong></span><a href="#getter-he-setter" class="header-anchor"></a></h2><p>该注解可应用在类或成员变量之上，和我们预想的一样，<code>@Getter</code> 和 <code>@Setter</code> 就是为成员变量自动生成 get 和 set 方法，默认生成访问权限为 public 方法，当然我们也可以指定访问权限 protected 等，如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6myufocmj30u00cpt9t.jpg" alt="img"></p>
<p>成员变量name指定生成set方法，并且访问权限为protected；boolean类型的成员变量 female 只生成get方法，并修改方法名称为 isFemale()。当把该注解应用在类上，默认为所有非静态成员变量生成 get 和 set 方法，也可以通过 AccessLevel.NONE 手动禁止生成get或set方法，如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6myp0f75j30u00eqgn2.jpg" alt="img"></p>
<h2><span id="tostring"><strong>@ToString</strong></span><a href="#tostring" class="header-anchor"></a></h2><p>该注解需应用在类上，为我们生成 Object 的 toString 方法，而该注解里面的几个属性能更加丰富我们想要的内容, <code>exclude</code> 属性禁止在 toString 方法中使用某字段，而of属性可以指定需要使用的字段，如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mywfkv3j30u008c0tc.jpg" alt="img"></p>
<p>查看编译后的Employee.class得到我们预期的结果，如下图</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6myq9d60j30u006qjrn.jpg" alt="img"></p>
<h2><span id="equalsandhashcode"><strong>@EqualsAndHashCode</strong></span><a href="#equalsandhashcode" class="header-anchor"></a></h2><p>该注解需应用在类上，使用该注解，lombok会为我们生成 equals(Object other) 和 hashcode() 方法，包括所有非静态属性和非transient的属性，同样该注解也可以通过 exclude 属性排除某些字段，of 属性指定某些字段，也可以通过 callSuper 属性在重写的方法中使用父类的字段，这样我们可以更灵活的定义bean的比对，如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6myt0d0bj30u007w0td.jpg" alt="img"></p>
<p>查看编译后的Employee.class文件，如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mz06qxhj30u00pztak.jpg" alt="img"></p>
<h2><span id="nonnull"><strong>@NonNull</strong></span><a href="#nonnull" class="header-anchor"></a></h2><p>该注解需应用在方法或构造器的参数上或属性上，用来判断参数的合法性，默认抛出 NullPointerException 异常</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6myuwjt0j30o609g75c.jpg" alt="img"></p>
<p>查看NonNullExample.class文件，会为我们抛出空指针异常，如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mypsfnbj30o80cwdgx.jpg" alt="img"></p>
<p>当然我们可以通过指定异常类型抛出其他异常，lombok.nonNull.exceptionType = [NullPointerException | IllegalArgumentException] , 为实现此功能我们需要在项目的根目录新建lombok.config文件：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsg7gJ53pKBMtoiaSA2XESJplyAicsSRicGibReicAUfL34cknU1UYn5Von3DvLzFaa2d1pwhA2BltetuLg/640?wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>重新编译NonNullExample类，已经为我们抛出非法参数异常：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6myqstu7j30ts0dwq4c.jpg" alt="img"></p>
<h2><span id="noargsconstructor-requiredargsconstructor-allargsconstructor"><strong>@NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor</strong></span><a href="#noargsconstructor-requiredargsconstructor-allargsconstructor" class="header-anchor"></a></h2><p>以上三个注解分别为我们生成无参构造器，指定参数构造器和包含所有参数的构造器，默认情况下，<code>@RequiredArgsConstructor</code>, <code>@AllArgsConstructor</code> 生成的构造器会对所有标记 <code>@NonNull</code> 的属性做非空校验。</p>
<p>无参构造器很好理解，我们主要看看后两种，先看 <code>@RequiredArgsConstructor</code></p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6myyuwggj30u00ju3zw.jpg" alt="img"></p>
<p>从上图中我们可以看出， <code>@RequiredArgsConstructor</code> 注解生成有参数构造器时只会包含有 final 和 <code>@NonNull</code> 标识的 field，同时我们可以指定 staticName 通过生成静态方法来构造对象</p>
<p>查看Employee.class文件</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6myu34xij30u00e0753.jpg" alt="img"></p>
<p>当我们把 staticName 属性去掉我们来看遍以后的文件:</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6myvf8vmj30u00f40tm.jpg" alt="img"></p>
<h2><span id="data"><strong>@Data</strong></span><a href="#data" class="header-anchor"></a></h2><p>介绍了以上的注解，再来介绍 <code>@Data</code> 就非常容易懂了，<code>@Data</code> 注解应用在类上，是<code>@ToString</code>, <code>@EqualsAndHashCode</code>, <code>@Getter / @Setter</code> 和 <code>@RequiredArgsConstructor</code>合力的体现，如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6myrn8hnj30u00f9jso.jpg" alt="img"></p>
<h2><span id="builder"><strong>@Builder</strong></span><a href="#builder" class="header-anchor"></a></h2><p>函数式编程或者说流式的操作越来越流行，应用在大多数语言中，让程序更具更简介，可读性更高，编写更连贯，<code>@Builder</code>就带来了这个功能，生成一系列的builder API，该注解也需要应用在类上，看下面的例子就会更加清晰明了。</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mypak4rj30u00bcmxw.jpg" alt="img"></p>
<p>编译后的Employee.class文件如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mys5rfrj30u00iuwfh.jpg" alt="img"></p>
<p>妈妈再也不用担心我 set 值那么麻烦了，流式操作搞定：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mysosrsj30r603gdg3.jpg" alt="img"></p>
<h2><span id="log"><strong>@Log</strong></span><a href="#log" class="header-anchor"></a></h2><p>该注解需要应用到类上，在编写服务层，需要添加一些日志，以便定位问题，我们通常会定义一个静态常量Logger，然后应用到我们想日志的地方，现在一个注解就可以实现：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mytizioj30sq0e20u5.jpg" alt="img"></p>
<p>查看class文件，和我们预想的一样：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mywr9rkj30u009o0v8.jpg" alt="img"></p>
<p>Log有很多变种，CommonLog，Log4j，Log4j2，Slf4j等，lombok依旧良好的通过变种注解做良好的支持：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6mz0i52nj30u00d875x.jpg" alt="img"></p>
<p>我实际使用的是 <code>@Slf4j</code> 注解</p>
<h2><span id="val"><strong>val</strong></span><a href="#val" class="header-anchor"></a></h2><p>熟悉 Javascript 的同学都知道，var 可以定义任何类型的变量，而在 java 的实现中我们需要指定具体变量的类型，而 val 让我们摆脱指定，编译之后就精准匹配上类型，默认是 final 类型，就像 java8 的函数式表达式，()-&gt;System.out.println(“hello lombok”); 就可以解析到Runnable函数式接口。</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6myxuupoj30js0gm0u1.jpg" alt="img"></p>
<p>查看解析后的class文件：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6myvxhu3j30mc0e075i.jpg" alt="img"></p>
<h2><span id="cleanup"><strong>@Cleanup</strong></span><a href="#cleanup" class="header-anchor"></a></h2><p>当我们对流进行操作，我们通常需要调用 close 方法来关闭或结束某资源，而 @Cleanup 注解可以帮助我们调用 close 方法，并且放到 try/finally 处理块中，如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6myzc6xtj30rk0gswgf.jpg" alt="img"></p>
<p>编译后的class文件如下，我们发现被try/finally包围处理，并调用了流的close方法</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6myy7jwpj30tc0y2gns.jpg" alt="img"></p>
<p>其实在 JDK1.7 之后就有了 <code>try-with-resource</code>，不用我们显式的关闭流，这个请大家自行看吧</p>
<h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h1><p>Lombok的基本操作流程是这样的：</p>
<p>\1. 定义编译期的注解</p>
<p>\2. 利用JSR269 api(Pluggable Annotation Processing API )创建编译期的注解处理器</p>
<p>\3. 利用tools.jar的javac api处理AST(抽象语法树)</p>
<p>\4. 将功能注册进jar包</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6myr57yxj309t0kzq3b.jpg" alt="img"></p>
<p>Lombok 当然还有很多注解，我推荐使用以上就足够了，这个工具是带来便利的，而不能被其捆绑，Lombok 能让我更加专注有效代码排除意义微小的障眼代码（get，set等），另外Lombok生成的代码还能像使用工具类一样方便（@Builder）。</p>
<h1><span id="guan-wang">官网：</span><a href="#guan-wang" class="header-anchor"></a></h1><p><a href="https://www.projectlombok.org/" target="_blank" rel="noopener">lombok官网</a></p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>零散笔记</category>
      </categories>
      <tags>
        <tag>lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>REST规范</title>
    <url>/2020/01/01/CODING/%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/REST%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<blockquote>
<p>这是一篇我对REST理解的文</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#gai-nian">概念</a></li>
<li><a href="#shi-ji-yong-ti">实际用题</a></li>
<li><a href="#can-kao-wen-zhang">参考文章：</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<h1><span id="gai-nian">概念</span><a href="#gai-nian" class="header-anchor"></a></h1><h1><span id="shi-ji-yong-ti">实际用题</span><a href="#shi-ji-yong-ti" class="header-anchor"></a></h1><h1><span id="can-kao-wen-zhang">参考文章：</span><a href="#can-kao-wen-zhang" class="header-anchor"></a></h1><p><a href="http://www.infoq.com/cn/articles/rest-introduction" target="_blank" rel="noopener">深入浅出 REST</a><br><a href="http://kb.cnblogs.com/page/186516/" target="_blank" rel="noopener">理解本真的REST架构风格</a></p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>零散笔记</category>
      </categories>
      <tags>
        <tag>REST</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse中打开spring的xml配置文件只显示beans</title>
    <url>/2020/04/11/CODING/%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/eclipse%E4%B8%AD%E6%89%93%E5%BC%80spring%E7%9A%84xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%AA%E6%98%BE%E7%A4%BAbeans/</url>
    <content><![CDATA[<blockquote>
<p>在使用了很久idea之后用回eclipse后，发现创建的spring bean config file中的namespace栏中只有bean空间，无法添加其他的命名空间的情况</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdq9pwzctkj30iu0pomyo.jpg" alt="截屏2020-04-11下午11.57.50"></p>
<p>可以看到这里没有其他命名空间只有一个beans，修改方法如下：</p>
<ol>
<li>打开首选项（Preference） — Spring — NameSpace</li>
<li>取消勾选“Load NamespacesHandlers and XSDs from Project’s classpath”</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqa6lfdkbj311c0q212p.jpg" alt="截屏2020-04-11下午4.48.53"></p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>零散笔记</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>软件设计思想记录</title>
    <url>/2020/01/01/CODING/%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<blockquote>
<p>记录一些和软件工程相关的知识</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#pu-bu-mo-shi-gong-ye-biao-zhun-hua-kai-fa">瀑布模式（工业标准化开发）</a></li>
<li><a href="#min-jie-kai-fa-sheng-wu-jin-hua-xing-kai-fa">敏捷开发（生物进化型开发）</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="pu-bu-mo-shi-gong-ye-biao-zhun-hua-kai-fa">瀑布模式（工业标准化开发）</span><a href="#pu-bu-mo-shi-gong-ye-biao-zhun-hua-kai-fa" class="header-anchor"></a></h1><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdosixqqsfj30oc0g80u2.jpg" alt="img"></p>
<h1><span id="min-jie-kai-fa-sheng-wu-jin-hua-xing-kai-fa">敏捷开发（生物进化型开发）</span><a href="#min-jie-kai-fa-sheng-wu-jin-hua-xing-kai-fa" class="header-anchor"></a></h1><p>需求 — 原型 — 编码</p>
<p>加速了用户体验的过程</p>
]]></content>
      <tags>
        <tag>软件设计思路</tag>
      </tags>
  </entry>
  <entry>
    <title>日志系统总结</title>
    <url>/2020/04/02/CODING/%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>总结目前为止所用到的日志系统的，用法，关系，相关知识，如：SLF4J、logback、log4j等……</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#ri-zhi-xi-tong-de-gai-gua">日志系统的概括</a></li>
<li><a href="#bu-tong-ri-zhi-xi-tong-de-zheng-he">不同日志系统的整合</a></li>
<li><a href="#qi-ta">其他</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="ri-zhi-xi-tong-de-gai-gua">日志系统的概括</span><a href="#ri-zhi-xi-tong-de-gai-gua" class="header-anchor"></a></h1><p><strong>门面：</strong> </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>JCL（Jakarta Commons Logging）</td>
<td>陈旧</td>
</tr>
<tr>
<td>SLF4J（Simple Logging Facade for Java）</td>
<td>适合（<strong>同一作者</strong>）</td>
</tr>
<tr>
<td>jboss-logging</td>
<td>特殊专业领域使用</td>
</tr>
</tbody></table>
<p><strong>实现：</strong><br>| 名称 | 说明 |<br>| — | — |<br>| log4j | 最初版（<strong>同一作者</strong>） |<br>| JUL（java.util.logging）| JDK 自带 |<br>| log4j2 | Apache 收购 log4j 后全面重构，内部实现和 log4j 完全不同 |<br>| logback | 优雅、强大（<strong>同一作者</strong>） |</p>
<h1><span id="bu-tong-ri-zhi-xi-tong-de-zheng-he">不同日志系统的整合</span><a href="#bu-tong-ri-zhi-xi-tong-de-zheng-he" class="header-anchor"></a></h1><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdr0yid95jj30x80j0tqg.jpg" alt="截屏2020-04-12下午3.40.13"></p>
<h1><span id="qi-ta">其他</span><a href="#qi-ta" class="header-anchor"></a></h1><p>Spring的自带日志：commons-logging.jar（也成JCL）</p>
<p>使用jcl-over-slf4j代替commons-logging，并连接到slf4j-api，再由slf4j-api转换到logback-classic.jar</p>
<p>需要的maven管理为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在Spring 依赖中排除掉commons-logging --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-orm --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其他日志框架的中间转换包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jul-to-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CODING</category>
        <category>零散笔记</category>
      </categories>
      <tags>
        <tag>日志总结</tag>
      </tags>
  </entry>
  <entry>
    <title>常用配置文件模版</title>
    <url>/2020/01/01/CODING/%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A8%A1%E7%89%88/</url>
    <content><![CDATA[<blockquote>
<p>常用的配置文件或者依赖的模版记录，方便复制粘贴</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#log4j-xml">log4j.xml</a></li>
<li><a href="#c3p0-shu-ju-yuan-zai-spring-zhong-de-pei-zhi">c3p0数据源在spring中的配置</a></li>
<li><a href="#chang-yong-bi-bei-yi-lai">常用必备依赖</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="log4j-xml">log4j.xml</span><a href="#log4j-xml" class="header-anchor"></a></h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">log4j</span>:configuration <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/xml/doc-files/log4j.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">debug</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Encoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span> <span class="attr">value</span>=<span class="string">"%-5p %d&#123;MM-dd:HH:mm:ss,SSS&#125; %m (%F:%L) \n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"debug"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.apache.ibatis"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"info"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"debug"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1><span id="c3p0-shu-ju-yuan-zai-spring-zhong-de-pei-zhi">c3p0数据源在spring中的配置</span><a href="#c3p0-shu-ju-yuan-zai-spring-zhong-de-pei-zhi" class="header-anchor"></a></h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1><span id="chang-yong-bi-bei-yi-lai">常用必备依赖</span><a href="#chang-yong-bi-bei-yi-lai" class="header-anchor"></a></h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--junit --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- c3p0 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mysql --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.37<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CODING</category>
        <category>零散笔记</category>
      </categories>
      <tags>
        <tag>模版</tag>
      </tags>
  </entry>
  <entry>
    <title>配置主机地址的四种写法</title>
    <url>/2020/03/02/CODING/%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>今天配置了多次ElasticSearch集群环境，反复更改了很多yml配置文件，其中一条“network.host”因为写法混乱而导致一些小问题，所以总结一下ip地址的配置方法，以做巩固</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#di-zhi-de-si-chong-xie-fa-ji-te-dian-qu-bie">地址的四种写法及特点区别</a><ul>
<li><a href="#1-localhost">1、localhost</a></li>
<li><a href="#2-127-0-0-1">2、127.0.0.1</a></li>
<li><a href="#3-0-0-0-0">3、0.0.0.0</a></li>
<li><a href="#4-ip-di-zhi-ben-shen-li-192-168-10-10">4、IP地址本身（例：192.168.10.10）</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h1><span id="di-zhi-de-si-chong-xie-fa-ji-te-dian-qu-bie">地址的四种写法及特点区别</span><a href="#di-zhi-de-si-chong-xie-fa-ji-te-dian-qu-bie" class="header-anchor"></a></h1><h2><span id="1-localhost">1、localhost</span><a href="#1-localhost" class="header-anchor"></a></h2><p>直接配置本地地址，意义上和127.0.0.1相似，只是不需要</p>
<h2><span id="2-127-0-0-1">2、127.0.0.1</span><a href="#2-127-0-0-1" class="header-anchor"></a></h2><h2><span id="3-0-0-0-0">3、0.0.0.0</span><a href="#3-0-0-0-0" class="header-anchor"></a></h2><h2><span id="4-ip-di-zhi-ben-shen-li-192-168-10-10">4、IP地址本身（例：192.168.10.10）</span><a href="#4-ip-di-zhi-ben-shen-li-192-168-10-10" class="header-anchor"></a></h2>]]></content>
      <categories>
        <category>CODING</category>
        <category>零散笔记</category>
      </categories>
      <tags>
        <tag>ip地址写法</tag>
      </tags>
  </entry>
  <entry>
    <title>集合类型汇总</title>
    <url>/2020/06/09/CODING/Java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<blockquote>
<p>集合是Java基础中最为重要的部分之一，因此单独写出一篇文章，将常用的几个集合结合工作实际进行记录。</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#collection">Collection</a></li>
<li><a href="#set">Set</a></li>
<li><a href="#list">List</a><ul>
<li><a href="#arraylist">ArrayList</a></li>
<li><a href="#list-jing-yan-zong-jie">List经验总结：</a><ul>
<li><a href="#bian-li-de-tong-shi-shan-chu-list-zhong-de-yuan-su">遍历的同时删除List中的元素</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#map">Map</a></li>
<li><a href="#map-entry">Map.Entry</a><ul>
<li><a href="#hashmap">HashMap</a></li>
<li><a href="#qi-ta">其他</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="collection">Collection</span><a href="#collection" class="header-anchor"></a></h1><h1><span id="set">Set</span><a href="#set" class="header-anchor"></a></h1><h1><span id="list">List</span><a href="#list" class="header-anchor"></a></h1><h2><span id="arraylist">ArrayList</span><a href="#arraylist" class="header-anchor"></a></h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfmwi2bfzvj30em06l0sy.jpg" alt="ArrayList继承图"></p>
<p>特点：动态、连续、线性的数组。在保持Java数组线性快速查找的基础上，实现了动态扩容的特点，弥补了Java数组“不能动态扩容，创建时就要指定好空间大小”的缺点</p>
<p>解决办法：在使用ArrayList时，如果空间不够，ArrayList会再创建一个更大的数组，现将旧的数组内容复制过去，并且在最后一项添加上新的数据。</p>
<blockquote>
<ol>
<li>AbstractList提供了List接口的默认实现（个别方法为抽象方法）。</li>
<li>List接口定义了列表必须实现的方法。</li>
<li>实现了RandomAccess接口：提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。</li>
<li>实现了Cloneable接口：可以调用Object.clone方法返回该对象的浅拷贝。</li>
<li>实现了 java.io.Serializable 接口：可以启用其序列化功能，能通过序列化去传输。未实现此接口的类将无法使其任何状态序列化或反序列化。序列化接口没有方法或字段，仅用于标识可序列化的语义。</li>
</ol>
</blockquote>
<h2><span id="list-jing-yan-zong-jie">List经验总结：</span><a href="#list-jing-yan-zong-jie" class="header-anchor"></a></h2><h3><span id="bian-li-de-tong-shi-shan-chu-list-zhong-de-yuan-su">遍历的同时删除List中的元素</span><a href="#bian-li-de-tong-shi-shan-chu-list-zhong-de-yuan-su" class="header-anchor"></a></h3><p>当我们想要对某个List进行过滤（一边遍历一边删除不符合条件的数据）时，需要注意一点：不能使用“增强的for循环”搭配List.remove(Object)实现。这样会报出“java.util.ConcurrentModificationException”异常。</p>
<h1><span id="map">Map</span><a href="#map" class="header-anchor"></a></h1><h1><span id="map-entry">Map.Entry</span><a href="#map-entry" class="header-anchor"></a></h1><p>Entry是Map接口的一个内部接口，主要功能是使用迭代器指向Map中的每一个“键值对”</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns the key corresponding to this entry.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the key corresponding to this entry</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalStateException implementations may, but are not</span></span><br><span class="line"><span class="comment">         *         required to, throw this exception if the entry has been</span></span><br><span class="line"><span class="comment">         *         removed from the backing map.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns the value corresponding to this entry.  If the mapping</span></span><br><span class="line"><span class="comment">         * has been removed from the backing map (by the iterator's</span></span><br><span class="line"><span class="comment">         * &lt;tt&gt;remove&lt;/tt&gt; operation), the results of this call are undefined.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the value corresponding to this entry</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalStateException implementations may, but are not</span></span><br><span class="line"><span class="comment">         *         required to, throw this exception if the entry has been</span></span><br><span class="line"><span class="comment">         *         removed from the backing map.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Replaces the value corresponding to this entry with the specified</span></span><br><span class="line"><span class="comment">         * value (optional operation).  (Writes through to the map.)  The</span></span><br><span class="line"><span class="comment">         * behavior of this call is undefined if the mapping has already been</span></span><br><span class="line"><span class="comment">         * removed from the map (by the iterator's &lt;tt&gt;remove&lt;/tt&gt; operation).</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value new value to be stored in this entry</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> old value corresponding to the entry</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> UnsupportedOperationException if the &lt;tt&gt;put&lt;/tt&gt; operation</span></span><br><span class="line"><span class="comment">         *         is not supported by the backing map</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> ClassCastException if the class of the specified value</span></span><br><span class="line"><span class="comment">         *         prevents it from being stored in the backing map</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> NullPointerException if the backing map does not permit</span></span><br><span class="line"><span class="comment">         *         null values, and the specified value is null</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalArgumentException if some property of this value</span></span><br><span class="line"><span class="comment">         *         prevents it from being stored in the backing map</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalStateException implementations may, but are not</span></span><br><span class="line"><span class="comment">         *         required to, throw this exception if the entry has been</span></span><br><span class="line"><span class="comment">         *         removed from the backing map.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">V <span class="title">setValue</span><span class="params">(V value)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Compares the specified object with this entry for equality.</span></span><br><span class="line"><span class="comment">         * Returns &lt;tt&gt;true&lt;/tt&gt; if the given object is also a map entry and</span></span><br><span class="line"><span class="comment">         * the two entries represent the same mapping.  More formally, two</span></span><br><span class="line"><span class="comment">         * entries &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; represent the same mapping</span></span><br><span class="line"><span class="comment">         * if&lt;pre&gt;</span></span><br><span class="line"><span class="comment">         *     (e1.getKey()==null ?</span></span><br><span class="line"><span class="comment">         *      e2.getKey()==null : e1.getKey().equals(e2.getKey()))  &amp;amp;&amp;amp;</span></span><br><span class="line"><span class="comment">         *     (e1.getValue()==null ?</span></span><br><span class="line"><span class="comment">         *      e2.getValue()==null : e1.getValue().equals(e2.getValue()))</span></span><br><span class="line"><span class="comment">         * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">         * This ensures that the &lt;tt&gt;equals&lt;/tt&gt; method works properly across</span></span><br><span class="line"><span class="comment">         * different implementations of the &lt;tt&gt;Map.Entry&lt;/tt&gt; interface.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> o object to be compared for equality with this map entry</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if the specified object is equal to this map</span></span><br><span class="line"><span class="comment">         *         entry</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns the hash code value for this map entry.  The hash code</span></span><br><span class="line"><span class="comment">         * of a map entry &lt;tt&gt;e&lt;/tt&gt; is defined to be: &lt;pre&gt;</span></span><br><span class="line"><span class="comment">         *     (e.getKey()==null   ? 0 : e.getKey().hashCode()) ^</span></span><br><span class="line"><span class="comment">         *     (e.getValue()==null ? 0 : e.getValue().hashCode())</span></span><br><span class="line"><span class="comment">         * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">         * This ensures that &lt;tt&gt;e1.equals(e2)&lt;/tt&gt; implies that</span></span><br><span class="line"><span class="comment">         * &lt;tt&gt;e1.hashCode()==e2.hashCode()&lt;/tt&gt; for any two Entries</span></span><br><span class="line"><span class="comment">         * &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt;, as required by the general</span></span><br><span class="line"><span class="comment">         * contract of &lt;tt&gt;Object.hashCode&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the hash code value for this map entry</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> Object#hashCode()</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> Object#equals(Object)</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> #equals(Object)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns a comparator that compares &#123;<span class="doctag">@link</span> Map.Entry&#125; in natural order on key.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;The returned comparator is serializable and throws &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">         * NullPointerException&#125; when comparing an entry with a null key.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span>  &lt;K&gt; the &#123;<span class="doctag">@link</span> Comparable&#125; type of then map keys</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span>  &lt;V&gt; the type of the map values</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> a comparator that compares &#123;<span class="doctag">@link</span> Map.Entry&#125; in natural order on key.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> Comparable</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;K extends Comparable&lt;? <span class="keyword">super</span> K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByKey() &#123;</span><br><span class="line">            <span class="keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">                (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns a comparator that compares &#123;<span class="doctag">@link</span> Map.Entry&#125; in natural order on value.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;The returned comparator is serializable and throws &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">         * NullPointerException&#125; when comparing an entry with null values.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &lt;K&gt; the type of the map keys</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &lt;V&gt; the &#123;<span class="doctag">@link</span> Comparable&#125; type of the map values</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> a comparator that compares &#123;<span class="doctag">@link</span> Map.Entry&#125; in natural order on value.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> Comparable</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V extends Comparable&lt;? <span class="keyword">super</span> V&gt;&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByValue() &#123;</span><br><span class="line">            <span class="keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">                (c1, c2) -&gt; c1.getValue().compareTo(c2.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns a comparator that compares &#123;<span class="doctag">@link</span> Map.Entry&#125; by key using the given</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Comparator&#125;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;The returned comparator is serializable if the specified comparator</span></span><br><span class="line"><span class="comment">         * is also serializable.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span>  &lt;K&gt; the type of the map keys</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span>  &lt;V&gt; the type of the map values</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span>  cmp the key &#123;<span class="doctag">@link</span> Comparator&#125;</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> a comparator that compares &#123;<span class="doctag">@link</span> Map.Entry&#125; by the key.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? <span class="keyword">super</span> K&gt; cmp) &#123;</span><br><span class="line">            Objects.requireNonNull(cmp);</span><br><span class="line">            <span class="keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">                (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns a comparator that compares &#123;<span class="doctag">@link</span> Map.Entry&#125; by value using the given</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Comparator&#125;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;The returned comparator is serializable if the specified comparator</span></span><br><span class="line"><span class="comment">         * is also serializable.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span>  &lt;K&gt; the type of the map keys</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span>  &lt;V&gt; the type of the map values</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span>  cmp the value &#123;<span class="doctag">@link</span> Comparator&#125;</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> a comparator that compares &#123;<span class="doctag">@link</span> Map.Entry&#125; by the value.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? <span class="keyword">super</span> V&gt; cmp) &#123;</span><br><span class="line">            Objects.requireNonNull(cmp);</span><br><span class="line">            <span class="keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">                (c1, c2) -&gt; cmp.compare(c1.getValue(), c2.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>主要使用方法：Entry接口自带getKey()、getValue()方法，无需再用keySet迭代key值，再从map中取出value了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String &gt; testMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        testMap.put(<span class="string">"name"</span>, <span class="string">"tornado4651"</span>);</span><br><span class="line">        testMap.put(<span class="string">"password"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        testMap.put(<span class="string">"email"</span>, <span class="string">"tornado4651@qq.com"</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = testMap.entrySet();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : entries)&#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(<span class="string">"当前键值对："</span> + key + <span class="string">"-----"</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="hashmap">HashMap</span><a href="#hashmap" class="header-anchor"></a></h2><h2><span id="qi-ta">其他</span><a href="#qi-ta" class="header-anchor"></a></h2><p><a href="https://www.cnblogs.com/java-h/p/10969710.html" target="_blank" rel="noopener">map的遍历操作</a></p>
<p>使maph中存储数据更加灵活的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>移除map中的键值对：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; myMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; iterator= myMap.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">  String key = iterator.next();</span><br><span class="line">  Object value = myMap.get(key);</span><br><span class="line">  <span class="keyword">if</span>(<span class="comment">// 删除的判断操作)&#123;</span></span><br><span class="line">    iterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CODING</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>Set</tag>
        <tag>List</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式————观察者模式</title>
    <url>/2020/03/02/CODING/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>“观察者模式“是指：在多个对象之间定义一种”一对多”的关系，主要作用是，当其中的“一”对象做出改变时，可以立刻通知所有关注该对象（在该模式下称为“主题”）的观察者们做出更新动作。</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#shi-me-shi-guan-cha-zhe-mo-shi">什么是“观察者模式”</a></li>
<li><a href="#zi-ji-bian-xie-shi-xian-dai-ma">自己编写实现代码</a></li>
<li><a href="#shi-yong-java-zi-dai-de-guan-cha-zhe-mo-shi">使用java自带的观察者模式</a><ul>
<li><a href="#shi-yong-ji-shi-xian-fang-fa">使用及实现方法</a></li>
<li><a href="#shi-yong-java-zi-dai-guan-cha-zhe-mo-shi-de-te-dian">使用java自带“观察者模式”的特点</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="shi-me-shi-guan-cha-zhe-mo-shi">什么是“观察者模式”</span><a href="#shi-me-shi-guan-cha-zhe-mo-shi" class="header-anchor"></a></h1><p>“观察者模式“是指：在多个对象之间定义出”一对多”的关系，主要作用是，当其中的“一”对象做出改变时，可以立刻通知所有关注该对象（在该模式下称为“主题”）的观察者们做出更新动作。</p>
<p>举个例子：天气app的订阅关注机制，所有的人都可以关注天气中心，并且天气中心也可以自由的去除或者屏蔽订阅者，每当气温出现变化时，天气中心就会通知所有订阅者更新信息重新现实当前天气状况。</p>
<h1><span id="zi-ji-bian-xie-shi-xian-dai-ma">自己编写实现代码</span><a href="#zi-ji-bian-xie-shi-xian-dai-ma" class="header-anchor"></a></h1><p>首先，写出‘主题‘和’观察者‘接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> HeadFirst.B_Observer_Pattern.Customize.PatternUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        用于注册观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        用于移除取消观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        用于通知所有观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> HeadFirst.B_Observer_Pattern.Customize.PatternUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  	用于在主题通知更新</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后根据这实际情况具体实现以上两个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> HeadFirst.B_Observer_Pattern.Customize.Equipment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> HeadFirst.B_Observer_Pattern.Customize.PatternUtil.Observer;</span><br><span class="line"><span class="keyword">import</span> HeadFirst.B_Observer_Pattern.Customize.PatternUtil.Subject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 天气中心，是一个主题节点，因此实现Subject接口</span></span><br><span class="line"><span class="comment"> * 主要有观察者的注册，移除，通知更新功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//观察者列表，存放所有注册过的观察者</span></span><br><span class="line">    <span class="keyword">private</span> List observerList;</span><br><span class="line">    <span class="comment">//天气数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在每一个新的天气数据创建的构造方法中创建一个观察者列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        observerList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册观察者的具体实现方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observerList.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除指定观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = observerList.indexOf(observer);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            observerList.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据观察者列表，遍历通知每一个观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; observerList.size(); i++) &#123;</span><br><span class="line">            Observer observer = (Observer) observerList.get(i);</span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurement</span><span class="params">(<span class="keyword">float</span> tmperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = tmperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> HeadFirst.B_Observer_Pattern.Customize.Equipment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> HeadFirst.B_Observer_Pattern.Customize.PatternUtil.Observer;</span><br><span class="line"><span class="keyword">import</span> HeadFirst.B_Observer_Pattern.Customize.PatternUtil.Subject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前天气情况展示板，是一个观察者，因此实现Observer接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录观察的主题</span></span><br><span class="line">    <span class="keyword">private</span> Subject weatherDate;</span><br><span class="line">    <span class="comment">//展示板需要显示的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义带餐构造函数确定观察主题，并在观察主题中进行注册</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionDisplay</span><span class="params">(Subject weatherDate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weatherDate = weatherDate;</span><br><span class="line">        weatherDate.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现在观察者的更新具体操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temp;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示数据方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"========================================"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Current conditions: "</span>);</span><br><span class="line">        System.out.println(temperature + <span class="string">"F degrees and "</span> + humidity + <span class="string">"humidity"</span>);</span><br><span class="line">        System.out.println(<span class="string">"========================================"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似“CurrentConditionDisplay”的观察者类还可以创建多个，写法类似，同时对WeatherData主题进行观察。</p>
<p>当观察者和主题类都创建好后，我们就可以具体使用了，这里写一个简单的使用方法，以便理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> HeadFirst.B_Observer_Pattern.Customize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> HeadFirst.B_Observer_Pattern.Customize.Equipment.CurrentConditionDisplay;</span><br><span class="line"><span class="keyword">import</span> HeadFirst.B_Observer_Pattern.Customize.Equipment.WeatherData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 天气数据站，统一管理WeatherData天气数据和各种显示面板</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherStation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 注册组件：天气数据 和 当前状况显示板</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">        CurrentConditionDisplay currentConditionDisplay = <span class="keyword">new</span> CurrentConditionDisplay(weatherData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 模拟天气数据更新，自动通知所有观察者</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        weatherData.setMeasurement(<span class="number">80</span>,<span class="number">65</span>, <span class="number">30.4f</span>);</span><br><span class="line">        weatherData.setMeasurement(<span class="number">60</span>,<span class="number">37</span>, <span class="number">45.4f</span>);</span><br><span class="line">        weatherData.setMeasurement(<span class="number">70</span>,<span class="number">55</span>, <span class="number">56.3f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当不再需要监听后，移除监听者</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        weatherData.removeObserver(currentConditionDisplay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 再次更新天气数据后，由于已经移除了观察者，所以'当前状况显示板'不会有任何反应</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        weatherData.setMeasurement(<span class="number">555</span>,<span class="number">635</span>, <span class="number">33.4f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="shi-yong-java-zi-dai-de-guan-cha-zhe-mo-shi">使用java自带的观察者模式</span><a href="#shi-yong-java-zi-dai-de-guan-cha-zhe-mo-shi" class="header-anchor"></a></h1><h2><span id="shi-yong-ji-shi-xian-fang-fa">使用及实现方法</span><a href="#shi-yong-ji-shi-xian-fang-fa" class="header-anchor"></a></h2><p>java.util包下自带了实现“观察者模式”的接口和类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.Observable;</span><br><span class="line">java.util.Observer;</span><br></pre></td></tr></table></figure>

<p>使用java自带接口和类重写天气数据类、当前情况面板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> HeadFirst.B_Observer_Pattern.JavaUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立基础成员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于继承了Observable类，所以不再需要初始化时，自己创建存储结构来存放观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressusre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressusre;</span><br><span class="line">        <span class="comment">//注：java自带的通知方法要求通知前，需要先标记changed为true</span></span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义所有成员变量的getter方法，方便观察者自己"按需拉取"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> humidity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPressusre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pressure;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> HeadFirst.B_Observer_Pattern.JavaUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过实现jdk自带的Observer接口，作为观察者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    Observable observable;</span><br><span class="line">    <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">float</span> humidity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在创建时便注册观察</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionDisplay</span><span class="params">(Observable observable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observable = observable;</span><br><span class="line">        observable.addObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写通知更新方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> WeatherData)&#123;</span><br><span class="line">            WeatherData weatherData = (WeatherData)o;</span><br><span class="line">            <span class="keyword">this</span>.humidity = weatherData.getHumidity();</span><br><span class="line">            <span class="keyword">this</span>.temperature = weatherData.getTemperature();</span><br><span class="line">            display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========================="</span>);</span><br><span class="line">        System.out.println(<span class="string">"Current Condition: "</span>);</span><br><span class="line">        System.out.println(<span class="string">"temperature:"</span> + temperature + <span class="string">"; humidity:"</span> + humidity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="shi-yong-java-zi-dai-guan-cha-zhe-mo-shi-de-te-dian">使用java自带“观察者模式”的特点</span><a href="#shi-yong-java-zi-dai-guan-cha-zhe-mo-shi-de-te-dian" class="header-anchor"></a></h2><p>java自带的Observer接口和Observerable类相较于自己编写的接口实现，有以下特点：</p>
<ul>
<li><p>Observerable类中提供了丰富且全面的注册，删除，通知方法，相较自己写出的更为安全。</p>
</li>
<li><p>主题的创建通过“继承Observerable”类，并且该类没有实现任何接口，因此这一点违反了“多用组合，少用继承”设计原理。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>CODING</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式概括</title>
    <url>/2020/03/29/CODING/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E6%8B%AC/</url>
    <content><![CDATA[<blockquote>
<p>这篇是关于设计模式的概念性文章，主要记录设计模式的目的原则等</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#she-ji-mo-shi-de-mu-de">设计模式的目的</a></li>
<li><a href="#oo-ji-chu">OO基础</a><ul>
<li><a href="#san-da-ji-ben-te-zheng">三大基本特征</a><ul>
<li><a href="#feng-zhuang">封装</a></li>
<li><a href="#ji-cheng">继承</a></li>
<li><a href="#duo-tai">多态</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ji-ben-yuan-ze">基本原则</a><ul>
<li><a href="#1-dan-yi-zhi-ze-yuan-ze-single-responsibility-principle">1.单一职责原则（single-responsibility principle）</a></li>
<li><a href="#2-jie-kou-ge-chi-yuan-ze-interface-segregation-principle">2.接口隔离原则(Interface-Segregation principle)</a></li>
<li><a href="#3-yi-lai-dao-zhi-yuan-ze-dependency-inversion-principle">3.依赖倒置原则（Dependency-Inversion principle）</a></li>
<li><a href="#4-li-shi-ti-huan-yuan-ze-liskov-substitution-principle">4.里氏替换原则（Liskov-Substitution principle）</a></li>
<li><a href="#5-kai-fang-feng-bi-yuan-ze-open-closed-principle">5.* * 开放封闭原则* *（Open-Closed principle）</a></li>
<li><a href="#6-di-mi-te-fa-ze-demeter-principle">6.迪米特法则（Demeter Principle）</a></li>
<li><a href="#7-he-cheng-fu-yong-yuan-ze-composite-reuse-principle">7.合成复用原则（Composite Reuse Principle）</a></li>
</ul>
</li>
<li><a href="#she-ji-yuan-ze">设计原则</a></li>
<li><a href="#oo-mo-shi">OO模式</a><ul>
<li><a href="#ce-lue-mo-shi-dan-li-mo-shi">策略模式（单例模式）</a></li>
<li><a href="#guan-cha-zhe-mo-shi">观察者模式</a></li>
<li><a href="#zhuang-shi-zhe-mo-shi">装饰者模式</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="she-ji-mo-shi-de-mu-de">设计模式的目的</span><a href="#she-ji-mo-shi-de-mu-de" class="header-anchor"></a></h1><p>软件设计方面：耦合性、内聚性、可维护性、重用性、灵活性</p>
<p>使程序实现“高内聚、低耦合”的特点</p>
<h1><span id="oo-ji-chu">OO基础</span><a href="#oo-ji-chu" class="header-anchor"></a></h1><h2><span id="san-da-ji-ben-te-zheng">三大基本特征</span><a href="#san-da-ji-ben-te-zheng" class="header-anchor"></a></h2><h3><span id="feng-zhuang">封装</span><a href="#feng-zhuang" class="header-anchor"></a></h3><p>封装就是将一部分功能（步骤）打包提取出来，当作一个单独的模块，只对外留出接口的使用方法和说明，并不关注内部的具体实现方法。</p>
<h3><span id="ji-cheng">继承</span><a href="#ji-cheng" class="header-anchor"></a></h3><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<h3><span id="duo-tai">多态</span><a href="#duo-tai" class="header-anchor"></a></h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<p><strong>多态的优点：</strong></p>
<ul>
<li>消除类型之间的耦合关系</li>
<li>可替换性</li>
<li>可扩充性</li>
<li>接口性</li>
<li>灵活性</li>
<li>简化性</li>
</ul>
<p>多态存在的<strong>三个必要条件</strong>：</p>
<ul>
<li>继承</li>
<li>重写（子类继承父类后对父类方法进行重新定义）</li>
<li>父类引用指向子类对象</li>
</ul>
<h1><span id="ji-ben-yuan-ze">基本原则</span><a href="#ji-ben-yuan-ze" class="header-anchor"></a></h1><p>基本原则的出现是各种设计模式的基础，也是“设计模式为什么这样设计”的依据</p>
<h2><span id="1-dan-yi-zhi-ze-yuan-ze-single-responsibility-principle">1.单一职责原则（single-responsibility principle）</span><a href="#1-dan-yi-zhi-ze-yuan-ze-single-responsibility-principle" class="header-anchor"></a></h2><p>对于“类”来说：每一个类负责一项职责（如UserController只负责用户相关的控制内容，不负责订单，内容等），如果内部出现职责1、职责2的划分，那么需要把A类分成A1、A2.</p>
<p>对于“方法”来说：只有在类的方法足够少的情况下，我们才可以在方法级别保持单一原则。</p>
<p><em>对应代码：com.tornado4651.design_pattern.principle.single_responsibility</em></p>
<h2><span id="2-jie-kou-ge-chi-yuan-ze-interface-segregation-principle">2.接口隔离原则(Interface-Segregation principle)</span><a href="#2-jie-kou-ge-chi-yuan-ze-interface-segregation-principle" class="header-anchor"></a></h2><p>一个类所依赖的接口应该做到最小化，不应该依赖太多没用的接口。</p>
<p>如图所示：A类和C类分别通过接口依赖B类、D类（A - B、C - D）,接口中有1、2、3、4、5共五个方法。但是A只需要C的方法1、2、3，B类只需要的D的方法1、4、5。C、D分别多实现了两个方法。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gemijgnfezj30lu0judhk.jpg" alt="截屏2020-05-09 下午9.20.31"></p>
<p>改进方法：将接口拆分为接口1只有方法1、接口2只有方法2，3、接口3只有方法4、5的三个接口，而B类</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gemik2393ej30ui0eu403.jpg" alt="截屏2020-05-09 下午9.21.36"></p>
<p><em>对应代码：com.tornado4651.design_pattern.principle.liskov_substitution</em></p>
<h2><span id="3-yi-lai-dao-zhi-yuan-ze-dependency-inversion-principle">3.依赖倒置原则（Dependency-Inversion principle）</span><a href="#3-yi-lai-dao-zhi-yuan-ze-dependency-inversion-principle" class="header-anchor"></a></h2><ol>
<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li>
<li>抽象不应该依赖细节，细节应该依赖抽象</li>
<li>核心思想是面向接口编程</li>
<li>对于细节的多变性，抽象的东西要稳定的多。以接口为基础搭建的架构比以细节为基础的架构稳定的多。（抽象 –&gt; 接口\实现类；细节 –&gt; 实现类）</li>
<li>接口和抽象类的主要目的是“制定规范”，不涉及任何具体的操作</li>
</ol>
<p><strong>依赖关系传递的三种方式：</strong></p>
<ul>
<li><p>通过接口传递（无需抽象成员变量）</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1： 通过接口传递实现依赖</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span></span>&#123;</span><br><span class="line">	<span class="comment">// 重点：使用抽象接口传入参数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span></span>&#123;</span><br><span class="line"> 		tv.play();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过构造方法传递（需要抽象成员变量）</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式2: 通过构造方法依赖传递</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> ITV tv;</span><br><span class="line">  	<span class="comment">// 重点：实现具体构造方法传入依赖的抽象接口</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">OpenAndClose</span><span class="params">(ITV tv)</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.tv = tv;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.tv.play();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>settter方式传递（需要抽象成员变量）</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式3 , 通过setter方法传递</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重点：具体实现setter方法传入依赖的抽象接口</span></span><br><span class="line">  	<span class="keyword">private</span> ITV tv;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>注意：</strong></p>
<p>  在软件设计的时候，底层模块尽量是抽象的“抽象类或者接口或者二者并存”，这样稳定性更好，切忌一个孤零零类A存在那里</p>
<p>  使用抽象类或者接口进行变量声明，然后指向具体的实例( new XXX() )，这样一来，相当于在变量引用和实际对象之间存在一个缓冲层，利于程序的扩展和优化</p>
<p>  继承时遵循“里氏替换原则”</p>
<p>  <em>对应代码：</em></p>
</li>
</ul>
<h2><span id="4-li-shi-ti-huan-yuan-ze-liskov-substitution-principle">4.里氏替换原则（Liskov-Substitution principle）</span><a href="#4-li-shi-ti-huan-yuan-ze-liskov-substitution-principle" class="header-anchor"></a></h2><p>该原则主要针对面向对象三大基本特性的“继承性”提出，里氏替换原则指出：在继承关系中，子类B尽量不要重写父类A的方法。如果重写的较多，可以将子类B和父类A中共同的方法提出到一个Base类中，二者同时继承Base类，这样一来，将A、B变成统一等级，降低了耦合性。</p>
<p>其他降低耦合性的方法还有：聚合、组合、依赖等。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gemnyuxzb3j30om0d6glz.jpg" alt="截屏2020-05-10 上午12.27.22"></p>
<p><em>对应代码：com.tornado4651.design_pattern.principle.liskov_substitution</em></p>
<h2><span id="5-kai-fang-feng-bi-yuan-ze-open-closed-principle">5.* * 开放封闭原则* *（Open-Closed principle）</span><a href="#5-kai-fang-feng-bi-yuan-ze-open-closed-principle" class="header-anchor"></a></h2><p>开闭原则是所有模式中甚至编程过程中<strong>最基础、最重要</strong>的设计原则！</p>
<p>之前所有原则的制定都是为了实现开闭原则而准备的！</p>
<p>一个软件（类、模块、函数方法功能）应该<strong>对扩展开放、对修改关闭</strong>！</p>
<p>当软件的需求增加或者变化时，应该尽量通过<strong>扩展</strong>来实现变化，而<strong>不是修改</strong>原有代码。</p>
<p>例子：</p>
<p>原本结构：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gemp4w7snij30we09o0tp.jpg" alt="截屏2020-05-10 上午1.05.05"></p>
<p>改进后：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gemp4nelzkj30wq09gdgn.jpg" alt="截屏2020-05-10 上午1.04.51"></p>
<p><em>对应代码：com.tornado4651.design_pattern.principle.open_close</em></p>
<h2><span id="6-di-mi-te-fa-ze-demeter-principle">6.迪米特法则（Demeter Principle）</span><a href="#6-di-mi-te-fa-ze-demeter-principle" class="header-anchor"></a></h2><p>迪米特法则又称“最少知道原则”，指的是一个对象应该保持对其他对象最少的了解。对于被依赖的类，不管多么负责，都应该将逻辑封装在类的内部一个方法，只需要对外提供public方法即可。类与类关系越密切，耦合度越大。</p>
<p>简单理解为：只于直接朋友通信。【每当一个类和另一个类有依赖关系时，二者必定出现耦合性。如A依赖于B。直接朋友是指：B作为<strong>成员变量</strong>、<strong>方法参数</strong>、<strong>方法返回值</strong>出现在A中时】我们应该尽量避免在方法中出现其他类作为局部变量出现的情况（如：B出现在A的Method1方法中）。</p>
<p>改进方法：将局部变量在方法中所做的事情提出到B中一个具体方法实现，在A类中用直接朋友的关系调用B的那个方法即可。</p>
<p><em>实例代码：com.tornado4651.design_pattern.principle.demeter</em></p>
<h2><span id="7-he-cheng-fu-yong-yuan-ze-composite-reuse-principle">7.合成复用原则（Composite Reuse Principle）</span><a href="#7-he-cheng-fu-yong-yuan-ze-composite-reuse-principle" class="header-anchor"></a></h2><p>原则是指：尽量使用合成、聚合、组合的方式，少用继承</p>
<p>举例需求：</p>
<p>A有两个方法：method1、method2，现在B类想要调用A的两个方法，有哪几种办法？</p>
<ol>
<li>让B直接继承A，但是如果二者没有太大的关联性，这样很不好，会大大提高耦合性</li>
<li>合成：将A的对象作为方法参数传给B的某一个方法【b.method(A a)】</li>
<li>聚合：将A的引用作为B的成员变量传入，并设置set方法【b.setA(A a){this.a = a;}】</li>
<li>组合：将A的引用作为B的成员变量传入，但是在B初始化时就创建A的实例化对象【B{A a = new A();} 】</li>
</ol>
<h1><span id="she-ji-yuan-ze">设计原则</span><a href="#she-ji-yuan-ze" class="header-anchor"></a></h1><p>不论使用哪种设计模式，或者如何更改自己的代码，始终需要坚持的一种思想是：</p>
<p><strong>找出程序中会变化的方面，然后将其和固定不变的部分分离出来。而具体的如何实现分离，怎样分离，还有如何将两部分连接起来，尽量保持低耦合。这便是针对不同需求情况下不同的设计模式需要做的。</strong></p>
<ul>
<li><p>封装变化</p>
</li>
<li><p>多用组合，少用继承</p>
</li>
<li><p>针对接口编程，不针对实现编程</p>
</li>
<li><p>对扩展开放，对修改关闭</p>
</li>
<li><p>“组合”和“委托”</p>
</li>
<li><p>“对象组合”可以在“运行时”动态的改变行为？</p>
</li>
<li><p>要依赖抽象，不要依赖具体类</p>
</li>
</ul>
<h1><span id="oo-mo-shi">OO模式</span><a href="#oo-mo-shi" class="header-anchor"></a></h1><h2><span id="ce-lue-mo-shi-dan-li-mo-shi">策略模式（单例模式）</span><a href="#ce-lue-mo-shi-dan-li-mo-shi" class="header-anchor"></a></h2><h2><span id="guan-cha-zhe-mo-shi">观察者模式</span><a href="#guan-cha-zhe-mo-shi" class="header-anchor"></a></h2><h2><span id="zhuang-shi-zhe-mo-shi">装饰者模式</span><a href="#zhuang-shi-zhe-mo-shi" class="header-anchor"></a></h2>]]></content>
      <categories>
        <category>CODING</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的IOC思想与DI</title>
    <url>/2020/01/01/CODING/Java%20Web%E6%A1%86%E6%9E%B6/Spring/Spring%E2%80%94IOC%E6%80%9D%E6%83%B3%20%E5%92%8C%20DI/</url>
    <content><![CDATA[<blockquote>
<p>IOC：控制反转，是Spring框架所特有的一大主要思想，通过Spring的底层控制，可以为我们开发人员进行很大程度的简化java bean的配置，生成对象等操作</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#ioc-yu-di-gai-nian">IOC 与 DI概念</a></li>
<li><a href="#wo-dui-ioc-si-xiang-de-li-jie">我对IOC思想的理解</a></li>
<li><a href="#ju-ti-shi-xian">具体实现</a></li>
<li><a href="#di-ceng-fen-xi">底层分析</a></li>
<li><a href="#zong-jie">总结</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="ioc-yu-di-gai-nian">IOC 与 DI概念</span><a href="#ioc-yu-di-gai-nian" class="header-anchor"></a></h1><h1><span id="wo-dui-ioc-si-xiang-de-li-jie">我对IOC思想的理解</span><a href="#wo-dui-ioc-si-xiang-de-li-jie" class="header-anchor"></a></h1><h1><span id="ju-ti-shi-xian">具体实现</span><a href="#ju-ti-shi-xian" class="header-anchor"></a></h1><h1><span id="di-ceng-fen-xi">底层分析</span><a href="#di-ceng-fen-xi" class="header-anchor"></a></h1><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h1>]]></content>
      <categories>
        <category>CODING</category>
        <category>Java Web框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>IOC</tag>
        <tag>DI</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的AOP事务管理</title>
    <url>/2020/01/01/CODING/Java%20Web%E6%A1%86%E6%9E%B6/Spring/Spring%E7%9A%84AOP%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>这里记录Spring的AOP思想的重要使用方面：声明式事务的实现</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#spring-de-sheng-ming-shi-shi-wu">Spring的声明式事务</a></li>
<li><a href="#ji-yu-zhu-jie-de-sheng-ming-shi-shi-wu">“基于注解”的声明式事务</a></li>
<li><a href="#ji-yu-xml-pei-zhi-wen-jian-de-sheng-ming-shi-shi-wu">“基于xml配置文件”的声明式事务</a><ul>
<li><a href="#ju-ti-shi-li-dai-ma">具体示例代码：</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="spring-de-sheng-ming-shi-shi-wu">Spring的声明式事务</span><a href="#spring-de-sheng-ming-shi-shi-wu" class="header-anchor"></a></h1><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdrz8hz40bj317m0q2qbq.jpg" alt="截屏2020-04-13上午11.25.48"></p>
<p>事务分为：</p>
<p>1）传统的编程式事务。2）声明式事务</p>
<p>而Spring的声明式事务又可以具体分为：</p>
<p>1）基于注解（@Transaction）的事务。2）基于xml配置文件的声明式事务</p>
<p>接下来就详细描述两者的使用方法</p>
<h1><span id="ji-yu-zhu-jie-de-sheng-ming-shi-shi-wu">“基于注解”的声明式事务</span><a href="#ji-yu-zhu-jie-de-sheng-ming-shi-shi-wu" class="header-anchor"></a></h1><p>@Transcation</p>
<h1><span id="ji-yu-xml-pei-zhi-wen-jian-de-sheng-ming-shi-shi-wu">“基于xml配置文件”的声明式事务</span><a href="#ji-yu-xml-pei-zhi-wen-jian-de-sheng-ming-shi-shi-wu" class="header-anchor"></a></h1><p>整体步骤可分为：</p>
<ol>
<li>配置事务管理器</li>
<li>配置AOP</li>
<li>配置事务属性</li>
</ol>
<h2><span id="ju-ti-shi-li-dai-ma">具体示例代码：</span><a href="#ju-ti-shi-li-dai-ma" class="header-anchor"></a></h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd"</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 配置自动扫描的包 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.atguigu.crowd.service"</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 配置事务通知 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置事务属性 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 查询方法：配置只读属性，让数据库知道这是一个查询操作，能够进行一定优化 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"query*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"count*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">&lt;!-- 增删改方法：配置事务的传播行为、回滚异常 --&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">			propagation属性：</span></span><br><span class="line"><span class="comment">				REQUIRED：默认值，表示当前方法必须工作在事务中，如果当前线程上没有已经开启的事务，则自己开新事务。如果已经有了，那么就使用这个已有的事务。</span></span><br><span class="line"><span class="comment">					顾虑：用别人的事务有可能“被”回滚。</span></span><br><span class="line"><span class="comment">				REQUIRES_NEW：建议使用的值，表示不管当前线程上有没有事务，都要自己开事务，在自己的事务中运行。</span></span><br><span class="line"><span class="comment">					好处：不会受到其他事务回滚的影响。</span></span><br><span class="line"><span class="comment">		 --&gt;</span></span><br><span class="line">		 <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">			rollback-for属性：配置事务方法针对什么样的异常回滚</span></span><br><span class="line"><span class="comment">				默认：运行时异常回滚</span></span><br><span class="line"><span class="comment">				建议：编译时异常和运行时异常都回滚</span></span><br><span class="line"><span class="comment">		 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"save*"</span>   <span class="attr">propagation</span>=<span class="string">"REQUIRES_NEW"</span> <span class="attr">rollback-for</span>=<span class="string">"java.lang.Exception"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"uodate*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRES_NEW"</span> <span class="attr">rollback-for</span>=<span class="string">"java.lang.Exception"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"remove*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRES_NEW"</span> <span class="attr">rollback-for</span>=<span class="string">"java.lang.Exception"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"batch*"</span>  <span class="attr">propagation</span>=<span class="string">"REQUIRES_NEW"</span> <span class="attr">rollback-for</span>=<span class="string">"java.lang.Exception"</span>/&gt;</span> </span><br><span class="line">		<span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 配置事务切面 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"txPointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* *..*Service.*(..))"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 将切入点表达式 和 事务通知关联起来 --&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txPointcut"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdu71in3m5j30v40bltf9.jpg" alt="image-20200415092729589"></p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>Java Web框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>声明式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM整合</title>
    <url>/2020/01/01/CODING/Java%20Web%E6%A1%86%E6%9E%B6/Spring%20MVC/SSM%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<blockquote>
<p>这篇文章关于我对Sping + Spring + MyBatis框架整合的简单概括的理解，以及一些简单入门的具体配置方法</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#ssm-kuang-jia-gai-shu">SSM框架概述</a></li>
<li><a href="#ju-ti-pei-zhi">具体配置</a><ul>
<li><a href="#springmvc-bu-fen">SpringMVC部分</a></li>
<li><a href="#spring-bu-fen">Spring部分</a></li>
<li><a href="#mybatis-bu-fen">MyBatis部分</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="ssm-kuang-jia-gai-shu">SSM框架概述</span><a href="#ssm-kuang-jia-gai-shu" class="header-anchor"></a></h1><p>这是概述</p>
<h1><span id="ju-ti-pei-zhi">具体配置</span><a href="#ju-ti-pei-zhi" class="header-anchor"></a></h1><h2><span id="springmvc-bu-fen">SpringMVC部分</span><a href="#springmvc-bu-fen" class="header-anchor"></a></h2><h2><span id="spring-bu-fen">Spring部分</span><a href="#spring-bu-fen" class="header-anchor"></a></h2><h2><span id="mybatis-bu-fen">MyBatis部分</span><a href="#mybatis-bu-fen" class="header-anchor"></a></h2>]]></content>
      <categories>
        <category>CODING</category>
        <category>Java Web框架</category>
        <category>Spring MVC</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的整体认识</title>
    <url>/2020/01/01/CODING/Java%20Web%E6%A1%86%E6%9E%B6/Spring/%E5%AF%B9Spring%E7%9A%84%E6%95%B4%E4%BD%93%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>这是一篇关于我对Spring框架的理解总结的文章</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#wo-li-jie-de-spring-kuang-jia">我理解的Spring框架</a></li>
<li><a href="#spring-de-ju-ti-shi-xian">Spring的具体实现：</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="wo-li-jie-de-spring-kuang-jia">我理解的Spring框架</span><a href="#wo-li-jie-de-spring-kuang-jia" class="header-anchor"></a></h1><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbxzy7odsoj30iw0bcjuf.jpg" alt="Spring框架"></p>
<p>Spring框架给我一种对java应用的各方面功能的高度概括提炼，将各种复杂配置封装成框架底层，并添加进一些特殊管理方式和新思想，使得使用更加简便。</p>
<p>但是凡事具有两面性，框架的继承度越高，虽然使得入门简便了，但是灵活性大大降低，虽然各类功能的开发在一定程度上缓解了很大一部分的开发灵活性，但仍然需要有时修改底层源代码对Spring框架作出最适合自己的改变。</p>
<h1><span id="spring-de-ju-ti-shi-xian">Spring的具体实现：</span><a href="#spring-de-ju-ti-shi-xian" class="header-anchor"></a></h1><p>若抛开上图的WEB组件不谈，那么可以将Spring框架直接嵌套在Java Project上使用，无需创建JavaEE Project</p>
<p>具体实现方法，在Java项目中导入Spring-beans.jar; Spring-context.jar; Spring-core.jar; spring-expression.jar四个基础包即可简单使用依赖注入功能</p>
<p><strong>Spring知识点概括：</strong></p>
<p><strong>Ioc控制反转思想：</strong></p>
<p><strong>DI依赖注入具体实现：</strong></p>
<p><strong>基于XML配置：</strong></p>
<p><strong>基于注释配置：</strong></p>
<p><strong>实践：c3p0连接池和jdbc的使用对比</strong></p>
<p><strong>AOP切面：</strong></p>
<p><strong>实际例子中的需求描述：</strong></p>
<p><strong>动态代理：</strong></p>
<p><strong>AOP思想：</strong></p>
<p><strong>AOP术语：</strong></p>
<p><strong>AspectJ：</strong></p>
<p><strong>通知类型：</strong></p>
<p> <strong>基于注释的配置：</strong></p>
<p><strong>基于XML的配置：</strong></p>
<p><strong>Spring的事务管理：</strong></p>
<p><strong>JdbcTemplate：</strong></p>
<p>xml中必要的配置：</p>
<p>JdbcTemplate的增删改查：</p>
<p><strong>NamedPararmeterJdbcTemplate:</strong></p>
<p>xml中必要的配置</p>
<p>具名的增删改查：</p>
<p><strong>Spring事务管理：</strong></p>
<p>与Jdbc的事务管理对比</p>
<p>使用Spring的DataSourceTransactionManager事务管理器</p>
<p><strong>Spring中事务的传播行为、隔离级别、回滚设置、超时、只读 等属性设置</strong></p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>Java Web框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的AOP思想</title>
    <url>/2020/01/01/CODING/Java%20Web%E6%A1%86%E6%9E%B6/Spring/Spring%E2%80%94AOP%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<blockquote>
<p>AOP：切面思想，作为动态代理的升级版，提升了很多情况下的开发效能，这篇文章就会从入门概念，具体配置等，使读者对Spring的AOP切面思想有了具体的理解。</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#gai-shu">概述</a><ul>
<li><a href="#ju-ti-ying-yong-ju-li-ji-suan-qi-lei-de-gong-neng-shi-xian">具体应用举例：计算器类的功能实现</a></li>
</ul>
</li>
<li><a href="#gai-nian">概念：</a></li>
<li><a href="#ju-ti-shi-xian"><strong>具体实现：</strong></a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="gai-shu">概述</span><a href="#gai-shu" class="header-anchor"></a></h1><h2><span id="ju-ti-ying-yong-ju-li-ji-suan-qi-lei-de-gong-neng-shi-xian">具体应用举例：计算器类的功能实现</span><a href="#ju-ti-ying-yong-ju-li-ji-suan-qi-lei-de-gong-neng-shi-xian" class="header-anchor"></a></h2><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbxzygask6j30lq0cegr7.jpg" alt="AOP"></p>
<h1><span id="gai-nian">概念：</span><a href="#gai-nian" class="header-anchor"></a></h1><p><strong>AOP术语</strong></p>
<p><strong>1 横切关注点</strong></p>
<p>从每个方法中抽取出来的同一类非核心业务。如日志和验证参数</p>
<p><strong>2 切面(Aspect)</strong></p>
<p>由关注点所组成的大类，可以有多个切面将自己的关注点切入到目标类上</p>
<p><strong>3 通知(Advice)</strong></p>
<p>每个切面中具体的功能，与关注点类似，可以理解为“关注点在切面中的具体实现就叫通知”，通知相比关注点可以细分。如日志在切面中分成：前置日志，后置日志，报错日志等。。。</p>
<p><strong>4 目标(Target)</strong></p>
<p>也就是目标类，切面中的通知要通知的类</p>
<p><strong>5 代理(Proxy)</strong></p>
<p>向目标对象应用通知之后创建的代理对象</p>
<p><strong>6 连接点(Joinpoint)</strong></p>
<p>横切关注点在程序代码中的具体体现，对应程序执行的某个特定位置。例如：类某个方法调用前、调用后、方法捕获到异常后等。</p>
<p><strong>7 切入点(pointcut)</strong></p>
<p>定位连接点的方式。每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物。如果把连接点看作数据库中的记录，那么切入点就是查询条件——AOP可以通过切入点定位到特定的连接点。切点通过org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。</p>
<p><strong>4.2.8 图解</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gby00xs8uuj30jy0bq777.jpg" alt="image"></p>
<h1><span id="ju-ti-shi-xian"><strong>具体实现：</strong></span><a href="#ju-ti-shi-xian" class="header-anchor"></a></h1><p><strong>Spring自带有AOP框架，但是AspectJ框架更合适，并且Spring支持AspectJ框架，所以大多数情况使用AspectJ框架</strong></p>
<p><strong>在Spring框架的基础上，导入Spring-aop的jar包和</strong></p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>Java Web框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC中的“拦截器”</title>
    <url>/2020/01/01/CODING/Java%20Web%E6%A1%86%E6%9E%B6/Spring%20MVC/SpringMVC%E2%80%94%E2%80%94%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<p>[toc]</p>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#lan-jie-qi-yu-guo-lu-qi-de-bu-tong">拦截器 与过滤器的不同：</a></li>
<li><a href="#zai-springmvc-zhong-de-zi-ding-yi-lan-jie-qi-shi-xian-fang-shi">在SpringMVC中的自定义拦截器实现方式</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<h1><span id="lan-jie-qi-yu-guo-lu-qi-de-bu-tong">拦截器 与过滤器的不同：</span><a href="#lan-jie-qi-yu-guo-lu-qi-de-bu-tong" class="header-anchor"></a></h1><p>1、过滤器在DispatcherServlet之前执行，进行访问资源的过滤，如session验证用户是否登陆等功能</p>
<p>2、拦截器在DispatcherServlet之后执行</p>
<h1><span id="zai-springmvc-zhong-de-zi-ding-yi-lan-jie-qi-shi-xian-fang-shi">在SpringMVC中的自定义拦截器实现方式</span><a href="#zai-springmvc-zhong-de-zi-ding-yi-lan-jie-qi-shi-xian-fang-shi" class="header-anchor"></a></h1><p>实现HandlerInterceptor接口或者可以继承HandlerInterceptorAdaptor适配器。以上两者的<strong>区别</strong>：实现接口时必须冲重写preHandle、postHandle、afterCompletion这三个方法；而如果只想使用其中一个方法，只需要继承HandlerInterceptorAdaptor这个适配器类即可！</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>Java Web框架</category>
        <category>Spring MVC</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC中数据的传递和视图解析</title>
    <url>/2020/01/01/CODING/Java%20Web%E6%A1%86%E6%9E%B6/Spring%20MVC/SpringMVC%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>SpringMVC学习之使用SprigMVC解决web环境下数据接收的问题</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#yi-mo-xing-shu-chu-shu-ju">一、模型输出数据</a></li>
<li><a href="#er-shi-tu-yu-shi-tu-jie-xi">二、视图 与 视图解析</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="yi-mo-xing-shu-chu-shu-ju">一、模型输出数据</span><a href="#yi-mo-xing-shu-chu-shu-ju" class="header-anchor"></a></h1><p>org.springframework.web.servlet.ModelAndView</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"testModelAndView"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">testModelAndView</span><span class="params">(ModelAndView modelAndView)</span> </span>&#123;</span><br><span class="line">		modelAndView.addObject(<span class="string">"ModelAndViewMsg"</span>, <span class="string">"You got a String type Object from ModelAndView!"</span>);</span><br><span class="line">		modelAndView.setViewName(<span class="string">"success"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> modelAndView;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>org.springframework.ui.Model</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"testModel"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">testModel</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">		model.addAttribute(<span class="string">"ModelMsg"</span>, <span class="string">"You got a String type Object from model"</span>);</span><br><span class="line">    </span><br><span class="line">		<span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>java.util.Map&lt;K, V&gt;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"testMap"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">testMap</span><span class="params">(Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">		map.put(<span class="string">"MapMsg"</span>, <span class="string">"You got a String type Object from map"</span>);</span><br><span class="line">    </span><br><span class="line">		<span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h1><span id="er-shi-tu-yu-shi-tu-jie-xi">二、视图 与 视图解析</span><a href="#er-shi-tu-yu-shi-tu-jie-xi" class="header-anchor"></a></h1><p>控制器返回的ModelAndView的对象后，都会又视图解析器ViewResolver处理成视图，最终进行页面的跳  转</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>Java Web框架</category>
        <category>Spring MVC</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>初识SpringMVC</title>
    <url>/2020/01/01/CODING/Java%20Web%E6%A1%86%E6%9E%B6/Spring%20MVC/%E5%88%9D%E8%AF%86SpringMVC/</url>
    <content><![CDATA[<blockquote>
<p>关键词：SpringMVC框架在web应用中的引入；前段控制器；处理器；处理器映射器；处理器适配器；试图解析器</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#yi-springmvc-kuang-jia-de-shi-xian">一、SpringMVC框架的实现</a></li>
<li><a href="#er-springmvc-de-qing-qiu-xiang-ying-liu-cheng-ru-xia">二、SpringMVC的请求相应流程如下：</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h2><span id="yi-springmvc-kuang-jia-de-shi-xian">一、SpringMVC框架的实现</span><a href="#yi-springmvc-kuang-jia-de-shi-xian" class="header-anchor"></a></h2><p>Java Web项目统一由classpath下的web.xml管理，而MVC中的C即指代servlet或filter之一的“前段控制器”，只有这一部分的引入才决定了整个项目的框架是什么。</p>
<p>而在SpringMVC框架中，最主要的就是org.springframework.web.servlet.DispatcherServlet的实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/springMvc-config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="er-springmvc-de-qing-qiu-xiang-ying-liu-cheng-ru-xia">二、SpringMVC的请求相应流程如下：</span><a href="#er-springmvc-de-qing-qiu-xiang-ying-liu-cheng-ru-xia" class="header-anchor"></a></h2><ol>
<li>用户向浏览器发送请求，请求被Spring的“前端控制器DispatcherServlet”截获</li>
<li>将URL请求转换为URI，调用“处理器映射器HandlerMapping”，获得Controller配置的相关对象。</li>
<li>“前端控制器DispatcherServlet”根据获得的Handler，选择合适的“处理器适配器HandlerAdapter”，其代码结构清晰，便于维护，可复用性高。适配器调用具体的Handller进行对请求的实际处理。</li>
<li>定义Contoller类，其中包含具体的业务实现方法。Cotroller的实现可以通过注释方法：@Controller+@RequestMapping实现；也可以使用继承方法：implements Contoller+@Override public ModelAndView handleRequest()实现。当使用前者注释方法时，不需要在xml配置文件中特定声名bean了，直接自动扫描即可。【注：这一步中根据相关配置，Spring将帮你做一些额外配置：消息转换；数据转换；数据格式化；数据验证，具体含义及实现方法另寻详解】</li>
<li>Handler(即Controller类的具体方法)执行完毕后，向DispathcherServlet返回一个ModelAndView对象，其中包含有视图名(和模型)</li>
<li>“前端控制器DipatcherServlet”根据返回的ModelAndView对象，选择一个合适的“试图解析器ViewResolver”。</li>
<li>“试图解析器ViewResolver”对ModelAndView进行解析渲染</li>
<li>最终将渲染好的结果视图返回给用户</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaxai0mrrlj31ae0u0qgz.jpg" alt="SpringMVC相应流程图"></p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbykyher0zj30t60m6wi5.jpg" alt="image-20200216215030102"></p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>Java Web框架</category>
        <category>Spring MVC</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>web中的路径以及目录结构</title>
    <url>/2020/01/01/CODING/Java%20Web%E6%A1%86%E6%9E%B6/Web%E5%9F%BA%E7%A1%80/web%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BB%A5%E5%8F%8A%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<blockquote>
<p>这篇文章中主要记录了Java web中的各种有关目录目录结构的问题</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#ge-lei-web-xiang-mu-gai-gua-ji-shuo-ming">各类web项目概括 及 说明</a><ul>
<li><a href="#tomcat-fu-wu-qi-mu-lu-jie-gou">Tomcat服务器目录结构</a></li>
<li><a href="#tomcat-fu-wu-qi-shang-de-xiang-mu-mu-lu">Tomcat服务器上的项目目录</a></li>
</ul>
</li>
<li><a href="#wen-ti-dian-ji-lu">问题点记录</a><ul>
<li><a href="#classpath-he-classpath-de-qu-bie">classpath 和 classpath* 的区别</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="ge-lei-web-xiang-mu-gai-gua-ji-shuo-ming">各类web项目概括 及 说明</span><a href="#ge-lei-web-xiang-mu-gai-gua-ji-shuo-ming" class="header-anchor"></a></h1><p>从最基本的目录结构开始介绍：根据实际发布一款web软件的实际流程需求，由浅入深，逐一介绍各种需要了解的。</p>
<h2><span id="tomcat-fu-wu-qi-mu-lu-jie-gou">Tomcat服务器目录结构</span><a href="#tomcat-fu-wu-qi-mu-lu-jie-gou" class="header-anchor"></a></h2><h2><span id="tomcat-fu-wu-qi-shang-de-xiang-mu-mu-lu">Tomcat服务器上的项目目录</span><a href="#tomcat-fu-wu-qi-shang-de-xiang-mu-mu-lu" class="header-anchor"></a></h2><p>在WEB-INF目录的classes及lib子目录下，都可以存放Java类文件。在运行时，Servlet容器的类加载器先加载classes目录下的类，再加载lib目录下的JAR文件（Java类库的打包文件）中的类，jar包是许多class文件的集合。因此，如果两个目录下存在同名的类，classes目录下的类具有优先权。</p>
<h1><span id="wen-ti-dian-ji-lu">问题点记录</span><a href="#wen-ti-dian-ji-lu" class="header-anchor"></a></h1><h2><span id="classpath-he-classpath-de-qu-bie">classpath 和 classpath* 的区别</span><a href="#classpath-he-classpath-de-qu-bie" class="header-anchor"></a></h2><p>classpath:    只访问<strong>{项目名}/WEB-INF/classes/</strong>路径下的文件。</p>
<p>classpath<em>：相较classpath，在*</em>{项目名}/WEB-INF/classes/xxx.jar**中的所包含的文件也能找到</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>Java Web框架</category>
        <category>Web基础</category>
      </categories>
  </entry>
  <entry>
    <title>jQuery 和 Ajax 知识点记录</title>
    <url>/2020/03/13/CODING/Java%20Web%E6%A1%86%E6%9E%B6/Web%E5%9F%BA%E7%A1%80/jQuery%E5%92%8CAjax%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>简单记录JavaWeb基础的一些知识点，以便查看</p>
</blockquote>
<!--toc-->

<a id="more"></a>

<p>[toc]</p>
<h1><span id="axaj-ji-ben-diao-yong">Axaj基本调用</span><a href="#axaj-ji-ben-diao-yong" class="header-anchor"></a></h1><p>使用javascript发起ajax的步骤：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、我们首先要创建XMLHttpRequest </span></span><br><span class="line"><span class="keyword">var</span> ajaxRequest = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 				2、调用open方法设置请求参数,其中参数要传入：</span></span><br><span class="line">ajaxRequest.open(<span class="string">"GET"</span>, <span class="string">"http://localhost:8080/Json_Ajax/ajaxServlet"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 				3、调用send方法发送请求</span></span><br><span class="line">ajaxRequest.send();</span><br><span class="line"><span class="comment">// 				4、onreadystatechange是ajax对象中自带的一个返回准备函数，每当readyState的状态改变时，就会执行该函数，</span></span><br><span class="line"><span class="comment">//					readyState是状态码：0：请求未初始化。4：请求已完成，且相应已就绪</span></span><br><span class="line">ajaxRequest.onreadystatechange =<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(ajaxRequest.status==<span class="number">200</span> &amp;&amp; ajaxRequest.readyState==<span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.parse(ajaxRequest.responseText)</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"div01"</span>).innerHTML = <span class="string">"username:"</span>+jsonObj.username + <span class="string">"; age: "</span>+jsonObj.age;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CODING</category>
        <category>Java Web框架</category>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记</title>
    <url>/2020/06/01/CODING/Java%20Web%E6%A1%86%E6%9E%B6/Web%E5%9F%BA%E7%A1%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>重头学习基础知识，三个月拿下，查漏补缺，注重基础</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#forward-zhuan-fa-he-redire-chong-ding-xiang">forward（转发）和redire（重定向）</a></li>
<li><a href="#you-guan-servletcontext-zhong-de-get-fang-fa">有关ServletContext中的get方法</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="forward-zhuan-fa-he-redire-chong-ding-xiang">forward（转发）和redire（重定向）</span><a href="#forward-zhuan-fa-he-redire-chong-ding-xiang" class="header-anchor"></a></h1><p>1.从地址栏显示来说 </p>
<ul>
<li>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.</li>
<li>redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</li>
</ul>
<p>2.从数据共享来说 </p>
<ul>
<li>forward:转发页面和转发到的页面可以共享request里面的数据.</li>
<li>redirect:不能共享数据.</li>
</ul>
<p>3.从运用地方来说 </p>
<ul>
<li><p>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.</p>
</li>
<li><p>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.</p>
</li>
</ul>
<p>4.从效率来说 </p>
<ul>
<li>forward:高.</li>
<li>redirect:低.</li>
</ul>
<h1><span id="you-guan-servletcontext-zhong-de-get-fang-fa">有关ServletContext中的get方法</span><a href="#you-guan-servletcontext-zhong-de-get-fang-fa" class="header-anchor"></a></h1><p><strong>getParameter()</strong>是获取POST/GET传递的参数值；</p>
<p><strong>getInitParameter()</strong>获取Tomcat的server.xml中设置Context的初始化参数</p>
<p><strong>getAttribute()</strong>是获取对象容器中的数据值；</p>
<p><strong>getRequestDispatcher()</strong>是请求转发。</p>
<blockquote>
<p>注：</p>
<p>初始化参数（Parameter）是配置信息</p>
<p>属性（Attribute）是保存在上下文中的键值对。</p>
</blockquote>
]]></content>
      <categories>
        <category>CODING</category>
        <category>Java Web框架</category>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title>三、ES的查询大总结</title>
    <url>/2020/06/01/CODING/%E6%95%B0%E6%8D%AE%E5%BA%93/ElasticSearch/%E4%B8%89%E3%80%81ES%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>查询功能是在实际工作中经常用到的一项重要功能，因此特意单独列出一篇文章记录</p>
</blockquote>
<div class="toc">

<!-- toc -->



<!-- tocstop -->

</div>

<a id="more"></a>

<p>DSL</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>数据库</category>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ES踩坑记录</title>
    <url>/2020/06/01/CODING/%E6%95%B0%E6%8D%AE%E5%BA%93/ElasticSearch/ES%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#fen-ci-he-bu-fen-ci">分词 和 不分词</a></li>
<li><a href="#fan-wei-cha-xun">范围查询</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h1><span id="fen-ci-he-bu-fen-ci">分词 和 不分词</span><a href="#fen-ci-he-bu-fen-ci" class="header-anchor"></a></h1><p>在实际生产中，分词搜索有些时候会查询出很多不必要的信息，因此需要在配置文档mapping，和查询时对分词进行限制。</p>
<p><strong>分词查询</strong>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /test/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">      <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"reportorname"</span>: <span class="string">"tornado4651"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不分词查询：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /test/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">      <span class="attr">"wildcard"</span>: &#123;</span><br><span class="line">          <span class="attr">"username.keyword"</span>: <span class="string">"tornado4651"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 可以借助通配符搜索</span><br><span class="line">GET /test/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">      <span class="attr">"wildcard"</span>: &#123;</span><br><span class="line">          <span class="attr">"username.keyword"</span>: <span class="string">"tornado*"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="fan-wei-cha-xun">范围查询</span><a href="#fan-wei-cha-xun" class="header-anchor"></a></h1><p> <a href="https://www.cnblogs.com/shoufeng/p/11266136.html" target="_blank" rel="noopener">Elasticsearch中如何进行日期(数值)范围查询</a></p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>数据库</category>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis总结</title>
    <url>/2020/02/13/CODING/%E6%95%B0%E6%8D%AE%E5%BA%93/MyBatis/MyBatis%E6%80%BB%E7%BB%93%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>自己总结一些关于MyBatis的设计思路，使用技巧等</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#mybatis-de-gong-zuo-liu-cheng">MyBatis的工作流程</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="mybatis-de-gong-zuo-liu-cheng">MyBatis的工作流程</span><a href="#mybatis-de-gong-zuo-liu-cheng" class="header-anchor"></a></h1><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdpxf5oqy3j311c0q212p.jpg" alt="截屏2020-04-11下午4.48.53"></p>
<p>描述：</p>
<p>操作流程：</p>
<ol>
<li><p>准备jdbc.properties</p>
</li>
<li><p>创建Spring配置文件——专门配置Spring和MyBatis整合</p>
</li>
<li><p>在Spring配置文件中加载jdbc.properties属性文件</p>
</li>
</ol>
<p>3.1. 测试数据库连接</p>
<ol start="4">
<li><p>配置sqlSessionFactoryBean：配置数据源、指定mapper.xml配置文件的位置、指定MyBatis全局配置文件的位置（可选）</p>
</li>
<li><p>配置MapperScannerConfiguer</p>
</li>
<li><p>测试xxxmapper接口是否可以操作数据库</p>
</li>
</ol>
]]></content>
      <categories>
        <category>CODING</category>
        <category>数据库</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase进阶——使用</title>
    <url>/2020/06/09/CODING/%E6%95%B0%E6%8D%AE%E5%BA%93/HBase/HBase%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->



<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>数据库</category>
        <category>HBase</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase基础——概念、安装、逻辑</title>
    <url>/2020/06/02/CODING/%E6%95%B0%E6%8D%AE%E5%BA%93/HBase/Hbase%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>HBase上手第一天记录</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#shi-me-shi-hbase">什么是HBase</a></li>
<li><a href="#hbase-ji-ben-luo-ji-jie-gou">Hbase基本逻辑结构</a></li>
<li><a href="#hbase-ming-ling-xing-cao-zuo">Hbase命令行操作</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[TOC]</p>
<h1><span id="shi-me-shi-hbase">什么是HBase</span><a href="#shi-me-shi-hbase" class="header-anchor"></a></h1><h1><span id="hbase-ji-ben-luo-ji-jie-gou">Hbase基本逻辑结构</span><a href="#hbase-ji-ben-luo-ji-jie-gou" class="header-anchor"></a></h1><h1><span id="hbase-ming-ling-xing-cao-zuo">Hbase命令行操作</span><a href="#hbase-ming-ling-xing-cao-zuo" class="header-anchor"></a></h1><p>进入命令行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在hbase安装目录下执行</span><br><span class="line"><span class="meta">#</span><span class="bash">hbase shell</span></span><br></pre></td></tr></table></figure>

<p>进入命令行后对表的操作：</p>
<p>实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">显示 hbase 中的表</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> list</span></span><br><span class="line"></span><br><span class="line">创建表，并指定结构(列族)和版本</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> create <span class="string">'user_info'</span>,&#123;NAME=&gt;<span class="string">'base_info'</span>,VERSIONS=&gt;3 &#125;,&#123;NAME=&gt;<span class="string">'extra_info'</span>,VERSIONS=&gt;1 &#125; </span></span><br><span class="line">具体列族下的“列名“和”row key“，在插入数据时中指定。</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> put <span class="string">'user_info'</span>, <span class="string">'user0000'</span>, <span class="string">'base_info:name'</span>, <span class="string">'luoyufeng'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> put <span class="string">'user_info'</span>, <span class="string">'user0000'</span>, <span class="string">'base_info:age'</span>, <span class="string">'18'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> put <span class="string">'user_info'</span>, <span class="string">'user0000'</span>, <span class="string">'base_info:gender'</span>, <span class="string">'female'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> put <span class="string">'user_info'</span>, <span class="string">'user0000'</span>, <span class="string">'extra_info:size'</span>, <span class="string">'34'</span></span></span><br><span class="line">根据“row key”查询</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get <span class="string">'user_info'</span>, <span class="string">'user0000'</span></span></span><br><span class="line"></span><br><span class="line">create 'user_info',&#123;NAME=&gt;'base_info' &#125;,&#123;NAME=&gt;'extra_info'&#125; </span><br><span class="line">put 'user_info', 'user0001', 'base_info:name', 'zhangsan1'</span><br><span class="line">put 'user_info', 'zhangsan_20150701_0001', 'base_info:name', 'zhangsan1'</span><br><span class="line">put 'user_info', 'zhangsan_20150701_0002', 'base_info:name', 'zhangsan2'</span><br><span class="line">put 'user_info', 'zhangsan_20150701_0003', 'base_info:name', 'zhangsan3'</span><br><span class="line">put 'user_info', 'zhangsan_20150701_0004', 'base_info:name', 'zhangsan4'</span><br><span class="line">put 'user_info', 'zhangsan_20150701_0005', 'base_info:name', 'zhangsan5'</span><br><span class="line">put 'user_info', 'zhangsan_20150701_0006', 'base_info:name', 'zhangsan6'</span><br><span class="line">put 'user_info', 'zhangsan_20150701_0007', 'base_info:name', 'zhangsan7'</span><br><span class="line">put 'user_info', 'zhangsan_20150701_0008', 'base_info:name', 'zhangsan8'</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CODING</category>
        <category>数据库</category>
        <category>HBase</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>初识MyBatis</title>
    <url>/2020/01/01/CODING/%E6%95%B0%E6%8D%AE%E5%BA%93/MyBatis/%E5%88%9D%E5%A7%8BMyBatis/</url>
    <content><![CDATA[<blockquote>
<p>对MyBatis的基础概括及简单用法</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#mybatis-zong-gai">MyBatis总概</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="mybatis-zong-gai">MyBatis总概</span><a href="#mybatis-zong-gai" class="header-anchor"></a></h1><p>maven配置mybatis：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>MyBatis的核心应用</p>
<p>MyBatis四大组件</p>
<p>MyBatis的插件机制</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>数据库</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>初识MyBatisPlus</title>
    <url>/2020/03/03/CODING/%E6%95%B0%E6%8D%AE%E5%BA%93/MyBatis/%E5%88%9D%E8%AF%86MyBatisPlus/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#yu-mybatis-de-bi-jiao">与Mybatis的比较：</a></li>
<li><a href="#mp-de-hello-world-shi-yong">mp的hello world使用</a></li>
<li><a href="#mybatisplus-zhong-de-ji-ben-crud-fang-fa-shi-yong">MyBatisPlus中的基本CRUD方法使用</a></li>
<li><a href="#tiao-jian-gou-zao-qi">条件构造器</a></li>
<li><a href="#dai-ma-sheng-cheng-gong-neng">代码生成功能</a></li>
<li><a href="#quan-ju-cao-zuo">全局操作</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="yu-mybatis-de-bi-jiao">与Mybatis的比较：</span><a href="#yu-mybatis-de-bi-jiao" class="header-anchor"></a></h1><p>MyBatis：</p>
<ul>
<li>需要与Spring的连接包</li>
</ul>
<p>MyBatis：</p>
<ul>
<li>不需要MyBatis</li>
</ul>
<h1><span id="mp-de-hello-world-shi-yong">mp的hello world使用</span><a href="#mp-de-hello-world-shi-yong" class="header-anchor"></a></h1><p>maven依赖：直接引入mybatis-plus即可，不需要mybatis和mybatis-spring的依赖，mp会统统自动配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mp 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用Spring对mp的配置：（applicationContext.xml中）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1:数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2: MyBatisPlus配置：MyBatisSqlSessionFactoryBean,只需要更换类名即可，其他与MyBatis的相同，不用更改  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactoryBean"</span> <span class="attr">class</span>=<span class="string">"com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- MP配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 别名处理 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"com.tornado4651.mp"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--加入MyBatisPlus的全局配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"globalConfig"</span> <span class="attr">ref</span>=<span class="string">"globalConfiguration"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3:配置MybatisPlus的全局配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"globalConfiguration"</span> <span class="attr">class</span>=<span class="string">"com.baomidou.mybatisplus.entity.GlobalConfiguration"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 主键自增 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idType"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 表名前缀转换 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tablePrefix"</span> <span class="attr">value</span>=<span class="string">"tbl_"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 4:配置 mybatis 扫描 mapper 接口的路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.tornado4651.mp.mapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的配置完成后，就表示MyBatisPlus已经配置到项目中可以做基本的使用了。</p>
<h1><span id="mybatisplus-zhong-de-ji-ben-crud-fang-fa-shi-yong">MyBatisPlus中的基本CRUD方法使用</span><a href="#mybatisplus-zhong-de-ji-ben-crud-fang-fa-shi-yong" class="header-anchor"></a></h1><p>MyBatisPlus内置了许多基本的且功能强大的CRUD方法，基本的各类需求已经能够满足，无需开发人员自己动手编写mapper接口中的具体方法和对应的xxxmapper.xml映射文件，只需要将我们的接口继承com.baomidou.mybatisplus.mapper.BaseMapper接口即可。例如编写用户mapper：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tornado4651.mp.mapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.tornado4651.mp.beans.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过继承BaseMapper接口后，可以使用MP自带的CRUD功能，源码中具体如下，方法可分为两类，直接使用 和 传入条件使用。</p>
<p>直接使用的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入一条数据，参数是bean类，</span></span><br><span class="line"><span class="function">Integer <span class="title">insert</span><span class="params">(T var1)</span></span>;</span><br><span class="line"><span class="comment">//插入所有列</span></span><br><span class="line"><span class="function">Integer <span class="title">insertAllColumn</span><span class="params">(T var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Integer <span class="title">deleteById</span><span class="params">(Serializable var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Integer <span class="title">deleteByMap</span><span class="params">(@Param(<span class="string">"cm"</span>)</span> Map&lt;String, Object&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Integer <span class="title">deleteBatchIds</span><span class="params">(@Param(<span class="string">"coll"</span>)</span> Collection&lt;? extends Serializable&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Integer <span class="title">updateById</span><span class="params">(@Param(<span class="string">"et"</span>)</span> T var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Integer <span class="title">updateAllColumnById</span><span class="params">(@Param(<span class="string">"et"</span>)</span> T var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">selectById</span><span class="params">(Serializable var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">selectBatchIds</span><span class="params">(@Param(<span class="string">"coll"</span>)</span> Collection&lt;? extends Serializable&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">selectByMap</span><span class="params">(@Param(<span class="string">"cm"</span>)</span> Map&lt;String, Object&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">selectOne</span><span class="params">(@Param(<span class="string">"ew"</span>)</span> T var1)</span>;</span><br></pre></td></tr></table></figure>

<p>传入条件使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Integer <span class="title">delete</span><span class="params">(@Param(<span class="string">"ew"</span>)</span> Wrapper&lt;T&gt; var1)</span>;</span><br><span class="line"><span class="function">Integer <span class="title">update</span><span class="params">(@Param(<span class="string">"et"</span>)</span> T var1, @<span class="title">Param</span><span class="params">(<span class="string">"ew"</span>)</span> Wrapper&lt;T&gt; var2)</span>;</span><br><span class="line"><span class="function">Integer <span class="title">updateForSet</span><span class="params">(@Param(<span class="string">"setStr"</span>)</span> String var1, @<span class="title">Param</span><span class="params">(<span class="string">"ew"</span>)</span> Wrapper&lt;T&gt; var2)</span>;</span><br><span class="line"><span class="function">Integer <span class="title">selectCount</span><span class="params">(@Param(<span class="string">"ew"</span>)</span> Wrapper&lt;T&gt; var1)</span>;</span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">selectList</span><span class="params">(@Param(<span class="string">"ew"</span>)</span> Wrapper&lt;T&gt; var1)</span>;</span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; selectMaps(<span class="meta">@Param</span>(<span class="string">"ew"</span>) Wrapper&lt;T&gt; var1);</span><br><span class="line"><span class="function">List&lt;Object&gt; <span class="title">selectObjs</span><span class="params">(@Param(<span class="string">"ew"</span>)</span> Wrapper&lt;T&gt; var1)</span>;</span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">selectPage</span><span class="params">(RowBounds var1, @Param(<span class="string">"ew"</span>)</span> Wrapper&lt;T&gt; var2)</span>;</span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(RowBounds var1, <span class="meta">@Param</span>(<span class="string">"ew"</span>) Wrapper&lt;T&gt; var2);</span><br></pre></td></tr></table></figure>



<h1><span id="tiao-jian-gou-zao-qi">条件构造器</span><a href="#tiao-jian-gou-zao-qi" class="header-anchor"></a></h1><p>EntityWrapper</p>
<p>Condition.create()</p>
<h1><span id="dai-ma-sheng-cheng-gong-neng">代码生成功能</span><a href="#dai-ma-sheng-cheng-gong-neng" class="header-anchor"></a></h1><p>插件使用：</p>
<p><strong>分页插件</strong>： com.baomidou.mybatisplus.plugins.PaginationInterceptor</p>
<p><strong>执行分析插件</strong>：com.baomidou.mybatisplus.plugins.SqlExplainInterceptor</p>
<p><strong>性能分析插件</strong>：com.baomidou.mybatisplus.plugins.PerformanceInterceptor</p>
<p><strong>乐观锁插件</strong>：com.baomidou.mybatisplus.plugins.OptimisticLockerInterceptor</p>
<h1><span id="quan-ju-cao-zuo">全局操作</span><a href="#quan-ju-cao-zuo" class="header-anchor"></a></h1><p>自定义全局操作</p>
<ol>
<li>注入自己的mapper方法对应的sql语句</li>
<li>逻辑删除</li>
</ol>
]]></content>
      <categories>
        <category>CODING</category>
        <category>数据库</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库设计记录</title>
    <url>/2020/01/01/CODING/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#shu-ju-ku-de-san-da-te-xing">数据库的三大特性</a><ul>
<li><a href="#yuan-zi-xing">原子性</a></li>
<li><a href="#wan-zheng-xing">完整性</a></li>
</ul>
</li>
<li><a href="#san-da-fan-shi">三大范式</a><ul>
<li><a href="#di-yi-fan-shi">第一范式</a></li>
<li><a href="#di-er-fan-shi">第二范式</a></li>
<li><a href="#di-san-fan-shi">第三范式</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="shu-ju-ku-de-san-da-te-xing">数据库的三大特性</span><a href="#shu-ju-ku-de-san-da-te-xing" class="header-anchor"></a></h1><h2><span id="yuan-zi-xing">原子性</span><a href="#yuan-zi-xing" class="header-anchor"></a></h2><p>原子性是指：数据库中每一条数据的每一列值所表达的意义都不可以再分，如：</p>
<ul>
<li>“部门岗位”字段（❌）</li>
<li>“部门”“岗位”字段（✅）</li>
</ul>
<h2><span id="wan-zheng-xing">完整性</span><a href="#wan-zheng-xing" class="header-anchor"></a></h2><h1><span id="san-da-fan-shi">三大范式</span><a href="#san-da-fan-shi" class="header-anchor"></a></h1><h2><span id="di-yi-fan-shi">第一范式</span><a href="#di-yi-fan-shi" class="header-anchor"></a></h2><p>是指数据库的每一列都不可再分，即原子性。</p>
<p>错误设计</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdp00r0oe6j30f4040760.jpg" alt="错误"></p>
<p>正确设计：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdp01zd2gsj30ga048tal.jpg" alt="正确"></p>
<h2><span id="di-er-fan-shi">第二范式</span><a href="#di-er-fan-shi" class="header-anchor"></a></h2><p>在满足第二范式的基础上要求每个字段和主键相关，而不是锦盒主键部分相关（主要针对拥有多个字段的主键的“联合主键而言”）。</p>
<p>错误设计：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdozxd395gj30ko09ugqe.jpg" alt="错误"></p>
<p>改正设计：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdozy4fk6ij30rg0a27ac.jpg" alt="正确"></p>
<h2><span id="di-san-fan-shi">第三范式</span><a href="#di-san-fan-shi" class="header-anchor"></a></h2><p>表中主键和非主键字段必须直接相关，不能间接相关。</p>
<p>错误设计：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdozzdi7e4j30g6044wgd.jpg" alt="错误"></p>
<p>正确设计：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdp0042e1aj30pw040mzw.jpg" alt="正确"></p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis——主从复制</title>
    <url>/2020/01/01/CODING/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Reids%E2%80%94%E2%80%94%E4%B8%BB%E4%BB%8E%E5%92%8C%E5%93%A8%E5%85%B5/</url>
    <content><![CDATA[<blockquote>
<p>Redis的主从复制功能是在实践中常用到的一个重要功能，能够大大提高数据缓存的安全性和读写性能</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#zhu-cong-fu-zhi-master-slave">主从复制（Master/Slave）</a><ul>
<li><a href="#pei-zhi-he-shi-yong">配置和使用</a></li>
<li><a href="#ming-ling-xing-pei-zhi">命令行配置：</a></li>
<li><a href="#zhu-cong-fu-zhi-zhong-de-qing-kuang-ji-lu">主从复制中的情况记录</a></li>
</ul>
</li>
<li><a href="#shao-bing-mo-shi">哨兵模式</a><ul>
<li><a href="#pei-zhi-he-shi-yong-1">配置和使用</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="zhu-cong-fu-zhi-master-slave">主从复制（Master/Slave）</span><a href="#zhu-cong-fu-zhi-master-slave" class="header-anchor"></a></h1><p>Redis的主从复制（Master/Slave）功能主要是应对“容灾恢复，读写分离”的情况。</p>
<h2><span id="pei-zhi-he-shi-yong">配置和使用</span><a href="#pei-zhi-he-shi-yong" class="header-anchor"></a></h2><p>主从关系中：主写从读。每个客户端初始化角色都是master，所以主从复制的设定是：只要配置从机就好</p>
<h2><span id="ming-ling-xing-pei-zhi">命令行配置：</span><a href="#ming-ling-xing-pei-zhi" class="header-anchor"></a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> slaveof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br></pre></td></tr></table></figure>

<p>在从机的.conf配置文件中初始化主从关系：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################ REPLICATION #################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">在4.x版本中</span></span><br><span class="line"> replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">在3.x版本中</span></span><br><span class="line"> slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>

<p>创建不同的服务端时需要更改的基础配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bind</span><br><span class="line">port</span><br><span class="line">pidfile</span><br><span class="line">dbfilename</span><br><span class="line">dir</span><br></pre></td></tr></table></figure>

<h2><span id="zhu-cong-fu-zhi-zhong-de-qing-kuang-ji-lu">主从复制中的情况记录</span><a href="#zhu-cong-fu-zhi-zhong-de-qing-kuang-ji-lu" class="header-anchor"></a></h2><ul>
<li>从机在启动后会复制主机所有数据内容，没有时间限制</li>
<li>“主写从读”：从机只能读取，不能写入，可以在配置文件中“replica-read-only”后跟上陪孩子是否允许写入</li>
<li>主机下线后，如果不配置哨兵监控，从机待命，知道主机再次回来，从机继续跟上</li>
<li>从机掉线后，如果没有在配置文件中配置默认主从复制，则会变成master，需要重新命令配置</li>
<li>从机A可以当作从机B的主机，形成链条</li>
<li>从机被更改master后，从机上所有数据都会重新复制为新主机的数据，旧主机上无关</li>
</ul>
<h1><span id="shao-bing-mo-shi">哨兵模式</span><a href="#shao-bing-mo-shi" class="header-anchor"></a></h1><p>哨兵模式是指：另外启动一个哨兵服务，用于监控配置中命令哨兵监控的多个主从关系，用于在主机宕机或出现故障时，哨兵服从其的所有从机开启投票模式，重新选取主机继续工作。当旧主机恢复工作回来后，只能成为新主机的从机。</p>
<h2><span id="pei-zhi-he-shi-yong">配置和使用</span><a href="#pei-zhi-he-shi-yong" class="header-anchor"></a></h2><p>首先需要创建一个sentianl.conf文件，专门控制哨兵服务的启动初始化，文件中主要配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 配置要监控哪一个主机</span><br><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure>

<p>启动哨兵服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ redis-sentinel &#x2F;path&#x2F;to&#x2F;sentinal.conf</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CODING</category>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis——Jedis的使用</title>
    <url>/2020/01/01/CODING/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E2%80%94%E2%80%94Jedis%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>Jedis时在java上操控Redis的专用包，这篇文章记录了Jedis库的常用用法</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#ji-ben-ming-ling-shi-yong">基本命令使用</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<p>Jedis包的手动导入：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcjd9vnnxlj30510140sn.jpg" alt="截屏2020-03-05下午9.21.24"></p>
<h2><span id="ji-ben-ming-ling-shi-yong">基本命令使用</span><a href="#ji-ben-ming-ling-shi-yong" class="header-anchor"></a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"IP地址"</span>, 端口号);</span><br><span class="line">jedis</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CODING</category>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis——持久化</title>
    <url>/2020/01/01/CODING/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>Redis的持久化方面主要分为RDB和AOF两个方面，这篇文章主要讲解这两个方面</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#chi-jiu-hua-gai-shu">持久化概述</a><ul>
<li><a href="#redis-de-chi-jiu-hua">Redis的持久化</a></li>
</ul>
</li>
<li><a href="#rdb">RDB</a><ul>
<li><a href="#xiang-guan-pei-zhi">相关配置：</a></li>
<li><a href="#you-dian">优点</a></li>
<li><a href="#que-dian">缺点</a></li>
<li><a href="#qi-ta">其他</a></li>
</ul>
</li>
<li><a href="#aof">AOF</a><ul>
<li><a href="#xiang-guan-pei-zhi-he-cao-zuo">相关配置和操作</a></li>
<li><a href="#you-dian">优点：</a></li>
<li><a href="#que-dian-1">缺点</a></li>
<li><a href="#qi-ta-1">其他</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="chi-jiu-hua-gai-shu">持久化概述</span><a href="#chi-jiu-hua-gai-shu" class="header-anchor"></a></h1><h2><span id="redis-de-chi-jiu-hua">Redis的持久化</span><a href="#redis-de-chi-jiu-hua" class="header-anchor"></a></h2><p>Redis 提供了不同级别的持久化方式:</p>
<ul>
<li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</li>
<li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.</li>
<li>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li>
<li>你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li>
</ul>
<h1><span id="rdb">RDB</span><a href="#rdb" class="header-anchor"></a></h1><p>RDB全称：是一种通过“快照snapshot”技术将redis内存中的数据拷贝至磁盘中的方法，在每次启动服务的路径下创建一份rdb文件，用于记录redis内存数据库中的数据。而恢复则是将最新的rdb文件中的数据恢复到内存数据库中。具体方法：redis会在内存中先fork（复制）出一个子进程进行持久化操作，生成临时文件，等待持久化结束后，替换磁盘中的上次持久化的文件。</p>
<h2><span id="xiang-guan-pei-zhi">相关配置：</span><a href="#xiang-guan-pei-zhi" class="header-anchor"></a></h2><p>在redis.conf中，可以对rdb有如下的相关配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line"># 配置快照保存间隔条件，如果不需要快照，使用save “”即可</span><br><span class="line"># save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 保存的rdb文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">#配置保存路径</span><br><span class="line">dir .&#x2F;</span><br><span class="line"></span><br><span class="line"># 当生成RDB文件出错时是否继续处理 Redis 写命令</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># 是否对 RDB 文件进行压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 是否对 RDB 文件进行校验和校验，如果关闭会提高cpu性能</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure>

<p>命令配置：</p>
<ul>
<li><p>save：直接保存，并且阻塞所有IO操作，适合服务长时间休息时使用</p>
</li>
<li><p>bgsave：redis在后台异步进行快照操作，同时相应客户端的IO操作，适合工作时使用</p>
</li>
</ul>
<p>备份与恢复备份：</p>
<ul>
<li>每天将产生的dump.rdb文件冷备份到不同的物理硬盘上。恢复时只需要将冷备份的.rdp文件拷贝回server启动目录即可</li>
</ul>
<h2><span id="you-dian">优点</span><a href="#you-dian" class="header-anchor"></a></h2><ol>
<li>redis在每个设定好的时间点上都会保存所有的数据集，同时也使用增量备份，保存着过去30天内所有的数据。</li>
<li>适合大规模的备份，且对数据的完整性和一致性要求不高。</li>
<li>相比AOF更快</li>
</ol>
<h2><span id="que-dian">缺点</span><a href="#que-dian" class="header-anchor"></a></h2><ol>
<li>备份有间隔限制，一旦出现down机等意外情况，最后一次snapshot之后的数据将无法备份</li>
<li>每次fork出一个子进程时，内存中的数据都会成倍增加，占用内存</li>
</ol>
<h2><span id="qi-ta">其他</span><a href="#qi-ta" class="header-anchor"></a></h2><p>暂无记录</p>
<h1><span id="aof">AOF</span><a href="#aof" class="header-anchor"></a></h1><p>新技术的出现是为了解决上一代的缺点而设计，因为RDB在最后一次快照到发生突然事故这一段的数据是没有保存的，所以AOF有“实时记录”的特点。由于RDB在进行fork时会成倍增加内存体积，所以AOF并不进行数据备份，而是进行写操作备份。</p>
<p>AOF：以日志的形式来记录每个写操作到一个.aof文件中，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<h2><span id="xiang-guan-pei-zhi-he-cao-zuo">相关配置和操作</span><a href="#xiang-guan-pei-zhi-he-cao-zuo" class="header-anchor"></a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">############################## APPEND ONLY MODE ###############################</span><br><span class="line">#开启aof功能</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line">#定义aof文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line">#设定追加时间间隔</span><br><span class="line"># appendfsync always		#安全但是效率慢</span><br><span class="line"># appendfsync everysec	#适当</span><br><span class="line"># appendfsync no				#效率最高，但是不安全</span><br><span class="line"></span><br><span class="line">#重写配置，缩减文件体积大小</span><br><span class="line">auto-aof-rewrite-percentage 100 #当前AOF文件大小和上一次重写时AOF文件大小的比值</span><br><span class="line">auto-aof-rewrite-min-size 64mb  #文件的最小体积</span><br></pre></td></tr></table></figure>

<h2><span id="you-dian">优点：</span><a href="#you-dian" class="header-anchor"></a></h2><ol>
<li>提供了多种同步命令的方式，默认1秒同步一次写命令，最坏情况下会丢失不到1秒的数据；</li>
<li>AOF文件可读性交强，也可手动操作写命令。</li>
<li>并不占用内存容量。</li>
</ol>
<h2><span id="que-dian">缺点</span><a href="#que-dian" class="header-anchor"></a></h2><p> 1.AOF文件比RDB文件较大；<br> 2.redis负载较高时，RDB文件比AOF文件具有更好的性能；<br> 3.RDB使用快照的方式持久化整个redis数据，而aof只是追加写命令，因此从理论上来说，RDB比AOF方式更加健壮，另外，官方文档也指出，在某些情况下，AOF的确也存在一些bug，比如使用阻塞命令时，这些bug的场景RDB是不存在的。</p>
<h2><span id="qi-ta">其他</span><a href="#qi-ta" class="header-anchor"></a></h2><p>暂无记录</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac系统下的开发环境配置</title>
    <url>/2020/01/01/CODING/%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Mac%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>这篇文章主要记录了我在配置mac系统下的开发环境的详细步骤以及原理</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#pei-zhi-homebrew">配置Homebrew</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="pei-zhi-homebrew">配置Homebrew</span><a href="#pei-zhi-homebrew" class="header-anchor"></a></h1>]]></content>
      <categories>
        <category>CODING</category>
        <category>零散笔记</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】IDEA项目配置</title>
    <url>/2020/01/01/CODING/%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E3%80%90%E8%BD%AC%E3%80%91IDEA%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>作者 | Dulk<br>链接 | <a href="http://www.cnblogs.com/deng-cc/p/6416332.html" target="_blank" rel="noopener">www.cnblogs.com/deng-cc/p/6416332.html</a></p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#xiang-mu-pei-zhi-de-li-jie">项目配置的理解</a><ul>
<li><a href="#1-1-project"><strong>1.1 Project</strong></a></li>
<li><a href="#1-2-modules"><strong>1.2 Modules</strong></a><ul>
<li><a href="#1-2-1-zeng-shan-zi-xiang-mu"><strong>1.2.1 增删子项目</strong></a></li>
<li><a href="#1-2-2-zi-xiang-mu-pei-zhi"><strong>1.2.2 子项目配置</strong></a></li>
<li><a href="#1-2-3-zeng-shan-kuang-jia-web-bu-shu-1"><strong>1.2.3 增删框架（Web部署-1）</strong></a></li>
</ul>
</li>
<li><a href="#1-3-libraries"><strong>1.3 Libraries</strong></a></li>
<li><a href="#1-4-facets"><strong>1.4 Facets</strong></a></li>
<li><a href="#1-5-artifacts-web-bu-shu-2"><strong>1.5 Artifacts（Web部署-2）</strong></a></li>
</ul>
</li>
<li><a href="#can-kao-lian-jie">参考链接</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="xiang-mu-pei-zhi-de-li-jie">项目配置的理解</span><a href="#xiang-mu-pei-zhi-de-li-jie" class="header-anchor"></a></h1><p>IDEA 中最重要的各种设置项，就是这个 Project Structre 了，关乎你的项目运行，缺胳膊少腿都不行。最近公司正好也是用之前自己比较熟悉的IDEA而不是Eclipse，为了更深入理解和使用，就找来各种资料再研究一下，这里整理后来个输出。</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcee31fkmjj30u00ewjsr.jpg" alt="img"></p>
<h2><span id="1-1-project"><strong>1.1 Project</strong></span><a href="#1-1-project" class="header-anchor"></a></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshHCH5Az9piaaEt0TAR2mqZTp5krt1iaQbOC2uzz1QogTWjeelliaibodabvfFqE8bglDbcX29lud0TNQ/640?wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><strong>1. Project name</strong>：</p>
<p>定义项目的名称；</p>
<p><strong>2. Project SDK</strong>：</p>
<p>设置该项目使用的JDK，也可以在此处新添加其他版本的JDK；</p>
<p><strong>3. Project language level</strong>：</p>
<p>这个和JDK的类似，区别在于，假如你设置了JDK1.8，却只用到1.6的特性，那么这里可以设置语言等级为1.6，这个是限定项目编译检查时最低要求的JDK特性；</p>
<p><strong>4. Project compiler output</strong>：</p>
<p>项目中的默认编译输出总目录，如图黄色部分，实际上每个模块可以自己设置特殊的输出目录（Modules - (project) - Paths - Use module compile output path），所以这个设置有点鸡肋。</p>
<p>小插曲：更多 IDEA 相关文章可以本公众号（Java后端）回复 技术博文，获取~</p>
<h2><span id="1-2-modules"><strong>1.2 Modules</strong></span><a href="#1-2-modules" class="header-anchor"></a></h2><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcee346elej30u00gg760.jpg" alt="img"></p>
<h3><span id="1-2-1-zeng-shan-zi-xiang-mu"><strong>1.2.1 增删子项目</strong></span><a href="#1-2-1-zeng-shan-zi-xiang-mu" class="header-anchor"></a></h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcee32qhyrj30u00ggjt2.jpg" alt="img"></p>
<p>一个项目中可以有多个子项目，每个子项目相当于一个模块。一般我们项目只是单独的一个，IntelliJ IDEA 默认也是单子项目的形式，所以只需要配置一个模块。</p>
<p>（此处的两个项目引入仅作示例参考）</p>
<h3><span id="1-2-2-zi-xiang-mu-pei-zhi"><strong>1.2.2 子项目配置</strong></span><a href="#1-2-2-zi-xiang-mu-pei-zhi" class="header-anchor"></a></h3><p>每个子项目都对应了Sources、Paths、Dependencies 三大配置选项：</p>
<p><strong>Sources</strong>：</p>
<p>显示项目的目录资源，那些是项目部署的时候需要的目录，不同颜色代表不同的类型；</p>
<p><strong>Paths</strong>：</p>
<p>可以指定项目的编译输出目录，即项目类和测试类的编译输出地址（替换掉了Project的默认输出地址）</p>
<p><strong>Dependencies</strong>：项目的依赖</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcee31o2ygj30ty0oytby.jpg" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcee35j35bj30ty0oy0v5.jpg" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcee33dypyj30ty0oydkg.jpg" alt="img"></p>
<h3><span id="1-2-3-zeng-shan-kuang-jia-web-bu-shu-1"><strong>1.2.3 增删框架（Web部署-1）</strong></span><a href="#1-2-3-zeng-shan-kuang-jia-web-bu-shu-1" class="header-anchor"></a></h3><p>每个子项目之下都可以定义它所使用的框架，这里重点说明一下Web部分的设置。</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcee351vghj30u00gggnc.jpg" alt="img"></p>
<h2><span id="1-3-libraries"><strong>1.3 Libraries</strong></span><a href="#1-3-libraries" class="header-anchor"></a></h2><p>这里可以显示所添加的jar包，同时也可以添加jar包，并且可以把多个jar放在一个组里面，类似于jar包整理。</p>
<p>这里默认将每个jar包做为了一个单独的组（未测试，待定）。</p>
<h2><span id="1-4-facets"><strong>1.4 Facets</strong></span><a href="#1-4-facets" class="header-anchor"></a></h2><p>官方的解释是：</p>
<p>When you select a framework (a facet) in the element selector pane, the settings for the framework are shown in the right-hand part of the dialog.</p>
<p>（当你在左边选择面板点击某个技术框架，右边将会显示这个框架的一些设置）</p>
<p>说实话，并没有感觉到有什么作用。</p>
<h2><span id="1-5-artifacts-web-bu-shu-2"><strong>1.5 Artifacts（Web部署-2）</strong></span><a href="#1-5-artifacts-web-bu-shu-2" class="header-anchor"></a></h2><p>项目的打包部署设置，这个是项目配置里面比较关键的地方，重点说一下。</p>
<p>先理解下它的含义，来看看官方定义的artifacts：</p>
<p>An artifact is an assembly of your project assets that you put together to test, deploy or distribute your software solution or its part. Examples are a collection of compiled Java classes or a Java application packaged in a Java archive, a Web application as a directory structure or a Web application archive, etc.</p>
<p>即编译后的Java类，Web资源等的整合，用以测试、部署等工作。再白话一点，就是说某个module要如何打包，例如war exploded、war、jar、ear等等这种打包形式。某个module有了 Artifacts 就可以部署到应用服务器中了。</p>
<p><strong>*( jar</strong>：<em>*Java ARchive，通常用于聚合大量的Java类文件、相关的元数据和资源（文本、图片等）文件到一个文件，以便分发Java平台应用软件或库；</em></p>
<p><strong>*war</strong>：<em>*Web application ARchive，一种JAR文件，其中包含用来分发的JSP、Java Servlet、Java类、XML文件、标签库、静态网页（HTML和相关文件），以及构成Web应用程序的其他资源；</em></p>
<p><strong>*exploded</strong>：<em>*在这里你可以理解为展开，不压缩的意思。也就是war、jar等产出物没压缩前的目录结构。建议在开发的时候使用这种模式，便于修改了文件的效果立刻显现出来。)</em></p>
<p>默认情况下，IDEA的 Modules 和 Artifacts 的 output目录已经设置好了，不需要更改，打成war包的时候会自动在 WEB-INF目录下生成classes，然后把编译后的文件放进去。</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcee31v7m3j30u00ewjsw.jpg" alt="img"></p>
<p>你可能对这里的输出目录不太理解，之前不是配置过了文件编译的输出目录了吗？为什么这里还有一个整合这些资源的目录呢？它又做了哪些事呢？ </p>
<p>其实，实际上，当你点击运行tomcat时，默认就开始做以下事情：</p>
<p>编译，IDEA在保存/自动保存后不会做编译，不像Eclipse的保存即编译，因此在运行server前会做一次编译。</p>
<p>编译后class文件存放在指定的项目编译输出目录下（见1.2.2）；</p>
<p>根据artifact中的设定对目录结构进行创建；</p>
<p>拷贝web资源的根目录下的所有文件到artifact的目录下（见1.2.3）；</p>
<p>拷贝编译输出目录下的classes目录到artifact下的WEB-INF下（见1.2.2）；</p>
<p>拷贝lib目录下所需的jar包到artifact下的WEB_INF下；</p>
<p>运行server，运行成功后，如有需要，会自动打开浏览器访问指定url。</p>
<p>在这里还要注意的是，配置完成的artifact，需要在tomcat中进行添加：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshHCH5Az9piaaEt0TAR2mqZTgROnrP2G5UdI0n4LVovTJMoCFmB6LFrDvz6XsA038I6MEgb7Zecrwg/640?wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h1><span id="can-kao-lian-jie">参考链接</span><a href="#can-kao-lian-jie" class="header-anchor"></a></h1><p>IntelliJ IDEA 项目相关的几个重要概念介绍</p>
<p>whudoc.qiniudn.com/2016/IntelliJ-IDEA-Tutorial/project-composition-introduce.html</p>
<p><a href="http://www.jetbrains.com/help/idea/2016.3/dependencies-tab.html" target="_blank" rel="noopener">www.jetbrains.com/help/idea/2016.3/dependencies-tab.html</a></p>
<p>Dependencies Tab</p>
<p><a href="https://www.jetbrains.com/help/idea/2016.3/facet-page.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/idea/2016.3/facet-page.html</a></p>
<p>Facet Page</p>
<p>Working with Artifacts</p>
<p><a href="http://www.jetbrains.com/help/idea/2016.3/working-with-artifacts.html#artifact_def" target="_blank" rel="noopener">www.jetbrains.com/help/idea/2016.3/working-with-artifacts.html#artifact_def</a></p>
<p>Intellij IDEA 14.x 中的Facets和Artifacts的区别</p>
<p><a href="http://www.cnblogs.com/52php/p/5677661.html" target="_blank" rel="noopener">www.cnblogs.com/52php/p/5677661.html</a></p>
<p>IntelliJ使用指南—— 深入理解IntelliJ的Web部署逻辑</p>
<p>white-crucifix.iteye.com/blog/2070830</p>
<p>IntelliJ IDEA WEB项目的部署配置</p>
<p>my.oschina.net/lujianing/blog/186737</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>零散笔记</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下设置隐藏文件/文件夹</title>
    <url>/2020/01/01/%E7%94%9F%E6%B4%BB%E9%9A%8F%E8%AE%B0/%E7%A7%91%E6%8A%80/%EF%A3%BF/Mac%E4%B8%8B%E8%AE%BE%E7%BD%AE%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<blockquote>
<p>在mac上如何将文件和文件夹隐藏起来</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#she-zhi-xian-shi-he-yin-cang-wen-jian-jia">设置显示和隐藏文件夹</a></li>
<li><a href="#quan-ju-xian-shi-he-yin-cang-wen-jian-jia">全局显示和隐藏文件夹</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="she-zhi-xian-shi-he-yin-cang-wen-jian-jia">设置显示和隐藏文件夹</span><a href="#she-zhi-xian-shi-he-yin-cang-wen-jian-jia" class="header-anchor"></a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chflags hidden ~&#x2F;路径&#x2F;文件夹名</span><br><span class="line">chflags nohidden ~&#x2F;路径&#x2F;文件夹名</span><br></pre></td></tr></table></figure>

<h1><span id="quan-ju-xian-shi-he-yin-cang-wen-jian-jia">全局显示和隐藏文件夹</span><a href="#quan-ju-xian-shi-he-yin-cang-wen-jian-jia" class="header-anchor"></a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示全部文件</span><br><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool true</span><br><span class="line">osascript -e &#39;tell application &quot;Finder&quot; to quit&#39;</span><br><span class="line"></span><br><span class="line"># 不显示全部文件</span><br><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool false</span><br><span class="line">osascript -e &#39;tell application &quot;Finder&quot; to quit&#39;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>生活随记</category>
        <category>科技</category>
        <category></category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac入门教程</title>
    <url>/2020/01/01/%E7%94%9F%E6%B4%BB%E9%9A%8F%E8%AE%B0/%E7%A7%91%E6%8A%80/%EF%A3%BF/Mac%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>这篇文章写给想要了解或正在纠结是否合适Mac系统的小白，以及最近刚从windows转达Mac尝鲜上手的朋友们。</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#mac-vs-win">Mac VS.  Win</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="mac-vs-win">Mac  VS.  Win</span><a href="#mac-vs-win" class="header-anchor"></a></h1><p>这是一个老生常谈的话题了，</p>
]]></content>
      <categories>
        <category>生活随记</category>
        <category>科技</category>
        <category></category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring+SpringMVC的整合</title>
    <url>/2020/01/01/CODING/Java%20Web%E6%A1%86%E6%9E%B6/Spring%20MVC/Spring%20%E4%B8%8ESpringMVC%E7%9A%84%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<blockquote>
<p>关于将非web环境的管理容器Spring 和 web环境的SpringMVC进行整合的实现思路， 具体方法</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#yi-wei-shi-me-xu-yao-zheng-he">一、为什么需要整合</a></li>
<li><a href="#er-spring-de-zui-ji-chu-pei-zhi">二、Spring的最基础配置</a></li>
<li><a href="#san-springmvc-kuang-jia-de-ji-ben-pei-zhi">三、SpringMVC框架的基本配置</a></li>
<li><a href="#si-spring-he-springmvc-zui-ji-chu-de-zheng-he">四、Spring和SpringMVC最基础的整合</a></li>
<li><a href="#wu-zong-jie">五、总结</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>


<p>[toc]</p>
<h1><span id="yi-wei-shi-me-xu-yao-zheng-he">一、为什么需要整合</span><a href="#yi-wei-shi-me-xu-yao-zheng-he" class="header-anchor"></a></h1><p>Spring框架主要提供思想，并且实现便利的DI和AOP。</p>
<p>而SpringMVC又可以将Spirng很具体的实现在web应用上，但仅仅是处理web上会变的简单高效，后端的整体支持还需要Spring这个大框架的支持</p>
<h1><span id="er-spring-de-zui-ji-chu-pei-zhi">二、Spring的最基础配置</span><a href="#er-spring-de-zui-ji-chu-pei-zhi" class="header-anchor"></a></h1><p>Spring主要是IOC控制反转思想，具体来说，就是容器对java对象的自动实例化，自动装配，并在创建好之后存入Spring容器中，开发人员在程序中调用时及时返回，但返回后具体怎么用还是要看开发人员。</p>
<p>实现在代码中，可以简单的看作，Spring容器就是自己定义的xml配置文件。Spring的IOC容器创建方法：</p>
<p>非web环境下：</p>
<p>Spring的xml配置框架：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"自定义的唯一标识符，一般都是将类名首字母小写"</span> <span class="attr">class</span>=<span class="string">"具体要装配类的全类名"</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"类中的成员变量名"</span> <span class="attr">value</span>=<span class="string">"你要赋予的值"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"构造器中的形参名"</span> <span class="attr">value</span>=<span class="string">"形参对应的值"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在.java文件中的具体调用Spring容器，并且从容器中获得自动装配好的bean对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 具体的包名</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXX</span></span>&#123;</span><br><span class="line">  ApllicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"具体路径以及xml配置文件名"</span>);</span><br><span class="line">  <span class="comment">//从Spring的IOC容器中获得创建好的bean对象，如自定义的Person</span></span><br><span class="line"> 	Persoon person = applicationContext.getBean(<span class="string">"person"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="comment">//传统方法</span></span><br><span class="line">  Person person = <span class="keyword">new</span> Person();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1><span id="san-springmvc-kuang-jia-de-ji-ben-pei-zhi">三、SpringMVC框架的基本配置</span><a href="#san-springmvc-kuang-jia-de-ji-ben-pei-zhi" class="header-anchor"></a></h1><p>SpringMVC是指Spring大框架中的WEB部分，主要是依靠”org.springframework.web.servlet.DispatcherServlet“这个具体的Servlet实现将web请求转发给SpringMVC组件做进一步处理</p>
<p>具体实现：</p>
<p>web项目的入口web.xml中配置SpringMVC所提供的DespatcherServlet连接到具体的springMVC配置文件中（DispatcherServlet只是基本配置，还有filter等）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span> <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:SpringMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- Map all requests to the DispatcherServlet for handling --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后再在SpringMVC的具体xml文件中的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/content/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--- 基本默认配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>









<h1><span id="si-spring-he-springmvc-zui-ji-chu-de-zheng-he">四、Spring和SpringMVC最基础的整合</span><a href="#si-spring-he-springmvc-zui-ji-chu-de-zheng-he" class="header-anchor"></a></h1><p>因为ServletContext是web应用中最基础的组件（Tomcat一启动，ServletContext就被创建了），所以应该创建一个监听器，用于监听ServletContext，监听到ServletContext对像被创建，就立即创建IOC容器。并且为了让所有的controller（handler）能够使用IOC容器自动管理bean对象，所有还要将IOC容器绑定到ServletContext中，以便让所有的组件能共享到IOC容器。</p>
<p>具体实现方法：</p>
<p>在动态web工程的必备配置文件：web.xml中作出如下配置：ContextLoaderListener用于在tomcat启动创建contextServlet时创建一个统一的applicationContext对象，用于以后的调用。DispatcherServlet指定到SpringMVC的具体配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span> <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  	<span class="comment">&lt;!-- Bootstraps the root web application context before servlet initialization --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">&lt;!-- needed for ContextLoaderListener --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:Spring.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- The front controller of this Spring Web application, responsible for handling all application requests --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- Map all requests to the DispatcherServlet for handling --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的基础配置上，我们便可以在指定的param-value下创建具体的Spring和Springmvc配置文件了.</p>
<p>Spring.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.tornado4651.SS"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring不需要管理web请求的相关操作 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SpringMVC.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.tornado4651.SS"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">		注意：因为Spring和SpringMVC都需要启动组建扫描以自动装配带有注解的类、方法、参数，所以</span></span><br><span class="line"><span class="comment">		而SpringMVC又是web服务，主要负责请求的接收、转发、重定向等操作，因此只扫描带有Controller的注解即可</span></span><br><span class="line"><span class="comment">		 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1><span id="wu-zong-jie">五、总结</span><a href="#wu-zong-jie" class="header-anchor"></a></h1>]]></content>
      <categories>
        <category>CODING</category>
        <category>Java Web框架</category>
        <category>Spring MVC</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>二、ES的使用及关键字查询</title>
    <url>/2020/05/28/CODING/%E6%95%B0%E6%8D%AE%E5%BA%93/ElasticSearch/%E4%BA%8C%E3%80%81ES%E7%9A%84%E2%80%9C%E8%AF%AD%E6%B3%95%E2%80%9D%E3%80%81%E2%80%9C%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%9D%E7%AD%89%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>ElasticSearch的语法和关键字实在是太多太复杂了，因此单独开出一篇文章记录它们的用法</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#can-kao-lian-jie">参考链接</a></li>
<li><a href="#es-de-gai-nian">ES的概念</a><ul>
<li><a href="#es-zhong-de-shu-ju">ES中的“数据”</a></li>
<li><a href="#wen-dang">文档</a><ul>
<li><a href="#wen-dang-yuan-shu-ju">文档元数据</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ji-ben-cao-zuo-crud">基本操作CRUD</a><ul>
<li><a href="#chuang-jian">创建</a></li>
<li><a href="#huo-qu">获取</a></li>
<li><a href="#geng-xin">更新</a></li>
<li><a href="#shan-chu">删除</a></li>
</ul>
</li>
<li><a href="#pi-liang-cao-zuo">批量操作</a><ul>
<li><a href="#duo-wen-dang-jian-suo-mget">多文档检索——mget</a></li>
<li><a href="#duo-gong-neng-pi-liang-cao-zuo-bulk">多功能批量操作—bulk</a></li>
</ul>
</li>
<li><a href="#sou-suo-search">搜索——“_search”</a><ul>
<li><a href="#ji-ben-sou-suo-kong-sou-suo">基本搜索：空搜索</a></li>
<li><a href="#duo-suo-yin-duo-lei-xing-sou-suo">多索引多类型搜索</a></li>
<li><a href="#fen-ye-sou-suo">分页搜索</a></li>
</ul>
</li>
<li><a href="#api-he-guan-jian-zi-hui-zong-ji-lu">API 和 关键字 汇总记录</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[TOC]</p>
<h1><span id="can-kao-lian-jie">参考链接</span><a href="#can-kao-lian-jie" class="header-anchor"></a></h1><p><a href="https://wiki.jikexueyuan.com/project/elasticsearch-definitive-guide-cn/" target="_blank" rel="noopener">Elasticsearch 权威指南（中文版）</a></p>
<p><a href="https://www.jianshu.com/p/3873a6290c65" target="_blank" rel="noopener">ES学习教程</a></p>
<p><a href="https://blog.csdn.net/qq_22612245/article/details/82432107" target="_blank" rel="noopener">elasticsearch 关键词查询-实现like查询</a></p>
<p><a href="https://www.cnblogs.com/shoufeng/category/1332134.html" target="_blank" rel="noopener">瘦风的南墙</a></p>
<h1><span id="es-de-gai-nian">ES的概念</span><a href="#es-de-gai-nian" class="header-anchor"></a></h1><h2><span id="es-zhong-de-shu-ju">ES中的“数据”</span><a href="#es-zhong-de-shu-ju" class="header-anchor"></a></h2><p>传统意义上“面向对象编程”的数据都是提供在一个Object中，对象(object)是一种语言相关，记录在内存中的的数据结构。为了在网络间发送，或者存储它，我们需要一些标准的格式来表示它。JSON (JavaScript Object Notation是一种可读的以文本来表示对象的方式。它已经成为NoSQL世界中数据交换的一种事实标准。</p>
<p>在ES的世界中，数据被分为以下几个级别的记录方式：</p>
<blockquote>
<p>文档 — 索引 — 类型 — id —元数据 — “_source”</p>
</blockquote>
<h2><span id="wen-dang">文档</span><a href="#wen-dang" class="header-anchor"></a></h2><p>通常，我们可以认为<strong>对象(object)</strong>和<strong>文档(document)</strong>是等价相通的。不过，他们还是有所差别：对象(Object)是一个JSON结构体——类似于哈希、hashmap、字典或者关联数组；对象(Object)中还可能包含其他对象(Object)。</p>
<p> 在Elasticsearch中，<strong>文档(document)</strong>这个术语有着特殊含义。它特指最顶层结构或者<strong>根对象(root object)</strong>序列化成的JSON数据（以唯一ID标识并存储于Elasticsearch中）。</p>
<h3><span id="wen-dang-yuan-shu-ju">文档元数据</span><a href="#wen-dang-yuan-shu-ju" class="header-anchor"></a></h3><p>一个文档不只有数据。它还包含了<strong>元数据(metadata)</strong>，如：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhf0c7fl7j30u00uzjy4.jpg" alt="截屏2020-06-05 下午2.36.08"></p>
<p>关于文档的信息。三个必须的元数据节点是：</p>
<table>
<thead>
<tr>
<th align="center">节点</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>_index</code></td>
<td align="center">文档存储的地方</td>
</tr>
<tr>
<td align="center"><code>_type</code></td>
<td align="center">文档代表的对象的类</td>
</tr>
<tr>
<td align="center"><code>_id</code></td>
<td align="center">文档的唯一标识</td>
</tr>
</tbody></table>
<h1><span id="ji-ben-cao-zuo-crud">基本操作CRUD</span><a href="#ji-ben-cao-zuo-crud" class="header-anchor"></a></h1><h2><span id="chuang-jian">创建</span><a href="#chuang-jian" class="header-anchor"></a></h2><p>使用<strong>PUT</strong>方法，传入一个新的文档：/index/type/id以及具体的JSON内容时，即为创建</p>
<p>如果创建时不清楚该文档是否存在，可以使用<strong>HEAD</strong>方法检查是否存在</p>
<ul>
<li><p>补充操作：</p>
<ol>
<li><p>在创建时确保是全新文档，而不会进行更新的操作。请求后跟上<strong>op_type=create参数</strong>或者<strong>_create参数</strong></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/2?op_type=create</span><br><span class="line">&#123;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br><span class="line">PUT /website/blog/2?_create</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<pre><code>2. 如果ES依赖的关系数据库中拥有版本控制字段，那么就可以在创建文档的时候使用指定**version_type=external**外部版本。

3. 在创建时就指定版本号，version=【x】

    <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/2?version=5&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  "title": "My first external blog entry",</span><br><span class="line">  "text":  "Starting to get the hang of this..."</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2><span id="huo-qu">获取</span><a href="#huo-qu" class="header-anchor"></a></h2><blockquote>
<p>注意：这里的GET方法操作只是获取<strong>文档信息</strong>而已，并不是完全的返回<strong>文档内容</strong>。</p>
<p>除非请求方法上写全了index、type、id三大值。</p>
<p>想要进行条件查询筛选等操作，会在后面的<strong>“_search”</strong>关键字中单独详细记录</p>
</blockquote>
<p>使用<strong>GET</strong>方法，根据 /index/type/id 获取文档相关具体信息</p>
<ul>
<li>补充操作：<ol>
<li>使用_source指定查询范围，或者只返回_source部分。只能在确定了index、type、id后使用</li>
<li>使用pretty参数美化输出格式</li>
<li>版本控制：使用version</li>
</ol>
</li>
</ul>
<h2><span id="geng-xin">更新</span><a href="#geng-xin" class="header-anchor"></a></h2><p><strong>1.整个文档更新</strong></p>
<p>直接使用PUT方法传入一份完整的新文档，ES会自动进行更新覆盖操作。并返回如下响应</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 更新文档的具体基本信息</span></span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"123"</span>,</span><br><span class="line">  <span class="comment">// 更新后版本号+1</span></span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="comment">// 结果提示：更新操作，而不是创建操作</span></span><br><span class="line">  <span class="attr">"result"</span>: <span class="string">"updated"</span>,</span><br><span class="line">  <span class="comment">// 其他信息</span></span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"_seq_no"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"_primary_term"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.局部更新</strong></p>
<p>使用<strong>_update条件</strong>向旧文档中添加新的字段，并使用<strong>doc局部文档</strong>设置添加字段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">   "doc" : &#123;</span><br><span class="line">      "tags" : [ "testing" ],</span><br><span class="line">      "views": 0</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<strong>upsert</strong>保证文档不存在时，也能进行局部更新</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /website/pageviews/1/_update</span><br><span class="line">&#123;</span><br><span class="line">   "upsert": &#123;</span><br><span class="line">       "views": 1</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于多用户的局部更新，文档被修改了并不要紧。例如，两个进程都要增加页面浏览量，增加的顺序我们并不关心——如果冲突发生，我们唯一要做的仅仅是重新尝试更新既可。所以要设置冲突后的重试次数</p>
<p>使用<strong>retry_on_conflict</strong>设置更新操作产生冲突时的重试次数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /website/pageviews/1/_update?retry_on_conflict=5 &lt;1&gt;</span><br><span class="line">&#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3.更新和冲突问题</strong></p>
<blockquote>
<p> 为了避免丢失数据，<code>update</code> API在<strong>检索(retrieve)</strong>阶段检索文档的当前<code>_version</code>，然后在<strong>重建索引(reindex)</strong>阶段通过<code>index</code>请求提交。如果其他进程在<strong>检索(retrieve)</strong>和<strong>重建索引(reindex)</strong>阶段修改了文档，<code>_version</code>将不能被匹配，然后更新失败。</p>
</blockquote>
<h2><span id="shan-chu">删除</span><a href="#shan-chu" class="header-anchor"></a></h2><p>使用<strong>DELETE</strong>方法。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DELETE /website/blog/123</span><br></pre></td></tr></table></figure>

<p>如果文档被找到，Elasticsearch将返回<code>200 OK</code>状态码和以下响应体。</p>
<p>如果文档未找到，我们将得到一个<code>404 Not Found</code>状态码。</p>
<blockquote>
<p>注意：对文档进行DELETE删除操作，不管成功与否，都会将文档的version值+1。因为这是内部记录的一部分，它确保在多节点间不同操作可以有正确的顺序。</p>
<p>并且删除一个文档也不会立即从磁盘上移除，它只是被标记成已删除。Elasticsearch将会在你之后添加更多索引的时候才会在后台进行删除内容的清理。</p>
</blockquote>
<h1><span id="pi-liang-cao-zuo">批量操作</span><a href="#pi-liang-cao-zuo" class="header-anchor"></a></h1><h2><span id="duo-wen-dang-jian-suo-mget">多文档检索——mget</span><a href="#duo-wen-dang-jian-suo-mget" class="header-anchor"></a></h2><p>Elasticsearch中检索多个文档，相对于一个一个的检索，更快的方式是在一个请求中使用<strong>multi-get</strong>或<strong>mget</strong> API。</p>
<p>mget参数直接单独作为参数发送即可，不需要写明index、type、id等信息了，因为是多部分请求，所以具体信息都在请求体中。</p>
<p>mget的请求参数是一个docs的数组，数组中的每一项是具体的文档定位和内容等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /_mget</span><br><span class="line">&#123;</span><br><span class="line">   "docs" : [</span><br><span class="line">      &#123;</span><br><span class="line">         "_index" : "website",</span><br><span class="line">         "_type" :  "blog",</span><br><span class="line">         "_id" :    2</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         "_index" : "website",</span><br><span class="line">         "_type" :  "pageviews",</span><br><span class="line">         "_id" :    1,</span><br><span class="line">         "_source": "views"</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="duo-gong-neng-pi-liang-cao-zuo-bulk">多功能批量操作—bulk</span><a href="#duo-gong-neng-pi-liang-cao-zuo-bulk" class="header-anchor"></a></h2><p><code>bulk</code> API允许我们使用单一请求来实现多个文档的<code>create</code>、<code>index</code>、<code>update</code>或<code>delete</code>。这对索引类似于日志活动这样的数据流非常有用，它们可以以成百上千的数据为一个批次按序进行索引。</p>
<p><strong>bulk请求体格式：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 第一个请求</span><br><span class="line">&#123; 【action】: &#123; 【metadata】 &#125;&#125;\n</span><br><span class="line">&#123; 【request body】        &#125;\n</span><br><span class="line"># 第二个请求</span><br><span class="line">&#123; 【action】: &#123; 【metadata】 &#125;&#125;\n</span><br><span class="line">&#123; 【request body】        &#125;\n</span><br><span class="line"># 第三个请求</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>bulk请求的每一行末尾必须使用“\n”分隔符，即使最后一行</p>
<p>【action】和【metadata】字段具有<code>操作方法</code>和<code>指定操作文档</code>的作用。</p>
<p>【action】必须是以下几种：</p>
<table>
<thead>
<tr>
<th align="left">行为</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>create</code></td>
<td align="left">当文档不存在时创建之。</td>
</tr>
<tr>
<td align="left"><code>index</code></td>
<td align="left">创建新文档或替换已有文档。</td>
</tr>
<tr>
<td align="left"><code>update</code></td>
<td align="left">局部更新文档。</td>
</tr>
<tr>
<td align="left"><code>delete</code></td>
<td align="left">删除一个文档。</td>
</tr>
</tbody></table>
<p><strong>举例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"delete"</span>: &#123; <span class="attr">"_index"</span>: <span class="string">"website"</span>, <span class="attr">"_type"</span>: <span class="string">"blog"</span>, <span class="attr">"_id"</span>: <span class="string">"123"</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>一个完整的bulk请求如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; "delete": &#123; "_index": "website", "_type": "blog", "_id": "123" &#125;&#125;\n</span><br><span class="line">&#123; "create": &#123; "_index": "website", "_type": "blog", "_id": "123" &#125;&#125;\n</span><br><span class="line">&#123; "title":    "My first blog post" &#125;\n</span><br><span class="line">&#123; "index":  &#123; "_index": "website", "_type": "blog" &#125;&#125;\n</span><br><span class="line">&#123; "title":    "My second blog post" &#125;\n</span><br><span class="line">&#123; "update": &#123; "_index": "website", "_type": "blog", "_id": "123", "_retry_on_conflict" : 3&#125; &#125;\n</span><br><span class="line">&#123; "doc" : &#123;"title" : "My updated blog post"&#125; &#125; \n</span><br></pre></td></tr></table></figure>

<p>bulk请求体中【metadata】中的index和type如果都相同，可以提出到请求头中，如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /website/log/_bulk</span><br><span class="line"><span class="comment">// 与请求头中的index和type相同，不需要指定</span></span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125; </span><br><span class="line">&#123; <span class="attr">"event"</span>: <span class="string">"User logged in"</span> &#125;</span><br><span class="line"><span class="comment">// 与请求头中的type值不同，进行指定覆盖</span></span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_type"</span>: <span class="string">"blog"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"title"</span>: <span class="string">"Overriding the default type"</span> &#125;</span><br></pre></td></tr></table></figure>

<h1><span id="sou-suo-search">搜索——“_search”</span><a href="#sou-suo-search" class="header-anchor"></a></h1><p>在实际应用中查询数据，条件查询，结构化查询中，最主要的是<strong>“_search”API</strong>，重要程度等同于SQL中的SELECT语句。</p>
<h2><span id="ji-ben-sou-suo-kong-sou-suo">基本搜索：空搜索</span><a href="#ji-ben-sou-suo-kong-sou-suo" class="header-anchor"></a></h2><p>空搜索会查询到ES集群中所有的数据，并默认返回前十条。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br></pre></td></tr></table></figure>

<h2><span id="duo-suo-yin-duo-lei-xing-sou-suo">多索引多类型搜索</span><a href="#duo-suo-yin-duo-lei-xing-sou-suo" class="header-anchor"></a></h2><p>如果需要的数据文档存放在不同索引或者相同索引不同类型下，可以使用多索引多类型搜索</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/gb/_search</span><br><span class="line">在索引gb的所有类型中搜索</span><br><span class="line"></span><br><span class="line">/gb,us/_search</span><br><span class="line">在索引gb和us的所有类型中搜索</span><br><span class="line"></span><br><span class="line">/g*,u*/_search</span><br><span class="line">在以g或u开头的索引的所有类型中搜索</span><br><span class="line"></span><br><span class="line">/gb/user/_search</span><br><span class="line">在索引gb的类型user中搜索</span><br><span class="line"></span><br><span class="line">/gb,us/user,tweet/_search</span><br><span class="line">在索引gb和us的类型为user和tweet中搜索</span><br><span class="line"></span><br><span class="line">/_all/user,tweet/_search</span><br><span class="line">在所有索引的user和tweet中搜索</span><br></pre></td></tr></table></figure>

<h2><span id="fen-ye-sou-suo">分页搜索</span><a href="#fen-ye-sou-suo" class="header-anchor"></a></h2><p>在请求语句上使用如下API确定分页条件</p>
<p><code>size</code>: 每页结果数，默认10</p>
<p><code>from</code>: 跳过开始的结果数，默认0</p>
<h1><span id="api-he-guan-jian-zi-hui-zong-ji-lu">API 和 关键字 汇总记录</span><a href="#api-he-guan-jian-zi-hui-zong-ji-lu" class="header-anchor"></a></h1><table>
<thead>
<tr>
<th align="center">API</th>
<th align="center">含义</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pretty</td>
<td align="center">使查询的数据美化后返回</td>
<td align="center">作为参数放在末端，eg: /&lt;_index&gt;/&lt;_type&gt;/&lt;_id&gt;?pretty</td>
</tr>
<tr>
<td align="center">_source</td>
<td align="center">指定只查询的具体字段</td>
<td align="center">作为参数放在末端，不指定具体字段的话，只返回source部分，没有文档元数据</td>
</tr>
<tr>
<td align="center">op_type</td>
<td align="center">限定操作方式</td>
<td align="center">参数值：created</td>
</tr>
<tr>
<td align="center">_create</td>
<td align="center">请求时指定成必须创建新文档，防止进行update操作。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">version</td>
<td align="center">指定版本号</td>
<td align="center">指定操作可用在新增、查询、更新操作中</td>
</tr>
<tr>
<td align="center">retry_on_conflict</td>
<td align="center">设置产生冲突时重试次数</td>
<td align="center">一般用于对于先后顺序<strong>不重要</strong>的更新操作。</td>
</tr>
<tr>
<td align="center">last-write-wins</td>
<td align="center">保留最后更新</td>
<td align="center">用于对于先后顺序<strong>重要</strong>的更新操作。</td>
</tr>
<tr>
<td align="center">timeout</td>
<td align="center">指定相应时间（ms）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">_all</td>
<td align="center">表示所有</td>
<td align="center">具体指”所有什么“要看放在哪个字段</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">含义</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">doc</td>
<td align="center">局部文档参数</td>
<td align="center">用于更新操作时，合并到现有文档中对象合并在一起，存在的标量字段被覆盖，新字段被添加</td>
</tr>
<tr>
<td align="center">upset</td>
<td align="center">不存在时创建字段的参数</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">docs</td>
<td align="center"><code>mget</code> API的一个参数数组</td>
<td align="center">数组中存放多个文档内容</td>
</tr>
<tr>
<td align="center">ids</td>
<td align="center"><code>mget</code> API的一个参数数组</td>
<td align="center">数组中存放多个id值</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CODING</category>
        <category>数据库</category>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>一、ES基础、安装、使用</title>
    <url>/2020/05/27/CODING/%E6%95%B0%E6%8D%AE%E5%BA%93/ElasticSearch/%E4%B8%80%E3%80%81ES%E5%9F%BA%E7%A1%80%E3%80%81%E5%AE%89%E8%A3%85%E3%80%81%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>入职公司后，需要从零开始接触ES（ElasticSearch）这一数据库，所以将一路上排坑和记录写在这片入门文章上。以便后期随时查阅</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#shi-me-shi-elasticsearch">什么是ElasticSearch？</a></li>
<li><a href="#an-zhuang-pei-zhi-es">安装 配置 ES</a><ul>
<li><a href="#shou-dong-ben-ji-mac-an-zhuang">手动本机（Mac）安装</a></li>
<li><a href="#docker-an-zhuang">docker安装</a></li>
</ul>
</li>
<li><a href="#an-zhuang-pei-zhi-kibana">安装 配置 KIBANA</a><ul>
<li><a href="#zhi-jie-ben-ji-mac-an-zhuang">直接本机（mac）安装</a></li>
<li><a href="#docker-an-zhuang-kibana">docker安装kibana</a></li>
</ul>
</li>
<li><a href="#pei-zhi-es-ji-qun-he-kibana">配置ES集群和KIBANA</a></li>
<li><a href="#linux-xia-de-wan-zheng-an-zhuang-pei-zhi-guo-cheng-ji-lu">Linux下的完整安装配置过程记录</a></li>
<li><a href="#ji-ben-ming-ci">基本名词</a><ul>
<li><a href="#es-he-rdbms-de-bi-jiao">ES 和 RDBMS 的比较</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="shi-me-shi-elasticsearch">什么是ElasticSearch？</span><a href="#shi-me-shi-elasticsearch" class="header-anchor"></a></h1><p>简单的摘抄来一些概念记录，熟练之后再补充自己对ES的心得感悟总结。</p>
<p>百度定义：</p>
<blockquote>
<p>Elasticsearch 是一个分布式、高扩展、高实时的搜索与数据分析引擎。它能很方便的使大量数据具有搜索、分析和探索的能力。充分利用Elasticsearch的水平伸缩性，能使数据在生产环境变得更有价值。Elasticsearch 的实现原理主要分为以下几个步骤，首先用户将数据提交到Elasticsearch 数据库中，再通过分词控制器去将对应的语句分词，将其权重和分词结果一并存入数据，当用户搜索数据时候，再根据权重将结果排名，打分，再将返回结果呈现给用户。</p>
<p>Elasticsearch是与名为Logstash的数据收集和日志解析引擎以及名为Kibana的分析和可视化平台一起开发的。这三个产品被设计成一个集成解决方案，称为“Elastic Stack”（以前称为“ELK stack”）。</p>
<p>Elasticsearch可以用于搜索各种文档。它提供可扩展的搜索，具有接近实时的搜索，并支持多租户。”Elasticsearch是分布式的，这意味着索引可以被分成分片，每个分片可以有0个或多个副本。每个节点托管一个或多个分片，并充当协调器将操作委托给正确的分片。再平衡和路由是自动完成的。“相关数据通常存储在同一个索引中，该索引由一个或多个主分片和零个或多个复制分片组成。一旦创建了索引，就不能更改主分片的数量。</p>
<p>Elasticsearch使用Lucene，并试图通过JSON和Java API提供其所有特性。它支持facetting和percolating，如果新文档与注册查询匹配，这对于通知非常有用。另一个特性称为“网关”，处理索引的长期持久性；例如，在服务器崩溃的情况下，可以从网关恢复索引。Elasticsearch支持实时GET请求，适合作为NoSQL数据存储，但缺少分布式事务。</p>
</blockquote>
<p>wiki百科定义：</p>
<blockquote>
<p>Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。</p>
<p>但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。</p>
<p>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的<code>RESTful API</code>来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p>
<p>不过，Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它：</p>
<ul>
<li>分布式的实时文件存储，每个字段都被索引并可被搜索</li>
<li>分布式的实时分析搜索引擎</li>
<li>可以扩展到上百台服务器，处理PB级结构化或非结构化数据</li>
</ul>
<p>而且，所有的这些功能被集成到一个服务里面，你的应用可以通过简单的<code>RESTful API</code>、各种语言的客户端甚至命令行与之交互。</p>
<p>上手Elasticsearch非常容易。它提供了许多合理的缺省值，并对初学者隐藏了复杂的搜索引擎理论。它开箱即用（安装即可使用），只需很少的学习既可在生产环境中使用。</p>
</blockquote>
<h1><span id="an-zhuang-pei-zhi-es">安装 配置 ES</span><a href="#an-zhuang-pei-zhi-es" class="header-anchor"></a></h1><h2><span id="shou-dong-ben-ji-mac-an-zhuang">手动本机（Mac）安装</span><a href="#shou-dong-ben-ji-mac-an-zhuang" class="header-anchor"></a></h2><p>首先下载对应的包：</p>
<p><a href="https://elasticsearch.cn/download/" target="_blank" rel="noopener">elastic中文社区下载</a></p>
<p>解压后放入某一路径即可（最好路径全英文）</p>
<p>启动ES: 命令行进入“&lt;安装目录&gt;/&lt;解压得到的文件夹&gt;/bin”后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">elasticsearch -d</span></span><br></pre></td></tr></table></figure>

<p>停止ES:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看ES进程号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lsof -i:ES的端口号</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据进程号杀死进程，结束</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">kill</span> -9 进程号</span></span><br></pre></td></tr></table></figure>

<h2><span id="docker-an-zhuang">docker安装</span><a href="#docker-an-zhuang" class="header-anchor"></a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --name elasticsearch -d -p 9200:9200 -p 9300:9300 -p 5601:5601 elasticsearch</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>官方的镜像的网络设置是允许外部访问的即network.host=0.0.0.0</p>
<p>如果要制定es配置可用通过-E{param=value}指定，或者通过-v “$PWD/config”:/usr/share/elasticsearch/config 映射配置文件地址</p>
<p>-p 5601:5601 是kibana的端口地址 (我这里kibana的container共用elasticsearch的网络，所以这样设置)</p>
</blockquote>
<h1><span id="an-zhuang-pei-zhi-kibana">安装 配置 KIBANA</span><a href="#an-zhuang-pei-zhi-kibana" class="header-anchor"></a></h1><h2><span id="zhi-jie-ben-ji-mac-an-zhuang">直接本机（mac）安装</span><a href="#zhi-jie-ben-ji-mac-an-zhuang" class="header-anchor"></a></h2><ol>
<li><p>下载对应版本的kibana包：<a href="https://elasticsearch.cn/download/" target="_blank" rel="noopener">elastic中文社区下载</a></p>
</li>
<li><p>无需安装，解压后放入elasticsearch的同级目录下</p>
</li>
</ol>
<p>开启kibana</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入kubana安装目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./bin/kibana &amp;</span></span><br></pre></td></tr></table></figure>

<p>关闭kibana: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看ES进程号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lsof -i:kibana的端口号</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据进程号杀死进程，结束</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">kill</span> -9 进程号</span></span><br></pre></td></tr></table></figure>

<h2><span id="docker-an-zhuang-kibana">docker安装kibana</span><a href="#docker-an-zhuang-kibana" class="header-anchor"></a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it -d -e ELASTICSEARCH_URL=http://127.0.0.1:9200 --name kibana --network=container:elasticsearch kibana</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>–network 指定容器共享elasticsearch容器的网络栈 (使用了–network 就不能使用-p 来暴露端口)</p>
</blockquote>
<h1><span id="pei-zhi-es-ji-qun-he-kibana">配置ES集群和KIBANA</span><a href="#pei-zhi-es-ji-qun-he-kibana" class="header-anchor"></a></h1><p>ES集群配置：</p>
<ul>
<li>首先将elasticsearch的包复制多份，创建多节点的环境</li>
<li>打开每一个节点下的配置文件（&lt;es包&gt;/config/elastsearch.yml），进行如下修改：</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 集群名称（所有节点相同）</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">cluster1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点名称，每个节点分别编号（node-1, node-2, node-3等）</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-1</span></span><br><span class="line"><span class="comment"># 允许该节点成为主节点</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 允许该节点存储数据</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储数据的路径设置</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/Users/tornado4651/CS/super/es/elk/elasticsear</span></span><br><span class="line"><span class="comment"># 存储日志的路径设置</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/Users/tornado4651/CS/super/es/elk/elasticsearch/logs1</span></span><br><span class="line"><span class="comment"># 内存锁设置为true来锁住内存。因为内存交换到磁盘对服务器性能来说是致命的，当jvm开始swapping时es的效率会降低，所以要保证它不swap</span></span><br><span class="line"><span class="attr">bootstrap.memory_lock:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定ip地址</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment"># 设置当前节点的对外端口号，每个节点不同（9201、9202、9203....）</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9201</span></span><br><span class="line"><span class="comment"># 设置集群内部连接端口号，每个节点不同（9301、9302、9303....）</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9301</span></span><br><span class="line"><span class="comment"># 这提供了自动集群体验，而无需进行任何配置。数组设置或逗号分隔的设置。每个值的形式应该是host:port或host</span></span><br><span class="line"><span class="comment">#（如果没有设置，port默认设置会transport.profiles.default.port 回落到transport.tcp.port）。</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> <span class="string">["192.168.20.109:9301",</span> <span class="string">"192.168.20.109:9302"</span><span class="string">,</span> <span class="string">"192.168.20.109:9303"</span><span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小节点数设置，如果没有这种设置,遭受网络故障的集群就有可能将集群分成两个独立的集群，这将导致数据丢失</span></span><br><span class="line"><span class="attr">discovery.zen.minimum_master_nodes:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>KIBANA配置：</p>
<ul>
<li>打开KIBANA的配置文件：【&lt;kibana安装目录&gt;/config/kibana.yml】,进行如下配置</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置kibana的端口号</span></span><br><span class="line"><span class="attr">server.port:</span> <span class="number">5601</span></span><br><span class="line"><span class="comment"># 绑定ip地址</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">"0.0.0.0"</span></span><br><span class="line"><span class="comment"># 设置监控es集群的某一个节点url</span></span><br><span class="line"><span class="attr">elasticsearch.url:</span> <span class="string">"http://127.0.0.1:9201"</span></span><br><span class="line"><span class="comment"># 设置kibana在集群中的存储索引</span></span><br><span class="line"><span class="attr">kibana.index:</span> <span class="string">".kibana"</span></span><br><span class="line"><span class="comment"># 关闭xpack安全，否则会有安全阻止，关于es的xpack是什么，我会单独再写一篇记录</span></span><br><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h1><span id="linux-xia-de-wan-zheng-an-zhuang-pei-zhi-guo-cheng-ji-lu">Linux下的完整安装配置过程记录</span><a href="#linux-xia-de-wan-zheng-an-zhuang-pei-zhi-guo-cheng-ji-lu" class="header-anchor"></a></h1><p>搭建es</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Elasticsearch安装</span><br><span class="line"><span class="meta">#</span><span class="bash">解压文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash">tar -zxvf elasticsearch-6.3.2.tar.gz</span></span><br><span class="line"><span class="meta">#</span><span class="bash">复制文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash">cp -r elasticsearch-6.3.2 elasticsearch-1</span></span><br><span class="line"><span class="meta">$</span><span class="bash">cp -r elasticsearch-6.3.2 elasticsearch-2</span></span><br><span class="line"><span class="meta">$</span><span class="bash">cp -r elasticsearch-6.3.2 elasticsearch-3</span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建数据存放路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash">应将设置配置为在Elasticsearch主目录之外定位数据目录，以便在不删除数据的情况下删除主目录！</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mkdir /super/es/elk/elasticsearch/data1</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mkdir /super/es/elk/elasticsearch/data2</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mkdir /super/es/elk/elasticsearch/data3</span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建日志存放路径</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mkdir /super/es/elk/elasticsearch/logs1</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mkdir /super/es/elk/elasticsearch/logs2</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mkdir /super/es/elk/elasticsearch/logs3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">修改elasticsearch配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash">vim /super/es/elasticsearch-1/config/elasticsearch.yml </span></span><br><span class="line"><span class="meta">$</span><span class="bash">vim /super/es/elasticsearch-2/config/elasticsearch.yml </span></span><br><span class="line"><span class="meta">$</span><span class="bash">vim /super/es/elasticsearch-3/config/elasticsearch.yml</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将配置文件以下内容进行修改</span></span><br><span class="line"><span class="meta">#</span><span class="bash">集群的名称</span></span><br><span class="line">cluster.name: es6-1</span><br><span class="line"><span class="meta">#</span><span class="bash">节点名称,其余两个节点分别为node-2 和node-3</span></span><br><span class="line">node.name: node-1</span><br><span class="line"><span class="meta">#</span><span class="bash">指定该节点是否有资格被选举成为master节点，默认是<span class="literal">true</span>，es是默认集群中的第一台机器为master，如果这台机挂了就会重新选举master</span></span><br><span class="line">node.master: true</span><br><span class="line"><span class="meta">#</span><span class="bash">允许该节点存储数据(默认开启)</span></span><br><span class="line">node.data: true</span><br><span class="line"><span class="meta">#</span><span class="bash">索引数据的存储路径</span></span><br><span class="line">path.data: /super/es/elk/elasticsearch/data1 </span><br><span class="line"><span class="meta">#</span><span class="bash">日志文件的存储路径</span></span><br><span class="line">path.logs: /super/es/elk/elasticsearch/logs1 </span><br><span class="line"><span class="meta">#</span><span class="bash">设置为<span class="literal">true</span>来锁住内存。因为内存交换到磁盘对服务器性能来说是致命的，当jvm开始swapping时es的效率会降低，所以要保证它不swap</span></span><br><span class="line">bootstrap.memory_lock: true</span><br><span class="line"><span class="meta">#</span><span class="bash">绑定的ip地址</span></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置对外服务的http端口，其余两个节点分别为9202 和9203</span></span><br><span class="line">http.port: 9201</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置节点间交互的tcp端口, 其余两个节点分别为9302 和9303</span></span><br><span class="line">transport.tcp.port: 9301</span><br><span class="line"><span class="meta">#</span><span class="bash">Elasticsearch将绑定到可用的环回地址，并将扫描端口9300到9305以尝试连接到运行在同一台服务器上的其他节点。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">这提供了自动集群体验，而无需进行任何配置。数组设置或逗号分隔的设置。每个值的形式应该是host:port或host</span></span><br><span class="line"><span class="meta">#</span><span class="bash">（如果没有设置，port默认设置会transport.profiles.default.port 回落到transport.tcp.port）。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">请注意，IPv6主机必须放在括号内。默认为127.0.0.1, [::1]</span></span><br><span class="line">discovery.zen.ping.unicast.hosts: ["localhost:9301", "localhost:9302", "localhost:9303"]</span><br><span class="line"><span class="meta">#</span><span class="bash">如果没有这种设置,遭受网络故障的集群就有可能将集群分成两个独立的集群 - 分裂的大脑 - 这将导致数据丢失</span></span><br><span class="line">discovery.zen.minimum_master_nodes: 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 调整jvm内存</span></span><br><span class="line"><span class="meta">$</span><span class="bash">vim /super/es/elasticsearch-1/config /jvm.options</span></span><br><span class="line"><span class="meta">$</span><span class="bash">vim /super/es/elasticsearch-2/config /jvm.options</span></span><br><span class="line"><span class="meta">$</span><span class="bash">vim /super/es/elasticsearch-3/config /jvm.options </span></span><br><span class="line"><span class="meta">#</span><span class="bash">默认是1g官方建议对jvm进行一些修改，不然很容易出现OOM,参考官网改参数配置最好不要超过内存的50% </span></span><br><span class="line">-Xms1g</span><br><span class="line">-Xmx1g</span><br></pre></td></tr></table></figure>

<p>用户设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">建立es用户并授权</span></span><br><span class="line"><span class="meta">#</span><span class="bash">添加用户</span></span><br><span class="line"><span class="meta">$</span><span class="bash">useradd es</span></span><br><span class="line"><span class="meta">#</span><span class="bash">赋予文件夹权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash">chown -R  es:es  /super/es</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">root用户 修改配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash">vim /etc/security/limits.conf</span></span><br><span class="line">*	soft	nofile	65536</span><br><span class="line">*	hard	nofile	65536</span><br><span class="line">*   soft    nproc   4096</span><br><span class="line">*   hard    nproc   4096</span><br><span class="line">*   soft    memlock unlimited </span><br><span class="line">*   hard    memlock unlimited</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">vim /etc/sysctl.conf</span></span><br><span class="line">vm.max_map_count=655360</span><br><span class="line">fs.file-max=655360</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">vim /etc/security/limits.d/*-nproc.conf</span></span><br><span class="line">*          soft    nproc     4096</span><br><span class="line">root       soft    nproc     unlimited</span><br><span class="line"><span class="meta">#</span><span class="bash">启动</span></span><br><span class="line"><span class="meta">#</span><span class="bash">注意：请使用es用户启动 su – es</span></span><br><span class="line"><span class="meta">$</span><span class="bash">/super/es/elasticsearch6-1/bin/elasticsearch -d</span></span><br><span class="line"><span class="meta">$</span><span class="bash">/super/es/elasticsearch6-2/bin/elasticsearch -d</span></span><br><span class="line"><span class="meta">$</span><span class="bash">/super/es/elasticsearch6-3/bin/elasticsearch –d</span></span><br><span class="line"><span class="meta">#</span><span class="bash">验证</span></span><br><span class="line"><span class="meta">#</span><span class="bash">http://10.10.1.8:9201/_cat/nodes?v</span></span><br></pre></td></tr></table></figure>

<p>搭建kibana</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">解压</span></span><br><span class="line"><span class="meta">$</span><span class="bash">tar -zxvf kibana-6.3.2-linux-x86_64.tar.gz  -C kibana</span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash">vim /super/es/kibana/config/kibana.yml</span></span><br><span class="line"><span class="meta">#</span><span class="bash">端口</span></span><br><span class="line"><span class="meta">$</span><span class="bash">server.port: 5601</span></span><br><span class="line"><span class="meta">#</span><span class="bash">主机</span></span><br><span class="line"><span class="meta">$</span><span class="bash">server.host: <span class="string">"10.10.1.8"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">es的地址</span></span><br><span class="line"><span class="meta">$</span><span class="bash">elasticsearch.url: <span class="string">"http://localhost:9201"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">kibana在es中的索引</span></span><br><span class="line"><span class="meta">$</span><span class="bash">kibana.index: <span class="string">".kibana"</span></span></span><br><span class="line">启动</span><br><span class="line"><span class="meta">$</span><span class="bash">kibana &amp;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">验证</span></span><br><span class="line"><span class="meta">#</span><span class="bash">http://10.10.1.8:5601</span></span><br></pre></td></tr></table></figure>

<h1><span id="ji-ben-ming-ci">基本名词</span><a href="#ji-ben-ming-ci" class="header-anchor"></a></h1><ul>
<li><p><strong>节点</strong> - 它指的是Elasticsearch的单个正在运行的实例。单个物理和虚拟服务器容纳多个节点，这取决于其物理资源的能力，如RAM，存储和处理能力。</p>
</li>
<li><p><strong>集群</strong> - 它是一个或多个节点的集合。 集群为整个数据提供跨所有节点的集合索引和搜索功能。</p>
</li>
<li><p><strong>索引</strong> - 它是不同类型的文档和文档属性的集合。索引还使用分片的概念来提高性能。 例如，一组文档包含社交网络应用的数据。</p>
</li>
<li><p><strong>类型/映射</strong> - 它是共享同一索引中存在的一组公共字段的文档的集合。 例如，索引包含社交网络应用的数据，然后它可以存在用于用户简档数据的特定类型，另一类型可用于消息的数据，以及另一类型可用于评论的数据。</p>
</li>
<li><p><strong>文档</strong> - 它是以JSON格式定义的特定方式的字段集合。每个文档都属于一个类型并驻留在索引中。每个文档都与唯一标识符(称为UID)相关联。</p>
</li>
<li><p><strong>碎片</strong> - 索引被水平细分为碎片。这意味着每个碎片包含文档的所有属性，但包含的数量比索引少。水平分隔使碎片成为一个独立的节点，可以存储在任何节点中。主碎片是索引的原始水平部分，然后这些主碎片被复制到副本碎片中。</p>
</li>
<li><p><strong>副本</strong> - Elasticsearch允许用户创建其索引和分片的副本。 复制不仅有助于在故障情况下增加数据的可用性，而且还通过在这些副本中执行并行搜索操作来提高搜索的性能。</p>
</li>
</ul>
<h2><span id="es-he-rdbms-de-bi-jiao">ES 和 RDBMS 的比较</span><a href="#es-he-rdbms-de-bi-jiao" class="header-anchor"></a></h2><table>
<thead>
<tr>
<th align="center">ES</th>
<th align="center">RDBMS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">索引</td>
<td align="center">库</td>
</tr>
<tr>
<td align="center">映射</td>
<td align="center">表</td>
</tr>
<tr>
<td align="center">文档</td>
<td align="center">行</td>
</tr>
<tr>
<td align="center">字段</td>
<td align="center">列</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CODING</category>
        <category>数据库</category>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Redis</title>
    <url>/2020/01/01/CODING/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E5%88%9D%E8%AF%86Redis/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记记录了Redis的产生需求，相关数据库知识，上手操作，以及用法记录</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#nosql-he-sql-de-dui-bi">NoSQL和SQL的对比</a></li>
<li><a href="#redis-de-an-zhuang-linux-ban">Redis的安装（Linux版）：</a></li>
<li><a href="#redis-ji-ben-shi-yong-ming-ling">Redis基本使用命令</a></li>
<li><a href="#redis-zai-xian-cha-xun">redis在线查询</a></li>
<li><a href="#redis-de-shu-ju-lei-xing-5-1">Redis的数据类型（5+1）</a><ul>
<li><a href="#shu-ju-lei-xing-gai-gua">数据类型概括</a></li>
<li><a href="#key-cao-zuo">KEY操作</a></li>
<li><a href="#string-xing">String型</a></li>
<li><a href="#list-xing">List型</a></li>
<li><a href="#set-xing">Set型</a></li>
<li><a href="#zset-xing">Zset型</a></li>
<li><a href="#hash-xing">Hash型</a></li>
</ul>
</li>
<li><a href="#qi-ta">其他</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="nosql-he-sql-de-dui-bi">NoSQL和SQL的对比</span><a href="#nosql-he-sql-de-dui-bi" class="header-anchor"></a></h1><p>NoSQL是指Not only SQL，是对SQL型数据库在大数据时代表现不足的一种性能扩展。</p>
<p>SQL型数据库中（以MySQL，Oracal为代表）的不足及演变过程：</p>
<p>单机型：</p>
<p>缓存结构：</p>
<p>主从结构：</p>
<p>集群结构：</p>
<p>NoSQL的特点：</p>
<p>NoSQL型的两大特点：CAP vs. ACID；BASE</p>
<p>NoSQL的分布式集群概述</p>
<h1><span id="redis-de-an-zhuang-linux-ban">Redis的安装（Linux版）：</span><a href="#redis-de-an-zhuang-linux-ban" class="header-anchor"></a></h1><p>下载地址：</p>
<ol>
<li><a href="https://redis.io/" target="_blank" rel="noopener">官网</a></li>
<li><a href="http://www.redis.cn/" target="_blank" rel="noopener">中文网址</a></li>
<li><a href="https://code.google.com/archive/p/redis/downloads" target="_blank" rel="noopener">Google Code上的历史版本</a></li>
<li><a href="https://github.com/dmajkic/redis/downloads" target="_blank" rel="noopener">github上的windows</a></li>
</ol>
<p>下载后将压缩包解压并移动到某一个安装目录下就可以，之后进入解压目录，使用make命令编译安装redis。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -xvzf redis-stable.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv redis-stable ~/CS/Redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-stable</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure>

<p>使用make命令安装Redis，如果环境正确，提示安装成功</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcexhe9nv1j30i60ilabh.jpg" alt="安装成功"></p>
<p>如果未成功，是由于redis使用C++所编写，所以编译时要求提供gcc，失败原因中提示没有安装gcc：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcexbl314ij31hc0q4gqa.jpg" alt="安装错误提醒"></p>
<p>这时需要安装gcc，我用的是centos 7从网络上直接下载，不同版本的安装教程另寻百度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum install gcc</span></span><br></pre></td></tr></table></figure>

<p>gcc安装成功后不要直接使用make命令安装，在redis解压目录下先清空上次安装一半的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make distclean</span></span><br></pre></td></tr></table></figure>

<p>最后再进行make命令，便会提示成功安装，并建议使用”make test“命令测试。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure>

<p>查看/usr/local/bin中是否生成了redis系列的命令，如果没有（我的mac 和linux 上没有生成），只好自己手动将redis路径配置到环境变量中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">vim ~/.bash_profile</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入下面的两句，将redis目录加入到环境变量中</span></span><br><span class="line">export REDIS_HOME=【redis包的路径】</span><br><span class="line">export PATH=$&#123;REDIS_HOME&#125;/src:$PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> .bash_profile</span></span><br></pre></td></tr></table></figure>

<h1><span id="redis-ji-ben-shi-yong-ming-ling">Redis基本使用命令</span><a href="#redis-ji-ben-shi-yong-ming-ling" class="header-anchor"></a></h1><p>由于redis服务每次启动都会在当前目录中产生和需要一些附属文件(如redis.conf, rdb, aof, sentinel.conf等)，所以创建一个目录作为redis的运行目录，将存放各类redis运行的配置，然后在该目录下使用具体的redis命令。</p>
<p>命令解释：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动Redis服务，后跟启动配置文件路径</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-server /path/to/redis.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash">不借助配置文件在后台启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-server &amp;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动客户端连接redis服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli [-h &#123;host&#125;] [-p &#123;port&#125;] [-a &#123;password&#125;] [<span class="built_in">command</span>]</span></span><br><span class="line"><span class="meta">#</span><span class="bash">关闭redies服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli SHUTDOWN</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 批处理测试性能,模拟 N 个客户端同时发出 M 个请求</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-benchmark [-h &lt;host&gt;] [-p &lt;port&gt;] [-c &lt;clients&gt;] [-n &lt;requests]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修复损坏的rdb或aof文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-check-rdb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-check-aof</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启哨兵监听，后跟具体的哨兵配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-sentinel ./sentinel.conf</span></span><br></pre></td></tr></table></figure>

<p>开启服务后界面如下（后台运行时不现实）：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcha7n2hlnj31nm0roqb8.jpg" alt="redis启动"></p>
<p>使用redis客户端连接服务：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gchb9slgg3j316m0jygvo.jpg" alt="客户端"></p>
<p>基本的redis操作命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试连通性</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ping</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换数据库，默认开启16个</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SELECT 数据库索引</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空所有数据库：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> FlUSHALL</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空当前数据库：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> FLUSHDB</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭数据库服务</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SHUTDOWN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出客户端</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> EXIT</span></span><br></pre></td></tr></table></figure>

<p>Redis设置密码：默认情况下所有库的密码都是统一的，一起连接或都不连接。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过命令行配置和获取密码，也可以在conf配置文件中配置</span></span><br><span class="line">redis 127.0.0.1:6379[1]&gt; config set requirepass my_redis</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379[1]&gt; config get requirepass</span><br><span class="line">1) "requirepass"</span><br><span class="line">2) "my_redis"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">连接后，在执行操作前确认密码：</span></span><br><span class="line">redis 127.0.0.1:6379&gt; auth myRedis</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) "requirepass"</span><br><span class="line">2) "myRedis"</span><br></pre></td></tr></table></figure>





<h1><span id="redis-zai-xian-cha-xun">redis在线查询</span><a href="#redis-zai-xian-cha-xun" class="header-anchor"></a></h1><p><a href="http://redisdoc.com/" target="_blank" rel="noopener">命令查询文档1</a></p>
<p><a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">命令查询2</a></p>
<h1><span id="redis-de-shu-ju-lei-xing-5-1">Redis的数据类型（5+1）</span><a href="#redis-de-shu-ju-lei-xing-5-1" class="header-anchor"></a></h1><h2><span id="shu-ju-lei-xing-gai-gua">数据类型概括</span><a href="#shu-ju-lei-xing-gai-gua" class="header-anchor"></a></h2><h2><span id="key-cao-zuo">KEY操作</span><a href="#key-cao-zuo" class="header-anchor"></a></h2><p>常用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置、获取、删除</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SET</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> DEL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">创建时自带生命时间</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SETEX 键名 生存时间（秒）值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">不存在该键再创建，避免覆盖值</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SETNX 键名 值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">多个创建、多条获取、多条判断创建（其中不能包含已经存在的键）</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> MSET 键1名 值1 键2名 值2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> MGET 键1名 键2名</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> MSETNX </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有键</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> keys *</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看以A开头的键</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> keys A?</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看key是否存在</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> EXISTS 键名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除key</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> DEL 键名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">转移键值对到别的库中</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> MOVE 键名 库名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">为给定的key设置生命周期时间（秒）</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> EXPIRE 键名 生命时间</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看key还有多少秒过期，过期后不再存在，永久删除，-1永久存在，-2已过期</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> TTL 键名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看key对应的值类型</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> TYPE 键名</span></span><br></pre></td></tr></table></figure>



<h2><span id="string-xing">String型</span><a href="#string-xing" class="header-anchor"></a></h2><p>常用操作命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">追加字符串、获取字符串长度</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> APPEND</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> STRLEN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">自增、自减、自定义自增、自定义自减</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> INCR 键名</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> DECR 键名</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> INCRBY 键名 长度</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> DECRBY 键名 长度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将字符串中某一段取出、将字符串中某一段覆盖设置为</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GETRANGE start end</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SETRANGE 键名 起始下标 覆盖的值</span></span><br></pre></td></tr></table></figure>



<h2><span id="list-xing">List型</span><a href="#list-xing" class="header-anchor"></a></h2><p>Redis链表可以看作一条左面为头，右面为尾的，可以双向出入的 队列。</p>
<p>注：链表中的值变空时，对应的键也将消失。链表左右插值效率高，中间插值效率很低</p>
<p>常用操作有：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 左右入队操作</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> LPUSH key value [value ...]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> RPUSH key value [value ...]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 左右出队操作</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> LPOP key</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> RPOP key</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看列表（0到-1表示查看全部）</span></span><br><span class="line">LRANGE key start stop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据索引取值</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> LINDEX key index</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取长度</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> LLEN key</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除链表中的count个value值</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> LREM key count value</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将原本list中的某一段 截取成 指定范围的新list</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">LTRIM key start stop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从一个链表中右出队一个数左进队到另一个链表中</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">RPOPLPUSH <span class="built_in">source</span> destination</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将链表上某一个索引处的值更换为新值</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> LSET key index value</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在链表中的指定值（pivot）前或后插入一个值(value)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> LINSERT key BEFORE|AFTER pivot value</span></span><br></pre></td></tr></table></figure>

<h2><span id="set-xing">Set型</span><a href="#set-xing" class="header-anchor"></a></h2><p>Redis的集合与链表相似，只是链表可以存入重复值，集合不可以重复。常用操作有：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SADD key member [member ...]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集合中的所有值</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SMEMBERS key</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断某个值是否在集合内</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SISMEMBER key member</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取集合中元素的个数</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SCAD key</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从集合中删除值</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SREM key member [member ...]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从集合中随意出队n个值</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SPOP key [count]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从集合中随意查看n个值（不从集合中移除）</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SRANDMEMBER key [count]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将一个集合中的值移动到另一个集合</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SMOVE <span class="built_in">source</span> destination member</span></span><br></pre></td></tr></table></figure>

<p>集合关联的操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以第一个集合为主，多个集合取“差集”</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SDIFF key [key ...]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 多个集合取“交集”</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SINTER key [key ...]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 多个集合取“并集”</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> SUNION key [key ...]</span></span><br></pre></td></tr></table></figure>

<h2><span id="zset-xing">Zset型</span><a href="#zset-xing" class="header-anchor"></a></h2><p>Redis中的z集合就是在集合的基础上，每一个值前面添加一个分数。即：value=“score + value”，常用方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按索引显示，0 -1表示全部查看，可以只查看值，也可以连同score一起查看</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZRANGE key start stop [WITHSCORES]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZREVRANGE key start stop [WITHSCORES] ======》反向显示</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据值的大小排序显示，注意“(”可以表示不包含的意思，也可以在最后限制从的n个截取m个</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]  ======》反向显示</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除z集合中的值，此处不加相连的score</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZREM key member [member ...]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看value个数</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZCARD key</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计一定范围分数内的value个数</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZCOUNT key min max</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看z集合中某一个值的排名，相当于查看索引</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZRANK key member</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看zset中某一个值对应的分数</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZSCORE key member</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ZREVRANK key member  ======》反向显示</span></span><br></pre></td></tr></table></figure>

<h2><span id="hash-xing">Hash型</span><a href="#hash-xing" class="header-anchor"></a></h2><p>Redis中的Hash型相当于java中的map&lt;String, Object&gt;类型，仍然保持键值对（K-V）的结构，只不过每一个V必须指定成小键值对（field-value）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 基本操作：插入，获取，多项插入，多项获取，不重复插入，获取所有值，删除值</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HSET key field value</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HGET key field</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HMSET key field value [field value ...]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HMGET key field [field ...]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HSETNX key field value</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HGETALL key</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HDEL key field [field ...]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看<span class="built_in">hash</span>的值总体</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  HLEN key</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看某个值是否存在</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HEXISTS key field</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 仅查看一个<span class="built_in">hash</span>中的属性名或只查看属性值</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HKEYS key</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> HVALS key</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自增（整数自增和浮点数自增）</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  HINCRBY key field increment</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  HINCRBYFLOAT key field increment</span></span><br></pre></td></tr></table></figure>

<h1><span id="qi-ta">其他</span><a href="#qi-ta" class="header-anchor"></a></h1><p>Redis的其他方面：持久化、主从复制，Jedis的使用等，请查看该目录下其他文章</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】 MacOS 下安装多个版本的 JDK 并统一管理</title>
    <url>/2020/01/01/CODING/%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E3%80%90%E8%BD%AC%E3%80%91%20MacOS%20%20%E4%B8%8B%E5%AE%89%E8%A3%85%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84-JDK-%E5%B9%B6%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>在网上看到一篇很好的管理mac上java版本的文章，遂拷贝。<br><a href="https://blog.csdn.net/aigestudio/article/details/99641818" target="_blank" rel="noopener">原文链接</a></p>
</blockquote>
<div class="toc">

<!-- toc -->



<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<p>现在的 MacOS 都不自带 JDK 了，如果你在未安装 JDK 的 MacOS 中执行 Java 命令会出现如下提示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AigeStudio@aige$ java -version`</span><br><span class="line">No Java runtime present, requesting install.`</span><br></pre></td></tr></table></figure>

<p>然后 MacOS 会提示你 JDK 未安装：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gclt2cntzvj30es07bwg4.jpg" alt="JDK 未安装提示 —— From AigeStudio"></p>
<p>点击更多信息的话就会去到 Oracle 的 JDK 下载页让你下载安装，在稍微早一点的 MacOS 版本中点击更多信息会让你跳转至 Apple 的 JDK 6 下载页，不管怎么个方式，MacOS 就是要你自己去安装 JDK，自行下载安装包安装 JDK 虽然可行，但是 JDK 的包并非是 app 而是 pkg 的形式，管理、升级和卸载起来都极不方便，因此这里爱哥是很不推荐下载安装包安装 JDK 的，相较而言，使用 brew 提供自动安装和卸载的功能，管理起来也比自行安装方便轻松。如果你还没用过 brew 的话可以参阅 MacOS 安装 brew 并配置 cask。</p>
<p>使用 brew 安装 JDK 也非常简单，如果你只是安装最新的 JDK，那么直接执行下述命令即可：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AigeStudio@aige$ brew cask install java</span><br></pre></td></tr></table></figure>

<p>当然很多时候我们开发环境并不一定只局限于最新版的 JDK，还需要一些低版本的 JDK，如果使用 brew 安装其他版本的 JDK 还需要使用 “homebrew-cask-versions”，该命令行工具用作于安装应用的历史版本，如果你未曾使用过它那么则需要先使用下述命令配置：</p>
<p>当然很多时候我们开发环境并不一定只局限于最新版的 JDK，还需要一些低版本的 JDK，如果使用 brew 安装其他版本的 JDK 还需要使用 “homebrew-cask-versions”，该命令行工具用作于安装应用的历史版本，如果你未曾使用过它那么则需要先使用下述命令配置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AigeStudio@aige$ brew tap caskroom/versions</span><br></pre></td></tr></table></figure>

<p>然后执行 brew 的 search 命令看看有哪些 JDK 版本可供安装：</p>
<p>然后执行 brew 的 search 命令看看有哪些 JDK 版本可供安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AigeStudio@aige$ brew search java</span><br></pre></td></tr></table></figure>

<p>这里爱哥已经安装了 JDK 的最新版 12 以及 8 和 6，可以看到执行搜索命令后会出现已安装的状态标识（该功能实现参阅 巧用 iTerm2 &amp; zsh &amp; oh-my-zsh 打造炫酷的 MacOS 终端环境）系列文章：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gclt4krl4kj30ll0eagpj.jpg" alt="brew 显示已安装的 JDK 版本 —— From AigeStudio"></p>
<p>安装完所有你需要的 JDK 版本后执行下述命令就可以查看所有已安装的 JDK 版本路径地址：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AigeStudio@aige$ /usr/libexec/java_home -V</span><br></pre></td></tr></table></figure>


<p>比如这里爱哥安装了三个版本的 JDK （其中 JDK6 区分了 32bit 和 64bit 版本）：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gclt4decckj30rx0dw795.jpg" alt="本机显示已安装的 JDK 版本 —— From AigeStudio"></p>
<p>得到每个不同的 JDK 路径后我们就可以着手在这些 JDK 之间进行切换，在默认情况下 MacOS 中 Java 使用的是最新的 JDK 版本，可以通过命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AigeStudio@aige$ java -version</span><br></pre></td></tr></table></figure>


<p>查看，比如这里爱哥使用的最新版本就是 Open JDK 12：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gclt54k8upj30ll0ek0vo.jpg" alt="本机安装的 Open JDK 12 —— From AigeStudio"></p>
<p>我们可以通过设置系统的环境变量 JAVA_HOME 来在不同的 JDK 版本之间切换，最简单的方式就是通过 “export” 命令手动修改它的值：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AigeStudio@aige$ <span class="built_in">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home</span><br></pre></td></tr></table></figure>


<p>不过每次都输入这么一长串命令显得太过繁琐不够智能，我们可以在 shell 的配置文件（如果是 bash 则在 ~/.bash_profile；如果是 zsh，则在 ~/.zshrc ）中以指定 alias 的方式简化切换命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># JDK 6、JDK 8、JDK 12 的 export 命令</span></span><br><span class="line"><span class="built_in">export</span> JDK6_HOME=<span class="string">"/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home"</span></span><br><span class="line"><span class="built_in">export</span> JDK8_HOME=<span class="string">"/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home"</span></span><br><span class="line"><span class="built_in">export</span> JDK12_HOME=<span class="string">"/Library/Java/JavaVirtualMachines/openjdk-12.0.1.jdk/Contents/Home"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alias 命令链接到 export 命令</span></span><br><span class="line"><span class="built_in">alias</span> jdk6=<span class="string">"export JAVA_HOME=<span class="variable">$JDK6_HOME</span>"</span></span><br><span class="line"><span class="built_in">alias</span> jdk8=<span class="string">"export JAVA_HOME=<span class="variable">$JDK8_HOME</span>"</span></span><br><span class="line"><span class="built_in">alias</span> jdk12=<span class="string">"export JAVA_HOME=<span class="variable">$JDK12_HOME</span>"</span></span><br></pre></td></tr></table></figure>
<p>修改完 Shell 配置文件后保存并执行 source 命令实时更新配置文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AigeStudio@aige$ <span class="built_in">source</span> 配置文件路径</span><br><span class="line">（如果是bash则为~/.bash_profile；如果是zsh，则为~/.zshrc）</span><br></pre></td></tr></table></figure>


<p>最后我们就可以在 Shell 中使用 jdk6、jdk8、jdk12 命令切换不同的 JDK 版本了。</p>
<p>使用 export &amp; alias 的方式管理 JDK 固然没问题，但是当我们遇到复杂的场景时这种方式就显得不中用了。比如我们又很多不同的 Java 项目，而这些 Java 项目之间又互相依赖，并且这些 Java 项目都不是使用统一的 JDK 版本。如果我们使用 export &amp; alias 的方式切换 JDK，那么就有可能会导致一些项目可以编译成功一些不能。一种更好的思路是限制 export &amp; alias 的作用范围，即可以将其对 JDK 环境变量的设置作用于某个具体的项目，即作用到具体的目录。这个思路虽好，但是使用 export &amp; alias 的方式实现起来就比较困难。这里爱哥给大家推荐 JEnv 这个小工具，它可以帮我们更好地管理 &amp; 切换不同版本的 JDK。</p>
<p>JEnv 的安装很简单，你可以直接参考其官方网站。JEnv 目前支持 Linux 和 MacOS 两种操作系统，在 MacOS 下你可以直接使用 brew 进行安装（注：如果你还没用过 brew 的话可以参阅 MacOS 安装 brew 并配置 cask）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AigeStudio@aige$ brew install jenv</span><br></pre></td></tr></table></figure>


<p>然后配置 Shell 添加如下配置参数</p>
<p>然后配置 Shell 添加如下配置参数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果你是用的 bash 则执行下述命令</span></span><br><span class="line">AigeStudio@aige$ <span class="built_in">echo</span> <span class="string">'export PATH="$HOME/.jenv/bin:$PATH"'</span> &gt;&gt; ~/.bash_profile</span><br><span class="line">AigeStudio@aige$ <span class="built_in">echo</span> <span class="string">'eval "$(jenv init -)"'</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你是用的 zsh 则执行下述命令</span></span><br><span class="line">AigeStudio@aige$ <span class="built_in">echo</span> <span class="string">'export PATH="$HOME/.jenv/bin:$PATH"'</span> &gt;&gt; ~/.zshrc</span><br><span class="line">AigeStudio@aige$ <span class="built_in">echo</span> <span class="string">'eval "$(jenv init -)"'</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>


<p>最后我们使用上述使用到的 /usr/libexec/java_home -V 命令罗列出已经安装的 JDK 路径：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AigeStudio@aige$ /usr/libexec/java_home -V</span><br><span class="line">Matching Java Virtual Machines (4):</span><br><span class="line">    12.0.1, x86_64:	<span class="string">"OpenJDK 12.0.1"</span>	/Library/Java/JavaVirtualMachines/openjdk-12.0.1.jdk/Contents/Home</span><br><span class="line">    1.8.0_212, x86_64:	<span class="string">"AdoptOpenJDK 8"</span>	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home</span><br><span class="line">    1.6.0_65-b14-468, x86_64:	<span class="string">"Java SE 6"</span>	/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home</span><br><span class="line">    1.6.0_65-b14-468, i386:	<span class="string">"Java SE 6"</span>	/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home</span><br></pre></td></tr></table></figure>


<p>再使用 jenv add 命令挨个将上述路径添加即可：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AigeStudio@aige$ jenv add /Library/Java/JavaVirtualMachines/openjdk-12.0.1.jdk/Contents/Home</span><br><span class="line">AigeStudio@aige$ jenv add /Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home</span><br><span class="line">AigeStudio@aige$ jenv add /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home</span><br></pre></td></tr></table></figure>


<p>完成上述配置后使用 JEnv 的 versions 命令查看已经被添加至 JEnv 管理的 JDK 版本：</p>
<p>完成上述配置后使用 JEnv 的 versions 命令查看已经被添加至 JEnv 管理的 JDK 版本：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AigeStudio@aige$ jenv versions</span><br><span class="line">  system</span><br><span class="line">  1.6</span><br><span class="line">  1.6.0.65</span><br><span class="line">  1.8</span><br><span class="line">  1.8.0.212</span><br><span class="line">  12.0</span><br><span class="line">* 12.0.1 (<span class="built_in">set</span> by /Users/aige/.jenv/version)</span><br><span class="line">  openjdk64-1.8.0.212</span><br><span class="line">  openjdk64-12.0.1</span><br><span class="line">  oracle64-1.6.0.65</span><br></pre></td></tr></table></figure>

<p>如果看到我们添加的 JDK 6、JDK 8 和 JDK 12 被添加了则表明配置成功。这里需要注意的是，JEnv 会读取 JDK 的不同别名来作为显示。比如上面命令行中罗列出的 1.8、1.8.0.212 以及 openjdk64-1.8.0.212 其实指代的都是 JDK 8。而版本号左边带星号 “*” 的则表示当前执行 Java 命令后会使用到的 JDK 版本。比如上述命令行中 12.0.1 左边有星号，这时我们执行一个 java version 命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AigeStudio@aige$ java -version</span><br><span class="line">openjdk version <span class="string">"12.0.1"</span> 2019-04-16</span><br><span class="line">OpenJDK Runtime Environment (build 12.0.1+12)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 12.0.1+12, mixed mode, sharing)</span><br></pre></td></tr></table></figure>

<p>显示的就会是 JDK 12 的版本。</p>
<p>显示的就会是 JDK 12 的版本。</p>
<p>JEnv 的精髓是 shell、local 和 global 三个参数命令。shell 用于设置终端窗口生命周期内使用的 JDK 版本；local 用于设置当前目录下使用的 JDK 版本；而 global 用于设置全局使用的 JDK 版本。这三个命令的使用方式都一样：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AigeStudio@aige$ jenv shell/<span class="built_in">local</span>/global 1.6</span><br></pre></td></tr></table></figure>


<p>上述命令最后的 “1.6” 即我们在 JEnv 中设置的不同 JDK 版本的别名。这里如果我们想在当前终端窗口中使用 JDK 8，我们只需执行：</p>
<p>上述命令最后的 “1.6” 即我们在 JEnv 中设置的不同 JDK 版本的别名。这里如果我们想在当前终端窗口中使用 JDK 8，我们只需执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AigeStudio@aige$ jenv shell 1.8</span><br></pre></td></tr></table></figure>


<p>此时我们再执行 java version 命令就会显示使用的是 JDK 8：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AigeStudio@aige$ jenv shell 1.8</span><br><span class="line">AigeStudio@aige$ java -version</span><br><span class="line">openjdk version <span class="string">"1.8.0_212"</span></span><br><span class="line">OpenJDK Runtime Environment (AdoptOpenJDK)(build 1.8.0_212-b04)</span><br><span class="line">OpenJDK 64-Bit Server VM (AdoptOpenJDK)(build 25.212-b04, mixed mode)</span><br></pre></td></tr></table></figure>


<p>shell 命令设置的 JDK 是终端窗口生命周期内有效的，即你一旦退出终端再次进入则会失效。而 local 命令则可以让你在某个目录下执行某个具体版本的 JDK：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gclt8pspabj30ll0ekdlp.jpg" alt="JEnv 参数命令 local 的使用 —— From AigeStudio"></p>
<p>local 命令不像 shell 那样有生命周期，一旦在某个目录下使用 local 设置了 JDK 版本，就会在该目录下生成一个 “.java-version” 文件，该文件中记录了当前目录所使用的 JDK 版本，只要你不删除该文件，则设置会一直有效。最后的 global 命令就不说了很好理解。</p>
<p>shell、local 和 global 命令几乎就是 JEnv 的全部，其它的一些小功能不太常用，你可以参考其官方文档或者直接查看 jenv 的命令帮助：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AigeStudio@aige$ jenv</span><br><span class="line">jenv 0.5.2</span><br><span class="line">Usage: jenv &lt;<span class="built_in">command</span>&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">Some useful jenv commands are:</span><br><span class="line">   commands    List all available jenv commands</span><br><span class="line">   <span class="built_in">local</span>       Set or show the <span class="built_in">local</span> application-specific Java version</span><br><span class="line">   global      Set or show the global Java version</span><br><span class="line">   shell       Set or show the shell-specific Java version</span><br><span class="line">   <span class="built_in">rehash</span>      Rehash jenv shims (run this after installing executables)</span><br><span class="line">   version     Show the current Java version and its origin</span><br><span class="line">   versions    List all Java versions available to jenv</span><br><span class="line">   <span class="built_in">which</span>       Display the full path to an executable</span><br><span class="line">   <span class="built_in">whence</span>      List all Java versions that contain the given executable</span><br><span class="line"></span><br><span class="line">See jenv <span class="built_in">help</span> &lt;<span class="built_in">command</span>&gt; <span class="keyword">for</span> information on a specific <span class="built_in">command</span>.</span><br><span class="line">For full documentation, see: https://github.com/hikage/jenv<span class="comment">#readme</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CODING</category>
        <category>零散笔记</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>入手Macbook pro，我的装备大升级！</title>
    <url>/2020/01/01/%E7%94%9F%E6%B4%BB%E9%9A%8F%E8%AE%B0/%E7%A7%91%E6%8A%80/%EF%A3%BF/MacBook%20Pro%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E8%A3%85%E5%A4%87%E5%A4%A7%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<blockquote>
<p>感谢老爸老妈的大力支持，趁着一波教育优惠让我在大学期间获得了梦想的生产力工具，MacBook Pro 2018，已经使用了近半个月了，具体电脑的使用感受过段时间详细叙述，这次先说说我的桌面升级吧，第一次写，望多多包涵，如果你有更好的点子可以留言建议。</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#yi-zheng-ti">一、整体</a></li>
<li><a href="#er-geng-xin-huan-dai-qian">二、更新换代前：</a></li>
<li><a href="#san-xin-tian-she-bei-lie-biao">三、新添设备列表：</a></li>
<li><a href="#si-zhuo-mian">四、桌面</a><ul>
<li><a href="#fang-an-yi-zuo-you-fen-ping">方案一：左右分屏</a></li>
<li><a href="#fang-an-er-shang-xia-fen-ping">方案二：上下分屏</a><ul>
<li><a href="#you-shi">优势：</a></li>
<li><a href="#bu-zu-dai-gai-jin-li-xiang-zhuo-mian">不足待改进（理想桌面）：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#wu-yi-xie-shi-yong-fen-xiang-jian-yi-he-xiao-gan-shou">五、一些使用分享建议和小感受：</a></li>
<li><a href="#san-ge-yue-hou-de-zhen-shi-shi-yong-ti-yan-ji-gai-jin">三个月后的真实使用体验及改进：</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="yi-zheng-ti">一、整体</span><a href="#yi-zheng-ti" class="header-anchor"></a></h1><p>Windows（旧电脑作主机）：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6j52p7ydj30yg0mztbh.jpg" alt></p>
<p>MacOS（MacBook Pro与旧电脑同时，显示器可切换输入原）：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6j4zz5vhj30yg0mzgov.jpg" alt="MacOS"></p>
<h1><span id="er-geng-xin-huan-dai-qian">二、更新换代前：</span><a href="#er-geng-xin-huan-dai-qian" class="header-anchor"></a></h1><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6j5tl1rqj30yg0puad3.jpg" alt></p>
<p>一台15寸 半k分辨率，512G机械硬盘的老dell，左下角的标签已经被磨成镜子。</p>
<h1><span id="san-xin-tian-she-bei-lie-biao">三、新添设备列表：</span><a href="#san-xin-tian-she-bei-lie-biao" class="header-anchor"></a></h1><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6j65j6arj30yg0puq5o.jpg" alt></p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6j6ifiq4j30yg0puq6d.jpg" alt></p>
<p>1）MacBook Pro 2018 （13寸，i5+16G+256G，教育优惠版）：</p>
<p>2）Dell P2418D（2k，24寸，16:9）显示器</p>
<p>3）Beats Solo3 Wireless耳机（暑期苹果教育优惠送）</p>
<p>4）G-Technology 1T移动硬盘（支持type-C和type-A）</p>
<p>5）笔记本立式支架（某宝）</p>
<p>6）小米Type-C转接线</p>
<h1><span id="si-zhuo-mian">四、桌面</span><a href="#si-zhuo-mian" class="header-anchor"></a></h1><h2><span id="fang-an-yi-zuo-you-fen-ping">方案一：左右分屏</span><a href="#fang-an-yi-zuo-you-fen-ping" class="header-anchor"></a></h2><p>优点：可以将扩展显示器竖屏看代码，但实际体验后发现也一般，因为显示器竖起来太长，有时候看顶部需要略微仰头（也可能是我座椅书桌高度的原因）</p>
<p>缺点：1:小屏做主屏，大屏做分屏实在有些别(lang)扭(fei)，当然，可以买一个笔记本支架把mac支起来放在旁边，配合键鼠。但是我不经常使用外接键盘，win的键盘布局和mac自带键盘布局来回切换有些影响生产效率，本人不适应，外加抱怨一下mac os上的鼠标滑轮方向。2:mac和旧电脑的win来回切换太麻烦，实际体验中需要来回换电脑，还有连接线的缠绊(我已经尽可能的将线理顺了)。3:桌面占用面积太大。</p>
<h2><span id="fang-an-er-shang-xia-fen-ping">方案二：上下分屏</span><a href="#fang-an-er-shang-xia-fen-ping" class="header-anchor"></a></h2><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6j7mx5dpj30yg0mzgov.jpg" alt></p>
<h3><span id="you-shi">优势：</span><a href="#you-shi" class="header-anchor"></a></h3><p>1:小屏大屏都可以用作主屏，不用大角度转头来回看，很方便，眼睛比较舒服。</p>
<p>2:使用mac时可以使用笔记本的键盘触摸板，操作舒服，使用win时使用外接键鼠。用mac时键鼠收在显示器下，切换成win时将mac盒盖放在支架上就可以了，解决了方案一中系统互换时的线缆麻烦，而且如果在win上做一些不需要键盘的事情的话，直接切换输入源，用鼠标就可以了，做完再换回mac的dp源，很方便！显示器自带一个HDMI和DP口各一个，我用HDMI连旧电脑作备用机(常开)，DP连MacBook Pro，通过信号输入选择流畅切换。</p>
<p>3:腾出一些放pad和杂物的空间。</p>
<h3><span id="bu-zu-dai-gai-jin-li-xiang-zhuo-mian">不足待改进（理想桌面）：</span><a href="#bu-zu-dai-gai-jin-li-xiang-zhuo-mian" class="header-anchor"></a></h3><p>左侧的充电线还没有完全收拾整齐；显示器背后的线还有一些杂乱，如果遇到需要在旧电脑的win上开双屏的话，比较麻烦(但这种情况很少)；罗技的多设备切换蓝牙键鼠，我感觉应该会很有帮助；如果能入一款支持带有雷雳3并支持100W双向供电的显示器，那么桌面就省去了充电线的困扰；如果桌面是一个L型将更方便电脑工作和文笔工作互不影响；最后，还需配备一把性价比较高的办公椅保护自己的后背。</p>
<h1><span id="wu-yi-xie-shi-yong-fen-xiang-jian-yi-he-xiao-gan-shou">五、一些使用分享建议和小感受：</span><a href="#wu-yi-xie-shi-yong-fen-xiang-jian-yi-he-xiao-gan-shou" class="header-anchor"></a></h1><p>1:macbook pro2018的TouchBar的确没有官网说的那么革命性设计，但在我看来也不至于大多数网友体验中说的那么鸡肋，中规中矩吧，我主要用于调整亮度，音量，播放暂停音乐，看视屏时调进度，打字时输入表情，点击程序RUN键。第二代蝶式键盘刚开始不太适应，但上手很容易，毕竟自己也不是文字工作者，目前的代码量还不足以让我嫌弃它，反而因为宽大的按键面积有一些依赖，网上测评中所说的“敲桌面“我个人倒觉得并没有那么夸张。相反，当换回dell的巧克力键盘时错误率会很高。</p>
<p>2:dell的显示器在1000-2500的性价比上我觉得相比aoc华硕lg等较高，在支架的设计上dell的应该是最为灵活了吧？</p>
<p>3:beats solo3还是有些小，对于我这样戴眼镜的用户来说带久了的确难受，但我并不玩音乐，不追求音质，很喜欢小小的beats感，三四年前就想入一只试试了。于是就没有转卖，自己留着感觉比卖1000块更值得。它的待机40H是真的强！</p>
<p>4:移动硬盘是在苹果官网和电脑一起入的，自带typec，typea两种模式，1TB 500rmb，也没比西部数据贵太多，我觉得在mac上用还是合作第三方的好点吧（初买苹果综合症）。</p>
<p>5:立式支架我买了一款双立的，如果是有把mac当作唯一主力电脑的，或者家里是自带主机的朋友，也可以买一个抬高笔记本的支架，这样可以随时双屏使用，但必需要外接键鼠了。</p>
<p>6:接线方面：dell的显示器大多配有4个USB Type-A接口，但需要一根USB上行接口先与电脑相连，这样就能在只占用一个电脑USB接口有的情况下在显示器上连接键鼠和移动硬盘了，我觉得很赞！而苹果的雷电转接线也有很多种，但有一些会出现发热烫手的情况，于是我当初在某东上“买三退二”（7天无理由），分别试了试400，200，100价位的三款，最后留下性价比最高的还是小米Type -C转HDMI，实测并不发烫，只是温温的感觉。而连接显示器方面推荐绿联的Type-c转DP，很方便（但是不能接在小米转换器的type-c接口上，必须接在电脑上），但绿联的转换头，很烫手！</p>
<p>7:在苹果官网上看到的外接显示器建议：当要断开显示器连接时，应该先将电脑进入睡眠模式，然后拔开线缆。</p>
<h1><span id="san-ge-yue-hou-de-zhen-shi-shi-yong-ti-yan-ji-gai-jin">三个月后的真实使用体验及改进：</span><a href="#san-ge-yue-hou-de-zhen-shi-shi-yong-ti-yan-ji-gai-jin" class="header-anchor"></a></h1><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6j79dijfj30yg0pu75v.jpg" alt></p>
<p>​    真正使用了三个月后，总结了一些更实用的体会和建议，也对当初的布置进行了改进，现在写出来给大家参考。</p>
<p>1：桌面不算大的话，一个Macbook足够，别想着另外连一个pc来回切换，之前我设想的显示器HDMI接pc电脑，PD接mbp纯属多此一举！尤其再把旧电脑当作测试工具瞎玩之后，我就完全把它装进电脑包吃灰了，现在我的桌面日常就是下图这样，我喜欢简简单单的，很舒服！</p>
<p>补充文章时随手一拍<br>需要多屏任务了，就连上dp转type-c的线，打开显示器，不用的时候显示器一般处于关闭状态。</p>
<p>2：键鼠，转换器等外设：能配蓝牙就配蓝牙！能配蓝牙就配蓝牙！能配蓝牙就配蓝牙！<br>    上图中也照出来了，我最常用的状态还是mac自身键盘加一个外置鼠标，而这时的鼠标我也换成了罗技的m590小鼠标（蓝牙静音，土豪可以买mx master3s），jd官方旗舰店前几天刚换的，很好用！比之前那个需要外接无线收发器的鼠标好用百倍！logitech option是神器！之前评论区有朋友提到的“mac外接鼠标滑轮方向问题”用这个软件单独设置罗技鼠标就可以改变，而且不会影响触摸板的两指滑动方向，并不需要插件。罗技鼠标的dpi值也足以让我在家里的书桌上不铺鼠标垫了，嗯，mac配logi，很赞！<br>    至于键盘，之前用着我原来的旧键盘（有线），虽然也有fn快捷键设置功能但是用惯了touch bar控制一些基础设置，还是macbook pro自身的键盘好用，我可能是为数不多的喜欢mac键盘和touch bar的用户了，ipad pro 2018上市后还去店里试了新的ipad键盘，也很舒服，没有网上说的敲木板的感觉，个人观点，自带键盘很好！过段时间可能会买一把蓝牙双模机械键盘，现在纠结于是买60%的还是买84，87键的。对了，这里说下键位，一般外面买的键盘都是windows布局，所以alt键在空格两边，windows键在左alt左面，mac的“设置-键盘-修饰键”中有更改键位的设置，不需要什么插件。<br>    蓝牙音箱，我即使是盒盖看电影时，也觉得macbook pro本身的外放已经很好了，就没有配备音箱设备，如果你还想配一套音响但不求太高境界的话，还是能选蓝牙就选蓝牙！不会错的</p>
<p>3：对于一些预算充裕，比我追求高一层次的朋友的建议，也是我的升级方向：显示器配置上，不差钱的话直接上4k支持type-c雷电3反向供电的显示器，那样充电，数据传输等一条线全部搞定，显示器自带hub，mac的充电器都能省下了！而且，要想做分屏操作，尤其是左右分屏的话，最好是买两个大显示器，像我这种一大一小的，只能勉强上下分屏，而左右很不舒服。</p>
]]></content>
      <categories>
        <category>生活随记</category>
        <category>科技</category>
        <category></category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title>【转】浅谈web网站架构演变过程</title>
    <url>/2020/01/01/CODING/Java%20Web%E6%A1%86%E6%9E%B6/Web%E5%9F%BA%E7%A1%80/%E3%80%90%E8%BD%AC%E3%80%91%E6%B5%85%E8%B0%88web%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>转载自公众号——“java后端”的一篇简述入门java web发展过程的文章，对于技术的实用性有帮助</p>
</blockquote>
<!--toc-->

<a id="more"></a>

<p>[toc]</p>
<h1><span id="ju-li-gai-gua">举例概括</span><a href="#ju-li-gai-gua" class="header-anchor"></a></h1><p>我们以javaweb为例，来搭建一个简单的电商系统，看看这个系统可以如何一步步演变。</p>
<p>该系统具备的功能：</p>
<ul>
<li>用户模块：用户注册和管理</li>
<li>商品模块：商品展示和管理</li>
<li>交易模块：创建交易和管理</li>
</ul>
<p>网站的初期，我们经常会在单机上跑我们所有的程序和软件。此时我们使用一个容器，如tomcat、jetty、jboos，然后直接使用JSP/servlet技术，或者使用一些开源的框架如maven+spring+struct+hibernate、maven+spring+springmvc+mybatis；最后再选择一个数据库管理系统来存储数据，如mysql、sqlserver、oracle，然后通过JDBC进行数据库的连接和操作。</p>
<p>把以上的所有软件都装载同一台机器上，应用跑起来了，也算是一个小系统了。此时系统结果如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcgl528f64j305a06nmwy.jpg" alt="img"></p>
<p>随着网站的上线，访问量逐步上升，服务器的负载慢慢提高，在服务器还没有超载的时候，我们应该就要做好准备，提升网站的负载能力。假如我们代码层面已难以优化，在不提高单台机器的性能的情况下，增加机器是一个不错的方式，不仅可以有效地提高系统的负载能力，而且性价比高。</p>
<p>增加的机器用来做什么呢？此时我们可以把数据库，web服务器拆分开来，这样不仅提高了单台机器的负载能力，也提高了容灾能力。</p>
<p>应用服务器与数据库分开后的架构如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcgl59b1zxj308406tjr7.jpg" alt="img"></p>
<p>随着访问量继续增加，单台应用服务器已经无法满足需求了。在假设数据库服务器没有压力的情况下，我们可以把应用服务器从一台变成了两台甚至多台，把用户的请求分散到不同的服务器中，从而提高负载能力。多台应用服务器之间没有直接的交互，他们都是依赖数据库各自对外提供服务。著名的做故障切换的软件有keepalived，keepalived是一个类似于layer3、4、7交换机制的软件，他不是某个具体软件故障切换的专属品，而是可以适用于各种软件的一款产品。keepalived配合上ipvsadm又可以做负载均衡，可谓是神器。</p>
<p><em>往期关于架构文章可以关注微信公众号：Java后端，后台回复 技术博文 获取。</em></p>
<p>我们以增加了一台应用服务器为例，增加后的系统结构图如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcgl545l29j30bt07nq2s.jpg" alt="img"><strong>系统演变到这里，将会出现下面四个问题</strong>：</p>
<ol>
<li><p>用户的请求由谁来转发到到具体的应用服务器</p>
</li>
<li><p>有什么转发的算法</p>
</li>
<li><p>应用服务器如何返回用户的请求</p>
</li>
<li><p>用户如果每次访问到的服务器不一样，那么如何维护session的一致性</p>
</li>
</ol>
<p><strong>我们来看看解决问题的方案</strong>：</p>
<p><strong>第一个问题即是负载均衡的问题，一般有5种解决方案：</strong></p>
<p>1、<strong>http重定向</strong>。HTTP重定向就是应用层的请求转发。用户的请求其实已经到了HTTP重定向负载均衡服务器，服务器根据算法要求用户重定向，用户收到重定向请求后，再次请求真正的集群</p>
<p>优点：简单。</p>
<p>缺点：性能较差。</p>
<p>2、<strong>DNS域名解析负载均衡</strong>。DNS域名解析负载均衡就是在用户请求DNS服务器，获取域名对应的IP地址时，DNS服务器直接给出负载均衡后的服务器IP。</p>
<p>优点：交给DNS，不用我们去维护负载均衡服务器。</p>
<p>缺点：当一个应用服务器挂了，不能及时通知DNS，而且DNS负载均衡的控制权在域名服务商那里，网站无法做更多的改善和更强大的管理。</p>
<p>3、<strong>反向代理服务器</strong>。在用户的请求到达反向代理服务器时（已经到达网站机房），由反向代理服务器根据算法转发到具体的服务器。常用的apache，nginx都可以充当反向代理服务器。</p>
<p>优点：部署简单。</p>
<p>缺点：代理服务器可能成为性能的瓶颈，特别是一次上传大文件。</p>
<p>4、<strong>IP层负载均衡</strong>。在请求到达负载均衡器后，负载均衡器通过修改请求的目的IP地址，从而实现请求的转发，做到负载均衡。</p>
<p>优点：性能更好。</p>
<p>缺点：负载均衡器的宽带成为瓶颈。</p>
<p>5、<strong>数据链路层负载均衡</strong>。在请求到达负载均衡器后，负载均衡器通过修改请求的mac地址，从而做到负载均衡，与IP负载均衡不一样的是，当请求访问完服务器之后，直接返回客户。而无需再经过负载均衡器。</p>
<p><strong>第二个问题即是集群调度算法问题，常见的调度算法有10种。</strong></p>
<p>**<br>**</p>
<p>1、<strong>rr 轮询调度算法</strong>。顾名思义，轮询分发请求。</p>
<p>优点：实现简单</p>
<p>缺点：不考虑每台服务器的处理能力</p>
<p>2、<strong>wrr 加权调度算法</strong>。我们给每个服务器设置权值weight，负载均衡调度器根据权值调度服务器，服务器被调用的次数跟权值成正比。</p>
<p>优点：考虑了服务器处理能力的不同</p>
<p>3、<strong>sh 原地址散列</strong>：提取用户IP，根据散列函数得出一个key，再根据静态映射表，查处对应的value，即目标服务器IP。过目标机器超负荷，则返回空。</p>
<p>4、<strong>dh 目标地址散列</strong>：同上，只是现在提取的是目标地址的IP来做哈希。</p>
<p>优点：以上两种算法的都能实现同一个用户访问同一个服务器。</p>
<p>5、<strong>lc 最少连接</strong>。优先把请求转发给连接数少的服务器。</p>
<p>优点：使得集群中各个服务器的负载更加均匀。</p>
<p>6、<strong>wlc 加权最少连接</strong>。在lc的基础上，为每台服务器加上权值。算法为：（活动连接数*256+非活动连接数）÷权重 ，计算出来的值小的服务器优先被选择。</p>
<p>优点：可以根据服务器的能力分配请求。</p>
<p>7、<strong>sed 最短期望延迟</strong>。其实sed跟wlc类似，区别是不考虑非活动连接数。算法为：（活动连接数+1)*256÷权重，同样计算出来的值小的服务器优先被选择。</p>
<p>8、<strong>nq 永不排队</strong>。改进的sed算法。我们想一下什么情况下才能“永不排队”，那就是服务器的连接数为0的时候，那么假如有服务器连接数为0，均衡器直接把请求转发给它，无需经过sed的计算。</p>
<p>9、<strong>LBLC 基于局部性的最少连接</strong>。均衡器根据请求的目的IP地址，找出该IP地址最近被使用的服务器，把请求转发之，若该服务器超载，最采用最少连接数算法。</p>
<p>10、<strong>LBLCR 带复制的基于局部性的最少连接</strong>。均衡器根据请求的目的IP地址，找出该IP地址最近使用的“服务器<strong>组</strong>”，注意，并不是具体某个服务器，然后采用最少连接数从该组中挑出具体的某台服务器出来，把请求转发之。若该服务器超载，那么根据最少连接数算法，在集群的<strong>非</strong>本服务器组的服务器中，找出一台服务器出来，加入本服务器组，然后把请求转发之。</p>
<p><strong>第三个问题是集群模式问题，一般3种解决方案：</strong></p>
<p>1、<strong>NAT</strong>：负载均衡器接收用户的请求，转发给具体服务器，服务器处理完请求返回给均衡器，均衡器再重新返回给用户。</p>
<p>2、<strong>DR</strong>：负载均衡器接收用户的请求，转发给具体服务器，服务器出来玩请求后直接返回给用户。需要系统支持IP Tunneling协议，难以跨平台。</p>
<p>3、<strong>TUN</strong>：同上，但无需IP Tunneling协议，跨平台性好，大部分系统都可以支持。</p>
<p>4、第四个问题是session问题，一般有4种解决方案：</p>
<p><strong>Session Sticky</strong>。session sticky就是把同一个用户在某一个会话中的请求，都分配到固定的某一台服务器中，这样我们就不需要解决跨服务器的session问题了，常见的算法有ip_hash法，即上面提到的两种散列算法。</p>
<p>优点：实现简单。</p>
<p>缺点：应用服务器重启则session消失。</p>
<p><strong>Session Replication</strong>。session replication就是在集群中复制session，使得每个服务器都保存有全部用户的session数据。</p>
<p>优点：减轻负载均衡服务器的压力，不需要要实现ip_hasp算法来转发请求。</p>
<p>缺点：复制时宽带开销大，访问量大的话session占用内存大且浪费。</p>
<p><strong>Session数据集中存储</strong>：session数据集中存储就是利用数据库来存储session数据，实现了session和应用服务器的解耦。</p>
<p>优点：相比session replication的方案，集群间对于宽带和内存的压力减少了很多。</p>
<p>缺点：需要维护存储session的数据库。</p>
<p><strong>Cookie Base</strong>：cookie base就是把session存在cookie中，有浏览器来告诉应用服务器我的session是什么，同样实现了session和应用服务器的解耦。</p>
<p>优点：实现简单，基本免维护。</p>
<p>缺点：cookie长度限制，安全性低，宽带消耗。</p>
<p><strong>值得一提的是</strong>：</p>
<p>nginx目前支持的负载均衡算法有wrr、sh（支持一致性哈希）、fair（本人觉得可以归结为lc）。但nginx作为均衡器的话，还可以一同作为静态资源服务器。</p>
<p>keepalived+ipvsadm比较强大，目前支持的算法有：rr、wrr、lc、wlc、lblc、sh、dh</p>
<p>keepalived支持集群模式有：NAT、DR、TUN</p>
<p>nginx本身并没有提供session同步的解决方案，而apache则提供了session共享的支持。</p>
<p>好了，解决了以上的问题之后，<strong>系统的结构如下</strong>：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcgl52r7krj30bt0d0mx8.jpg" alt="img"></p>
<p>上面我们总是假设数据库负载正常，但随着访问量的的提高，数据库的负载也在慢慢增大。那么可能有人马上就想到跟应用服务器一样，把数据库一份为二再负载均衡即可。但对于数据库来说，并没有那么简单。假如我们简单的把数据库一分为二，然后对于数据库的请求，分别负载到A机器和B机器，那么显而易见会造成两台数据库数据不统一的问题。那么对于这种情况，我们可以先考虑使用读写分离的方式。</p>
<p>读写分离后的数据库系统结构如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcgl58dhv9j30c40df3ym.jpg" alt="img"></p>
<p><strong>这个结构变化后也会带来两个问题</strong>：</p>
<p>主从数据库之间数据同步问题</p>
<p>应用对于数据源的选择问题</p>
<p><strong>解决问题方案</strong>：</p>
<p>我们可以使用MYSQL自带的master+slave的方式实现主从复制。</p>
<p>采用第三方数据库中间件，例如mycat。mycat是从cobar发展而来的，而cobar是阿里开源的数据库中间件，后来停止开发。mycat是国内比较好的mysql开源数据库分库分表中间件。</p>
<p>数据库做读库的话，常常对模糊查找力不从心，即使做了读写分离，这个问题还未能解决。以我们所举的交易网站为例，发布的商品存储在数据库中，用户最常使用的功能就是查找商品，尤其是根据商品的标题来查找对应的商品。对于这种需求，一般我们都是通过like功能来实现的，但是这种方式的代价非常大。此时我们可以使用搜索引擎的倒排索引来完成。</p>
<p><strong>搜索引擎具有以下优点</strong>：</p>
<p><strong>引入搜索引擎后也会带来以下的开销</strong>：</p>
<ul>
<li>带来大量的维护工作，我们需要自己实现索引的构建过程，设计全量/增加的构建方式来应对非实时与实时的查询需求。</li>
</ul>
<ul>
<li>需要维护搜索引擎集群</li>
</ul>
<p>搜索引擎并不能替代数据库，他解决了某些场景下的“读”的问题，是否引入搜索引擎，需要综合考虑整个系统的需求。引入搜索引擎后的系统结构如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcgl52aodfj30ch0dhweo.jpg" alt="img"></p>
<p>1、<strong>后台应用层和数据库层的缓存</strong></p>
<p>随着访问量的增加，逐渐出现了许多用户访问同一部分内容的情况，对于这些比较热门的内容，没必要每次都从数据库读取。我们可以使用缓存技术，例如可以使用google的开源缓存技术guava或者使用memcacahe作为应用层的缓存，也可以使用redis作为数据库层的缓存。</p>
<p>另外，在某些场景下，关系型数据库并不是很适合，例如我想做一个“每日输入密码错误次数限制”的功能，思路大概是在用户登录时，如果登录错误，则记录下该用户的IP和错误次数，那么这个数据要放在哪里呢？假如放在内存中，那么显然会占用太大的内容；假如放在关系型数据库中，那么既要建立数据库表，还要简历对应的java bean，还要写SQL等等。而分析一下我们要存储的数据，无非就是类似{ip:errorNumber}这样的key:value数据。对于这种数据，我们可以用NOSQL数据库来代替传统的关系型数据库。</p>
<p>2、<strong>页面缓存</strong></p>
<p>除了数据缓存，还有页面缓存。比如使用HTML5的localstroage或者cookie。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>需要维护缓存服务器</li>
</ul>
<ul>
<li>提高了编码的复杂性</li>
</ul>
<p><strong>值得一提的是</strong>：</p>
<p>缓存集群的调度算法不同与上面提到的应用服务器和数据库。最好采用“一致性哈希算法”，这样才能提高命中率。这个就不展开讲了，有兴趣的可以查阅相关资料。</p>
<p><strong>加入缓存后的结构</strong>：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcgl56yfmtj30g10dh0sz.jpg" alt="img"></p>
<p>我们的网站演进到现在，交易、商品、用户的数据都还在同一个数据库中。尽管采取了增加缓存，读写分离的方式，但随着数据库的压力继续增加，数据库的瓶颈越来越突出，此时，我们可以有数据垂直拆分和水平拆分两种选择。</p>
<p><strong>7.1、数据垂直拆分</strong></p>
<p>垂直拆分的意思是把数据库中不同的业务数据拆分道不同的数据库中，结合现在的例子，就是把交易、商品、用户的数据分开。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>解决了原来把所有业务放在一个数据库中的压力问题。</li>
<li>可以根据业务的特点进行更多的优化</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>需要维护多个数据库</li>
</ul>
<p><strong>问题</strong>：</p>
<ol>
<li><p>需要考虑原来跨业务的事务</p>
</li>
<li><p>跨数据库的join</p>
</li>
</ol>
<p><strong>解决问题方案</strong>：</p>
<p>\1. 我们应该在应用层尽量避免跨数据库的事物，如果非要跨数据库，尽量在代码中控制。</p>
<p>\2. 我们可以通过第三方应用来解决，如上面提到的mycat，mycat提供了丰富的跨库join方案，详情可参考mycat官方文档。</p>
<p>**<br>**</p>
<p><strong>垂直拆分后的结构如下</strong>：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcgl57xlwwj30j60dhaac.jpg" alt="img"></p>
<p><strong>7.2、数据水平拆分</strong></p>
<p>数据水平拆分就是把同一个表中的数据拆分到两个甚至多个数据库中。产生数据水平拆分的原因是某个业务的数据量或者更新量到达了单个数据库的瓶颈，这时就可以把这个表拆分到两个或更多个数据库中。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>如果我们能客服以上问题，那么我们将能够很好地对数据量及写入量增长的情况。</li>
</ul>
<p><strong>问题</strong>：</p>
<p>\1. 访问用户信息的应用系统需要解决SQL路由的问题，因为现在用户信息分在了两个数据库中，需要在进行数据操作时了解需要操作的数据在哪里。</p>
<p>\2. 主键的处理也变得不同，例如原来自增字段，现在不能简单地继续使用了。</p>
<p>\3. 如果需要分页，就麻烦了。</p>
<p><strong>解决问题方案</strong>：</p>
<ol>
<li>我们还是可以通过可以解决第三方中间件，如mycat。</li>
</ol>
<pre><code>mycat可以通过SQL解析模块对我们的SQL进行解析，再根据我们的配置，把请求转发到具体的某个数据库。</code></pre><ol start="2">
<li>我们可以通过UUID保证唯一或自定义ID方案来解决。</li>
</ol>
<ol start="3">
<li>mycat也提供了丰富的分页查询方案，比如先从每个数据库做分页查询，再合并数据做一次分页查询等等。</li>
</ol>
<p><strong>数据水平拆分后的结构</strong>：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcgl53oug0j30js0e8mxh.jpg" alt="img"></p>
<p><strong>8.1、拆分应用</strong></p>
<p>随着业务的发展，业务越来越多，应用越来越大。我们需要考虑如何避免让应用越来越臃肿。这就需要把应用拆开，从一个应用变为俩个甚至更多。还是以我们上面的例子，我们可以把用户、商品、交易拆分开。变成“用户、商品”和“用户，交易”两个子系统。　　</p>
<p>拆分后的结构：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcgl57k93rj30js0e80t4.jpg" alt="img"></p>
<p><strong>问题</strong>：</p>
<p>这样拆分后，可能会有一些相同的代码，如用户相关的代码，商品和交易都需要用户信息，所以在两个系统中都保留差不多的操作用户信息的代码。</p>
<p>如何保证这些代码可以复用是一个需要解决的问题。</p>
<p><strong>解决问题</strong>：</p>
<ol>
<li>通过走服务化的路线来解决</li>
</ol>
<p><strong>8.2、走服务化的道路</strong></p>
<p>为了解决上面拆分应用后所出现的问题，我们把公共的服务拆分出来，形成一种服务化的模式，简称SOA。</p>
<p>采用服务化之后的系统结构：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcgl58urunj30js0gqt96.jpg" alt="img"></p>
<p><strong>优点</strong>：</p>
<ul>
<li>相同的代码不会散落在不同的应用中了，这些实现放在了各个服务中心，使代码得到更好的维护。</li>
</ul>
<ul>
<li>我们把对数据库的交互放在了各个服务中心，让”前端“的web应用更注重与浏览器交互的工作。</li>
</ul>
<p><strong>问题</strong>：</p>
<p>随着网站的继续发展，我们的系统中可能出现不同语言开发的子模块和部署在不同平台的子系统。此时我们需要一个平台来传递可靠的，与平台和语言无关的数据，并且能够把负载均衡透明化，能在调用过程中收集调用数据并分析之，推测出网站的访问增长率等等一系列需求，对于网站应该如何成长做出预测。开源消息中间件有阿里的dubbo，可以搭配Google开源的分布式程序协调服务zookeeper实现服务器的注册与发现。</p>
<p>引入消息中间件后的结构：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcgl538432j30js0jdjru.jpg" alt="img"></p>
<p>以上的演变过程只是一个例子，并不适合所有的网站，实际中网站演进过程与自身业务和不同遇到的问题有密切的关系，没有固定的模式。只有认真的分析和不断地探究，才能发现适合自己网站的架构。</p>
<p>本文有什么说错的地方，希望大家指出，让我好改正过来，多谢。</p>
<p><strong>作者 | 小M的博客</strong></p>
<p><strong>链接 | <a href="http://www.cnblogs.com/xiaoMzjm/p/5223799.html" target="_blank" rel="noopener">www.cnblogs.com/xiaoMzjm/p/5223799.html</a></strong></p>
<p><strong>参考：</strong></p>
<p>《大型网站技术架构：核心原理与案例分析》——李智慧 著</p>
<p>《大型网站系统与Java中间件实践》——曾宪杰 著</p>
<p>《MySQL性能调优与架构设计》——简朝阳 著</p>
<p>《keepalived权威指南》</p>
<p>《mycat权威指南》</p>
<p>《dubbo用户指南》</p>
<p>《计算机网络》</p>
<p>《操作系统》</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>Java Web框架</category>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>web架构</tag>
      </tags>
  </entry>
  <entry>
    <title>CODING/数据库/MySQL/Mysql基础</title>
    <url>/2020/01/11/CODING/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/Mysql%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#yi-shu-ju-ku-de-hao-chu">一、数据库的好处</a></li>
<li><a href="#er-shu-ju-ku-de-xiang-guan-gai-nian">二、数据库的相关概念</a><ul>
<li><a href="#shu-ju-ku-cun-chu-shu-ju-de-te-dian">数据库存储数据的特点</a></li>
<li><a href="#mysql-fu-wu-de-qi-dong-he-ting-zhi">MySQL服务的启动和停止</a></li>
<li><a href="#mysql-fu-wu-de-deng-lu-he-tui-chu">MySQL服务的登录和退出</a></li>
</ul>
</li>
<li><a href="#san-mysql-de-chang-jian-ming-ling">三、MySQL的常见命令</a><ul>
<li><a href="#1-cha-kan-dang-qian-suo-you-de-shu-ju-ku">1.查看当前所有的数据库</a></li>
<li><a href="#2-da-kai-zhi-ding-de-ku">2.打开指定的库</a></li>
<li><a href="#3-cha-kan-dang-qian-ku-de-suo-you-biao">3.查看当前库的所有表</a></li>
<li><a href="#4-cha-kan-qi-ta-ku-de-suo-you-biao">4.查看其它库的所有表</a></li>
<li><a href="#5-chuang-jian-biao">5.创建表</a></li>
<li><a href="#6-cha-kan-biao-jie-gou">6.查看表结构</a></li>
<li><a href="#7-cha-kan-fu-wu-qi-de-ban-ben">7.查看服务器的版本</a></li>
<li><a href="#8-mysql-de-yu-fa-gui-fan">8.MySQL的语法规范</a></li>
</ul>
</li>
<li><a href="#si-sql-de-yu-yan-fen-lei">四、SQL的语言分类</a></li>
<li><a href="#wu-dql-yu-yan-de-xue-xi">五、DQL语言的学习</a><ul>
<li><a href="#jin-jie-1-ji-chu-cha-xun">进阶1：基础查询</a></li>
<li><a href="#jin-jie-2-tiao-jian-cha-xun">进阶2：条件查询</a></li>
<li><a href="#jin-jie-3-pai-xu-cha-xun">进阶3：排序查询</a></li>
<li><a href="#jin-jie-4-chang-jian-han-shu">进阶4：常见函数</a></li>
<li><a href="#jin-jie-5-fen-zu-cha-xun">进阶5：分组查询</a></li>
<li><a href="#jin-jie-6-duo-biao-lian-jie-cha-xun">进阶6：多表连接查询</a></li>
<li><a href="#jin-jie-7-zi-cha-xun">进阶7：子查询</a></li>
<li><a href="#jin-jie-8-fen-ye-cha-xun">进阶8：分页查询</a></li>
<li><a href="#jin-jie-9-lian-he-cha-xun">进阶9：联合查询</a></li>
</ul>
</li>
<li><a href="#liu-dml-yu-yan-de-xue-xi">六、DML语言的学习</a><ul>
<li><a href="#cha-ru">插入</a></li>
<li><a href="#xiu-gai">修改</a></li>
<li><a href="#shan-chu">删除</a></li>
</ul>
</li>
<li><a href="#qi-ddl-yu-yan-de-xue-xi">七、DDL语言的学习</a><ul>
<li><a href="#ku-he-biao-de-guan-li">库和表的管理</a></li>
<li><a href="#chang-jian-lei-xing">常见类型</a></li>
<li><a href="#chang-jian-yue-shu">常见约束</a></li>
</ul>
</li>
<li><a href="#ba-tcl-yu-yan-de-xue-xi-shi-wu">八、TCL语言的学习——事物</a><ul>
<li><a href="#han-yi">含义</a></li>
<li><a href="#te-dian">特点</a></li>
<li><a href="#xiang-guan-bu-zou">相关步骤：</a></li>
<li><a href="#shi-wu-de-fen-lei">事务的分类：</a></li>
<li><a href="#shi-yong-dao-de-guan-jian-zi">使用到的关键字</a></li>
<li><a href="#shi-wu-de-ge-chi-ji-bie">事务的隔离级别:</a></li>
</ul>
</li>
<li><a href="#jiu-shi-tu">九、视图</a><ul>
<li><a href="#han-yi">含义：</a></li>
<li><a href="#shi-tu-he-biao-de-qu-bie">视图和表的区别</a></li>
<li><a href="#shi-tu-de-hao-chu">视图的好处：</a></li>
<li><a href="#shi-tu-de-chuang-jian">视图的创建</a></li>
<li><a href="#shi-tu-de-zeng-shan-gai-cha">视图的增删改查</a></li>
<li><a href="#mou-xie-shi-tu-bu-neng-geng-xin">某些视图不能更新</a></li>
<li><a href="#shi-tu-luo-ji-de-geng-xin">视图逻辑的更新</a></li>
<li><a href="#shi-tu-de-shan-chu">视图的删除</a></li>
<li><a href="#shi-tu-jie-gou-de-cha-kan">视图结构的查看</a></li>
</ul>
</li>
<li><a href="#shi-cun-chu-guo-cheng-he-han-shu">十、存储过程和函数</a><ul>
<li><a href="#cun-chu-guo-cheng">存储过程</a><ul>
<li><a href="#han-yi-1">含义：</a></li>
<li><a href="#hao-chu">好处：</a></li>
<li><a href="#fen-lei">分类：</a></li>
<li><a href="#chuang-jian-cun-chu-guo-cheng">创建存储过程</a></li>
<li><a href="#diao-yong-cun-chu-guo-cheng">调用存储过程</a></li>
</ul>
</li>
<li><a href="#han-shu">函数</a><ul>
<li><a href="#chuang-jian-han-shu">创建函数</a></li>
<li><a href="#diao-yong-han-shu">调用函数</a></li>
</ul>
</li>
<li><a href="#han-shu-he-cun-chu-guo-cheng-de-qu-bie">函数和存储过程的区别</a></li>
</ul>
</li>
<li><a href="#shi-yi-bian-liang">十一、变量</a><ul>
<li><a href="#xi-tong-bian-liang">系统变量</a></li>
<li><a href="#zi-ding-yi-bian-liang">自定义变量</a></li>
</ul>
</li>
<li><a href="#shi-er-liu-cheng-kong-zhi-jie-gou">十二、流程控制结构</a><ul>
<li><a href="#if-han-shu">if函数</a></li>
<li><a href="#case-yu-ju">case语句</a></li>
<li><a href="#if-elseif-yu-ju">if elseif语句</a></li>
<li><a href="#san-zhe-bi-jiao">三者比较：</a></li>
<li><a href="#xun-huan">循环</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="yi-shu-ju-ku-de-hao-chu">一、数据库的好处</span><a href="#yi-shu-ju-ku-de-hao-chu" class="header-anchor"></a></h1><ol>
<li>持久化数据到本地</li>
<li>可以实现结构化查询，方便管理</li>
</ol>
<h1><span id="er-shu-ju-ku-de-xiang-guan-gai-nian">二、数据库的相关概念</span><a href="#er-shu-ju-ku-de-xiang-guan-gai-nian" class="header-anchor"></a></h1><ol>
<li>DB：数据库，保存一组有组织的数据的容器</li>
<li>DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据</li>
<li>SQL:结构化查询语言，用于和DBMS通信的语言</li>
</ol>
<h3><span id="shu-ju-ku-cun-chu-shu-ju-de-te-dian">数据库存储数据的特点</span><a href="#shu-ju-ku-cun-chu-shu-ju-de-te-dian" class="header-anchor"></a></h3><ol>
<li>将数据放到表中，表再放到库中</li>
<li>一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。</li>
<li>表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。</li>
<li>表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”</li>
<li>表中的数据是按行存储的，每一行类似于java中的“对象”。</li>
</ol>
<h3><span id="mysql-fu-wu-de-qi-dong-he-ting-zhi">MySQL服务的启动和停止</span><a href="#mysql-fu-wu-de-qi-dong-he-ting-zhi" class="header-anchor"></a></h3><p>方式一：计算机——右击管理——服务</p>
<p>方式二：通过管理员身份运行<br>    net start 服务名（启动服务）<br>    net stop 服务名（停止服务）</p>
<h3><span id="mysql-fu-wu-de-deng-lu-he-tui-chu">MySQL服务的登录和退出</span><a href="#mysql-fu-wu-de-deng-lu-he-tui-chu" class="header-anchor"></a></h3><p>方式一：通过mysql自带的客户端<br>只限于root用户</p>
<p>方式二：通过windows自带的客户端<br>登录：<br>mysql 【-h主机名 -P端口号 】-u用户名 -p密码</p>
<p>退出：<br>exit或ctrl+C</p>
<h1><span id="san-mysql-de-chang-jian-ming-ling">三、MySQL的常见命令</span><a href="#san-mysql-de-chang-jian-ming-ling" class="header-anchor"></a></h1><h2><span id="1-cha-kan-dang-qian-suo-you-de-shu-ju-ku">1.查看当前所有的数据库</span><a href="#1-cha-kan-dang-qian-suo-you-de-shu-ju-ku" class="header-anchor"></a></h2><pre><code>show databases;</code></pre><h2><span id="2-da-kai-zhi-ding-de-ku">2.打开指定的库</span><a href="#2-da-kai-zhi-ding-de-ku" class="header-anchor"></a></h2><pre><code>use 库名</code></pre><h2><span id="3-cha-kan-dang-qian-ku-de-suo-you-biao">3.查看当前库的所有表</span><a href="#3-cha-kan-dang-qian-ku-de-suo-you-biao" class="header-anchor"></a></h2><pre><code>show tables;</code></pre><h2><span id="4-cha-kan-qi-ta-ku-de-suo-you-biao">4.查看其它库的所有表</span><a href="#4-cha-kan-qi-ta-ku-de-suo-you-biao" class="header-anchor"></a></h2><pre><code>show tables from 库名;</code></pre><h2><span id="5-chuang-jian-biao">5.创建表</span><a href="#5-chuang-jian-biao" class="header-anchor"></a></h2><p>create table 表名(</p>
<pre><code>    列名 列类型,
    列名 列类型，
    。。。
);</code></pre><h2><span id="6-cha-kan-biao-jie-gou">6.查看表结构</span><a href="#6-cha-kan-biao-jie-gou" class="header-anchor"></a></h2><pre><code>desc 表名;</code></pre><h2><span id="7-cha-kan-fu-wu-qi-de-ban-ben">7.查看服务器的版本</span><a href="#7-cha-kan-fu-wu-qi-de-ban-ben" class="header-anchor"></a></h2><pre><code>方式一：登录到mysql服务端
select version();
方式二：没有登录到mysql服务端
mysql --version
或
mysql --V</code></pre><h2><span id="8-mysql-de-yu-fa-gui-fan">8.MySQL的语法规范</span><a href="#8-mysql-de-yu-fa-gui-fan" class="header-anchor"></a></h2><pre><code>1.不区分大小写,但建议关键字大写，表名、列名小写
2.每条命令最好用分号结尾
3.每条命令根据需要，可以进行缩进 或换行
4.注释
    单行注释：#注释文字
    单行注释：-- 注释文字
    多行注释：/* 注释文字  */</code></pre><p>​    </p>
<h1><span id="si-sql-de-yu-yan-fen-lei">四、SQL的语言分类</span><a href="#si-sql-de-yu-yan-fen-lei" class="header-anchor"></a></h1><pre><code>DQL（Data Query Language）：数据查询语言
    select 
DML(Data Manipulate Language):数据操作语言
    insert 、update、delete
DDL（Data Define Languge）：数据定义语言
    create、drop、alter
TCL（Transaction Control Language）：事务控制语言
    commit、rollback</code></pre><h1><span id="wu-dql-yu-yan-de-xue-xi">五、DQL语言的学习</span><a href="#wu-dql-yu-yan-de-xue-xi" class="header-anchor"></a></h1><pre><code>show databases;         查看所有的数据库
use 库名；              打开指定 的库
show tables ;           显示库中的所有表
show tables from 库名;  显示指定库中的所有表
create table 表名(
    字段名 字段类型,    
    字段名 字段类型
); 创建表

desc 表名;              查看指定表的结构
select * from 表名;     显示表中的所有数据</code></pre><h2><span id="jin-jie-1-ji-chu-cha-xun">进阶1：基础查询</span><a href="#jin-jie-1-ji-chu-cha-xun" class="header-anchor"></a></h2><p>语法：</p>
<pre><code> SELECT 要查询的东西
【FROM 表名】;</code></pre><p>特点：</p>
<p>①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在</p>
<p>② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</p>
<h2><span id="jin-jie-2-tiao-jian-cha-xun">进阶2：条件查询</span><a href="#jin-jie-2-tiao-jian-cha-xun" class="header-anchor"></a></h2><p>条件查询：根据条件过滤原始表的数据，查询到想要的数据<br>语法：<br>    select<br>        要查询的字段|表达式|常量值|函数<br>    from<br>        表<br>    where<br>        条件 ;</p>
<p>分类：</p>
<pre><code>1、条件表达式
    示例：salary&gt;10000
    条件运算符：
    &gt; &lt; &gt;= &lt;= = != &lt;&gt;

2、逻辑表达式
示例：salary&gt;10000 &amp;&amp; salary&lt;20000
逻辑运算符：
    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false
    or(||)：两个条件只要有一个成立，结果为true，否则为false
    not(!)：如果条件成立，则not后为false，否则为true
3、模糊查询
示例：last_name like &apos;表达式&apos;</code></pre><h2><span id="jin-jie-3-pai-xu-cha-xun">进阶3：排序查询</span><a href="#jin-jie-3-pai-xu-cha-xun" class="header-anchor"></a></h2><p>语法：</p>
<pre><code>select
    要查询的东西
from
    表
where 
    条件

order by 排序的字段|表达式|函数|别名 【asc|desc】</code></pre><h2><span id="jin-jie-4-chang-jian-han-shu">进阶4：常见函数</span><a href="#jin-jie-4-chang-jian-han-shu" class="header-anchor"></a></h2><p>单行函数</p>
<pre><code>1、字符函数
    concat拼接
    substr截取子串
    upper转换成大写
    lower转换成小写
    trim去前后指定的空格和字符
    ltrim去左边空格
    rtrim去右边空格
    replace替换
    lpad左填充
    rpad右填充
    instr返回子串第一次出现的索引
    length 获取字节个数
2、数学函数
    round 四舍五入
    rand 随机数
    floor向下取整
    ceil向上取整
    mod取余
    truncate截断
3、日期函数
    now当前系统日期+时间
    curdate当前系统日期
    curtime当前系统时间
    str_to_date 将字符转换成日期
    date_format将日期转换成字符
4、流程控制函数
    if 处理双分支
    case语句 处理多分支
        情况1：处理等值判断
        情况2：处理条件判断

5、其他函数
    version版本
    database当前库
    user当前连接用户</code></pre><p>分组函数</p>
<pre><code>sum 求和
max 最大值
min 最小值
avg 平均值
count 计数</code></pre><p>特点：</p>
<pre><code>1、以上五个分组函数都忽略null值，除了count(*)
2、sum和avg一般用于处理数值型
    max、min、count可以处理任何数据类型
3、都可以搭配distinct使用，用于统计去重后的结果
4、count的参数可以支持：
    字段、*、常量值，一般放1,表示计算所有行</code></pre><h2><span id="jin-jie-5-fen-zu-cha-xun">进阶5：分组查询</span><a href="#jin-jie-5-fen-zu-cha-xun" class="header-anchor"></a></h2><p>语法：</p>
<pre><code>select 查询的字段，分组函数
from 表
group by 分组的字段</code></pre><p>特点：</p>
<pre><code>1、可以按单个字段分组
2、和分组函数一同查询的字段最好是分组后的字段
3、分组筛选
4、可以按多个字段分组，字段之间用逗号隔开
5、可以支持排序
6、having后可以支持别名</code></pre><table>
<thead>
<tr>
<th>区别</th>
<th>针对的表</th>
<th>位置</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>分组前筛选</td>
<td>原始表</td>
<td>group by的前面</td>
<td>where</td>
</tr>
<tr>
<td>分组后筛选</td>
<td>分组后的结果集</td>
<td>group by的后面</td>
<td>having</td>
</tr>
</tbody></table>
<h2><span id="jin-jie-6-duo-biao-lian-jie-cha-xun">进阶6：多表连接查询</span><a href="#jin-jie-6-duo-biao-lian-jie-cha-xun" class="header-anchor"></a></h2><pre><code>笛卡尔乘积：如果连接条件省略或无效则会出现
解决办法：添加上连接条件</code></pre><p>1、传统模式下的连接 ：等值连接——非等值连接</p>
<pre><code>1.等值连接的结果 = 多个表的交集
2.n表连接，至少需要n-1个连接条件
3.多个表不分主次，没有顺序要求
4.一般为表起别名，提高阅读性和性能</code></pre><p>2、ql99语法：通过join关键字实现连接</p>
<pre><code>含义：1999年推出的sql语法
支持：
等值连接、非等值连接 （内连接）
外连接
交叉连接</code></pre><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 字段，...</span><br><span class="line">from 表1</span><br><span class="line">【inner|left outer|right outer|cross】join 表2 on  连接条件</span><br><span class="line">【inner|left outer|right outer|cross】join 表3 on  连接条件</span><br><span class="line">【where 筛选条件】</span><br><span class="line">【group by 分组字段】</span><br><span class="line">【having 分组后的筛选条件】</span><br><span class="line">【order by 排序的字段或表达式】</span><br></pre></td></tr></table></figure>

<p>好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</p>
<p>3、自连接</p>
<p>案例：查询员工名和直接上级的名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql99</span><br><span class="line">	SELECT e.last_name,m.last_name</span><br><span class="line">	FROM employees e</span><br><span class="line">	JOIN employees m ON e.&#96;manager_id&#96;&#x3D;m.&#96;employee_id&#96;;</span><br><span class="line">sql92</span><br><span class="line">	SELECT e.last_name,m.last_name</span><br><span class="line">	FROM employees e,employees m </span><br><span class="line">	WHERE e.&#96;manager_id&#96;&#x3D;m.&#96;employee_id&#96;;</span><br></pre></td></tr></table></figure>

<h2><span id="jin-jie-7-zi-cha-xun">进阶7：子查询</span><a href="#jin-jie-7-zi-cha-xun" class="header-anchor"></a></h2><p>含义：<br>    一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询,在外面的查询语句，称为主查询或外查询</p>
<p>特点：</p>
<pre><code>1、子查询都放在小括号内
2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧
3、子查询优先于主查询执行，主查询使用了子查询的执行结果
4、子查询根据查询结果的行数不同分为以下两类：
① 单行子查询
    结果集只有一行
    一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= 
    非法使用子查询的情况：
    a、子查询的结果为一组值
    b、子查询的结果为空

② 多行子查询
    结果集有多行
    一般搭配多行操作符使用：any、all、in、not in
    in： 属于子查询结果中的任意一个就行
    any和all往往可以用其他查询代替</code></pre><h2><span id="jin-jie-8-fen-ye-cha-xun">进阶8：分页查询</span><a href="#jin-jie-8-fen-ye-cha-xun" class="header-anchor"></a></h2><p>应用场景：</p>
<pre><code>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</code></pre><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 字段|表达式,...</span><br><span class="line">from 表</span><br><span class="line">【where 条件】</span><br><span class="line">【group by 分组字段】</span><br><span class="line">【having 条件】</span><br><span class="line">【order by 排序的字段】</span><br><span class="line">limit 【起始的条目索引，】条目数;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.起始条目索引从0开始</span><br><span class="line">2.limit子句放在查询语句的最后</span><br><span class="line">3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage</span><br><span class="line">假如:</span><br><span class="line">每页显示条目数sizePerPage</span><br><span class="line">要显示的页数 page</span><br></pre></td></tr></table></figure>

<h2><span id="jin-jie-9-lian-he-cha-xun">进阶9：联合查询</span><a href="#jin-jie-9-lian-he-cha-xun" class="header-anchor"></a></h2><p>关键字：union 联合、合并</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】</span><br><span class="line">.....</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、多条查询语句的查询的列数必须是一致的</span><br><span class="line">2、多条查询语句的查询的列的类型几乎相同</span><br><span class="line">3、union代表去重，union all代表不去重</span><br></pre></td></tr></table></figure>


<h1><span id="liu-dml-yu-yan-de-xue-xi">六、DML语言的学习</span><a href="#liu-dml-yu-yan-de-xue-xi" class="header-anchor"></a></h1><h2><span id="cha-ru">插入</span><a href="#cha-ru" class="header-anchor"></a></h2><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名(字段名，...)</span><br><span class="line">values(值1，...);</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<pre><code>1、字段类型和值类型一致或兼容，而且一一对应
2、可以为空的字段，可以不用插入值，或用null填充
3、不可以为空的字段，必须插入值
4、字段个数和值的个数必须一致
5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</code></pre><h2><span id="xiu-gai">修改</span><a href="#xiu-gai" class="header-anchor"></a></h2><p>修改单表语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表名 set 字段&#x3D;新值,字段&#x3D;新值</span><br><span class="line">【where 条件】</span><br></pre></td></tr></table></figure>

<p>修改多表语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表1 别名1,表2 别名2</span><br><span class="line">set 字段&#x3D;新值，字段&#x3D;新值</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件</span><br></pre></td></tr></table></figure>


<h2><span id="shan-chu">删除</span><a href="#shan-chu" class="header-anchor"></a></h2><p>方式1：delete语句 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单表的删除： ★</span><br><span class="line">	delete from 表名 【where 筛选条件】</span><br><span class="line">多表的删除：</span><br><span class="line">	delete 别名1，别名2</span><br><span class="line">	from 表1 别名1，表2 别名2</span><br><span class="line">	where 连接条件</span><br><span class="line">	and 筛选条件;</span><br></pre></td></tr></table></figure>

<p>方式2：truncate语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truncate table 表名</span><br></pre></td></tr></table></figure>


<p>两种方式的区别【面试题】</p>
<ol>
<li>truncate不能加where条件，而delete可以加where条件</li>
<li>truncate的效率高一丢丢</li>
<li>truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始.delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始</li>
<li>truncate删除不能回滚，delete删除可以回滚</li>
</ol>
<h1><span id="qi-ddl-yu-yan-de-xue-xi">七、DDL语言的学习</span><a href="#qi-ddl-yu-yan-de-xue-xi" class="header-anchor"></a></h1><h2><span id="ku-he-biao-de-guan-li">库和表的管理</span><a href="#ku-he-biao-de-guan-li" class="header-anchor"></a></h2><p>库的管理：</p>
<p>1、创建库</p>
<pre><code>create database 库名</code></pre><p>2、删除库</p>
<pre><code>drop database 库名</code></pre><p>表的管理：</p>
<p>1.创建表</p>
<pre><code>CREATE TABLE IF NOT EXISTS stuinfo(
    stuId INT,
    stuName VARCHAR(20),
    gender CHAR,
    bornDate DATETIME
);

DESC studentinfo;</code></pre><p>2.修改表 alter</p>
<pre><code>ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">①修改字段名</span><br><span class="line">ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;</span><br><span class="line"></span><br><span class="line">②修改表名</span><br><span class="line">ALTER TABLE stuinfo RENAME [TO]  studentinfo;</span><br><span class="line">#③修改字段类型和列级约束</span><br><span class="line">ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;</span><br><span class="line"></span><br><span class="line">④添加字段</span><br><span class="line">ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;</span><br><span class="line"></span><br><span class="line">⑤删除字段</span><br><span class="line">ALTER TABLE studentinfo DROP COLUMN email;</span><br></pre></td></tr></table></figure>


<p>3.删除表</p>
<pre><code>DROP TABLE [IF EXISTS] studentinfo;</code></pre><h2><span id="chang-jian-lei-xing">常见类型</span><a href="#chang-jian-lei-xing" class="header-anchor"></a></h2><pre><code>整型：Int
小数：
    浮点型:FLOAT
    定点型:DOUBLE
字符型：CHAR VARCHAR()
日期型：DATE(),NOW()
Blob类型：</code></pre><h2><span id="chang-jian-yue-shu">常见约束</span><a href="#chang-jian-yue-shu" class="header-anchor"></a></h2><pre><code>NOT NULL
DEFAULT
UNIQUE
CHECK
PRIMARY KEY
FOREIGN KEY</code></pre><h1><span id="ba-tcl-yu-yan-de-xue-xi-shi-wu">八、TCL语言的学习——事物</span><a href="#ba-tcl-yu-yan-de-xue-xi-shi-wu" class="header-anchor"></a></h1><h2><span id="han-yi">含义</span><a href="#han-yi" class="header-anchor"></a></h2><pre><code>通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态</code></pre><h2><span id="te-dian">特点</span><a href="#te-dian" class="header-anchor"></a></h2><pre><code>（ACID）
原子性：要么都执行，要么都回滚
一致性：保证数据的状态操作前和操作后保持一致
隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰
持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</code></pre><h2><span id="xiang-guan-bu-zou">相关步骤：</span><a href="#xiang-guan-bu-zou" class="header-anchor"></a></h2><pre><code>1、开启事务
2、编写事务的一组逻辑操作单元（多条sql语句）
3、提交事务或回滚事务</code></pre><h2><span id="shi-wu-de-fen-lei">事务的分类：</span><a href="#shi-wu-de-fen-lei" class="header-anchor"></a></h2><p>隐式事务，没有明显的开启和结束事务的标志</p>
<pre><code>比如
insert、update、delete语句本身就是一个事务</code></pre><p>显式事务，具有明显的开启和结束事务的标志</p>
<pre><code>1、开启事务
取消自动提交事务的功能

2、编写事务的一组逻辑操作单元（多条sql语句）
insert
update
delete

3、提交事务或回滚事务</code></pre><h2><span id="shi-yong-dao-de-guan-jian-zi">使用到的关键字</span><a href="#shi-yong-dao-de-guan-jian-zi" class="header-anchor"></a></h2><pre><code>set autocommit=0;
start transaction;
commit;
rollback;

savepoint  断点
commit to 断点
rollback to 断点</code></pre><h2><span id="shi-wu-de-ge-chi-ji-bie">事务的隔离级别:</span><a href="#shi-wu-de-ge-chi-ji-bie" class="header-anchor"></a></h2><p>事务并发问题如何发生？</p>
<pre><code>当多个事务同时操作同一个数据库的相同数据时</code></pre><p>事务的并发问题有哪些？</p>
<pre><code>脏读：一个事务读取到了另外一个事务未提交的数据
不可重复读：同一个事务中，多次读取到的数据不一致
幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据</code></pre><p>如何避免事务的并发问题？</p>
<pre><code>通过设置事务的隔离级别
1、READ UNCOMMITTED     不可避免脏读
2、READ COMMITTED       可以避免脏读
3、REPEATABLE READ      可以避免脏读、不可重复读和一部分幻读
4、SERIALIZABLE         可以避免脏读、不可重复读和幻读</code></pre><p>设置隔离级别：</p>
<pre><code>set session|global transaction isolation level 隔离级别名;</code></pre><p>查看隔离级别：</p>
<pre><code>select @@tx_isolation;</code></pre><h1><span id="jiu-shi-tu">九、视图</span><a href="#jiu-shi-tu" class="header-anchor"></a></h1><h2><span id="han-yi">含义：</span><a href="#han-yi" class="header-anchor"></a></h2><p>理解成一张虚拟的表</p>
<h2><span id="shi-tu-he-biao-de-qu-bie">视图和表的区别</span><a href="#shi-tu-he-biao-de-qu-bie" class="header-anchor"></a></h2><table>
<thead>
<tr>
<th>区别</th>
<th>使用方式</th>
<th>占用物理空间</th>
</tr>
</thead>
<tbody><tr>
<td>视图</td>
<td>完全相同</td>
<td>不占用，仅仅保存的是sql逻辑</td>
</tr>
<tr>
<td>表</td>
<td>完全相同</td>
<td>占用</td>
</tr>
</tbody></table>
<h2><span id="shi-tu-de-hao-chu">视图的好处：</span><a href="#shi-tu-de-hao-chu" class="header-anchor"></a></h2><pre><code>1、sql语句提高重用性，效率高
2、和表实现了分离，提高了安全性</code></pre><h2><span id="shi-tu-de-chuang-jian">视图的创建</span><a href="#shi-tu-de-chuang-jian" class="header-anchor"></a></h2><pre><code>语法：
CREATE VIEW  视图名
AS
查询语句;</code></pre><h2><span id="shi-tu-de-zeng-shan-gai-cha">视图的增删改查</span><a href="#shi-tu-de-zeng-shan-gai-cha" class="header-anchor"></a></h2><p>1、查看视图的数据</p>
<pre><code>SELECT * FROM my_v4;
SELECT * FROM my_v1 WHERE last_name=&apos;Partners&apos;;</code></pre><p>2、插入视图的数据</p>
<pre><code>INSERT INTO my_v4(last_name,department_id) VALUES(&apos;虚竹&apos;,90);</code></pre><p>3、修改视图的数据</p>
<pre><code>UPDATE my_v4 SET last_name =&apos;梦姑&apos; WHERE last_name=&apos;虚竹&apos;;</code></pre><p>4、删除视图的数据</p>
<pre><code>DELETE FROM my_v4;</code></pre><h2><span id="mou-xie-shi-tu-bu-neng-geng-xin">某些视图不能更新</span><a href="#mou-xie-shi-tu-bu-neng-geng-xin" class="header-anchor"></a></h2><pre><code>包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all
常量视图
Select中包含子查询
join
from一个不能更新的视图
where子句的子查询引用了from子句中的表</code></pre><h2><span id="shi-tu-luo-ji-de-geng-xin">视图逻辑的更新</span><a href="#shi-tu-luo-ji-de-geng-xin" class="header-anchor"></a></h2><p>方式一：</p>
<pre><code>CREATE OR REPLACE VIEW test_v7
AS
SELECT last_name FROM employees
WHERE employee_id&gt;100;</code></pre><p>方式二:</p>
<pre><code>ALTER VIEW test_v7
AS
SELECT employee_id FROM employees;

SELECT * FROM test_v7;</code></pre><h2><span id="shi-tu-de-shan-chu">视图的删除</span><a href="#shi-tu-de-shan-chu" class="header-anchor"></a></h2><pre><code>DROP VIEW test_v1,test_v2,test_v3;</code></pre><h2><span id="shi-tu-jie-gou-de-cha-kan">视图结构的查看</span><a href="#shi-tu-jie-gou-de-cha-kan" class="header-anchor"></a></h2><pre><code>DESC test_v7;
SHOW CREATE VIEW test_v7;</code></pre><h1><span id="shi-cun-chu-guo-cheng-he-han-shu">十、存储过程和函数</span><a href="#shi-cun-chu-guo-cheng-he-han-shu" class="header-anchor"></a></h1><h2><span id="cun-chu-guo-cheng">存储过程</span><a href="#cun-chu-guo-cheng" class="header-anchor"></a></h2><h3><span id="han-yi">含义：</span><a href="#han-yi" class="header-anchor"></a></h3><p>一组经过预先编译的sql语句的集合</p>
<h3><span id="hao-chu">好处：</span><a href="#hao-chu" class="header-anchor"></a></h3><pre><code>1、提高了sql语句的重用性，减少了开发程序员的压力
2、提高了效率
3、减少了传输次数</code></pre><h3><span id="fen-lei">分类：</span><a href="#fen-lei" class="header-anchor"></a></h3><pre><code>1、无返回无参
2、仅仅带in类型，无返回有参
3、仅仅带out类型，有返回无参
4、既带in又带out，有返回有参
5、带inout，有返回有参
注意：in、out、inout都可以在一个存储过程中带多个</code></pre><h3><span id="chuang-jian-cun-chu-guo-cheng">创建存储过程</span><a href="#chuang-jian-cun-chu-guo-cheng" class="header-anchor"></a></h3><p>语法：</p>
<pre><code>create procedure 存储过程名(in|out|inout 参数名  参数类型,...)
begin
    存储过程体

end</code></pre><p>注意</p>
<pre><code>1、需要设置新的结束标记
delimiter 新的结束标记
示例：
delimiter $
CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)
BEGIN
    sql语句1;
    sql语句2;
END $

2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end

3、参数前面的符号的意思
in:该参数只能作为输入 （该参数不能做返回值）
out：该参数只能作为输出（该参数只能做返回值）
inout：既能做输入又能做输出</code></pre><h3><span id="diao-yong-cun-chu-guo-cheng">调用存储过程</span><a href="#diao-yong-cun-chu-guo-cheng" class="header-anchor"></a></h3><pre><code>call 存储过程名(实参列表)</code></pre><h2><span id="han-shu">函数</span><a href="#han-shu" class="header-anchor"></a></h2><h3><span id="chuang-jian-han-shu">创建函数</span><a href="#chuang-jian-han-shu" class="header-anchor"></a></h3><p>学过的函数：</p>
<pre><code>LENGTH、SUBSTR、CONCAT等</code></pre><p>语法：</p>
<pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型
BEGIN
    函数体

END</code></pre><h3><span id="diao-yong-han-shu">调用函数</span><a href="#diao-yong-han-shu" class="header-anchor"></a></h3><pre><code>SELECT 函数名（实参列表）</code></pre><h2><span id="han-shu-he-cun-chu-guo-cheng-de-qu-bie">函数和存储过程的区别</span><a href="#han-shu-he-cun-chu-guo-cheng-de-qu-bie" class="header-anchor"></a></h2><table>
<thead>
<tr>
<th>区别</th>
<th>关键字</th>
<th>调用语法</th>
<th>返回值</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>函数</td>
<td>FUNCTION</td>
<td>SELECT 函数()</td>
<td>只能是一个</td>
<td>一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个</td>
</tr>
<tr>
<td>存储过程</td>
<td>PROCEDURE</td>
<td>CALL 存储过程()</td>
<td>可以有0个或多个</td>
<td>一般用于更新</td>
</tr>
</tbody></table>
<h1><span id="shi-yi-bian-liang">十一、变量</span><a href="#shi-yi-bian-liang" class="header-anchor"></a></h1><h2><span id="xi-tong-bian-liang">系统变量</span><a href="#xi-tong-bian-liang" class="header-anchor"></a></h2><p>1、全局变量</p>
<p>作用域：针对于所有会话（连接）有效，但不能跨重启</p>
<pre><code>查看所有全局变量
SHOW GLOBAL VARIABLES;
查看满足条件的部分系统变量
SHOW GLOBAL VARIABLES LIKE &apos;%char%&apos;;
查看指定的系统变量的值
SELECT @@global.autocommit;
为某个系统变量赋值
SET @@global.autocommit=0;
SET GLOBAL autocommit=0;</code></pre><p>2、会话变量</p>
<p>作用域：针对于当前会话（连接）有效</p>
<pre><code>查看所有会话变量
SHOW SESSION VARIABLES;
查看满足条件的部分会话变量
SHOW SESSION VARIABLES LIKE &apos;%char%&apos;;
查看指定的会话变量的值
SELECT @@autocommit;
SELECT @@session.tx_isolation;
为某个会话变量赋值
SET @@session.tx_isolation=&apos;read-uncommitted&apos;;
SET SESSION tx_isolation=&apos;read-committed&apos;;</code></pre><h2><span id="zi-ding-yi-bian-liang">自定义变量</span><a href="#zi-ding-yi-bian-liang" class="header-anchor"></a></h2><p>1、用户变量</p>
<p>声明并初始化：</p>
<pre><code>SET @变量名=值;
SET @变量名:=值;
SELECT @变量名:=值;</code></pre><p>赋值：</p>
<pre><code>方式一：一般用于赋简单的值
SET 变量名=值;
SET 变量名:=值;
SELECT 变量名:=值;


方式二：一般用于赋表 中的字段值
SELECT 字段名或表达式 INTO 变量
FROM 表;</code></pre><p>使用：</p>
<pre><code>select @变量名;</code></pre><p>2、局部变量</p>
<p>声明：</p>
<pre><code>declare 变量名 类型 【default 值】;</code></pre><p>赋值：</p>
<pre><code>方式一：一般用于赋简单的值
SET 变量名=值;
SET 变量名:=值;
SELECT 变量名:=值;


方式二：一般用于赋表 中的字段值
SELECT 字段名或表达式 INTO 变量
FROM 表;</code></pre><p>使用：</p>
<pre><code>select 变量名</code></pre><p>自定义变量的区别：</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>作用域</th>
<th>定义位置</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>用户变量</td>
<td>当前会话</td>
<td>会话的任何地方</td>
<td>加@符号，不用指定类型</td>
</tr>
<tr>
<td>局部变量</td>
<td>定义它的BEGIN END中</td>
<td>BEGIN END的第一句话</td>
<td>一般不用加@,需要指定类型</td>
</tr>
</tbody></table>
<h1><span id="shi-er-liu-cheng-kong-zhi-jie-gou">十二、流程控制结构</span><a href="#shi-er-liu-cheng-kong-zhi-jie-gou" class="header-anchor"></a></h1><h2><span id="if-han-shu">if函数</span><a href="#if-han-shu" class="header-anchor"></a></h2><p>语法：</p>
<pre><code>if(条件，值1，值2)</code></pre><p>特点：</p>
<pre><code>可以用在任何位置</code></pre><h2><span id="case-yu-ju">case语句</span><a href="#case-yu-ju" class="header-anchor"></a></h2><p>语法：</p>
<pre><code>情况一：类似于switch
case 表达式
when 值1 then 结果1或语句1(如果是语句，需要加分号) 
when 值2 then 结果2或语句2(如果是语句，需要加分号)
...
else 结果n或语句n(如果是语句，需要加分号)
end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</code></pre><p>​<br>​    情况二：类似于多重if<br>​    case<br>​    when 条件1 then 结果1或语句1(如果是语句，需要加分号)<br>​    when 条件2 then 结果2或语句2(如果是语句，需要加分号)<br>​    …<br>​    else 结果n或语句n(如果是语句，需要加分号)<br>​    end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</p>
<p>特点：<br>    可以用在任何位置</p>
<h2><span id="if-elseif-yu-ju">if elseif语句</span><a href="#if-elseif-yu-ju" class="header-anchor"></a></h2><p>语法：</p>
<pre><code>if 情况1 then 语句1;
elseif 情况2 then 语句2;
...
else 语句n;
end if;</code></pre><p>特点：<br>    只能用在begin end中！！！！！！！！！！！！！！！</p>
<h2><span id="san-zhe-bi-jiao">三者比较：</span><a href="#san-zhe-bi-jiao" class="header-anchor"></a></h2><table>
<thead>
<tr>
<th>语法</th>
<th>应用场合</th>
</tr>
</thead>
<tbody><tr>
<td>if函数</td>
<td>简单双分支</td>
</tr>
<tr>
<td>case结构</td>
<td>等值判断 的多分支</td>
</tr>
<tr>
<td>if结构</td>
<td>区间判断 的多分支</td>
</tr>
</tbody></table>
<h2><span id="xun-huan">循环</span><a href="#xun-huan" class="header-anchor"></a></h2><p>语法：</p>
<pre><code>【标签：】WHILE 循环条件  DO
    循环体
END WHILE 【标签】;</code></pre><p>特点：</p>
<pre><code>1、只能放在BEGIN END里面

2、如果要搭配leave跳转语句，需要使用标签，否则可以不用标签

3、leave类似于java中的break语句，跳出所在循环！！！</code></pre>]]></content>
      <categories>
        <category>CODING</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>在MacOS下配置Idea的最全教程</title>
    <url>/2020/01/01/CODING/%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%9C%A8MacOS%E4%B8%8B%E9%85%8D%E7%BD%AEIdea%E7%9A%84%E6%9C%80%E5%85%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>这篇文章详细记录了在Mac OS上使用IDEA开发环境的所有功能</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#huan-jing-de-ji-ben-jie-shao">环境的基本介绍</a></li>
<li><a href="#xia-zai-an-zhuang-yu-ren-zheng">下载安装与认证</a><ul>
<li><a href="#xue-sheng-ren-zheng">学生认证</a></li>
</ul>
</li>
<li><a href="#zheng-shi-shi-yong-qian-de-xi-guan-she-zhi-yi-ji-jiang-jie">正式使用前的习惯设置以及讲解</a><ul>
<li><a href="#ying-yong-de-pei-zhi-wen-jian-shuo-ming">应用的配置文件说明</a></li>
<li><a href="#chu-shi-hua-pei-zhi">初始化配置</a></li>
<li><a href="#kai-fa-qian-de-yi-xie-xi-guan-pei-zhi">开发前的一些习惯配置</a><ul>
<li><a href="#ji-chu-pei-zhi">基础配置</a></li>
<li><a href="#pei-zhi-tomcat-fu-wu-qi">配置tomcat服务器</a></li>
<li><a href="#pei-zhi-maven">配置maven：</a></li>
<li><a href="#pei-zhi-git">配置git</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#kuai-jie-jian">快捷键</a><ul>
<li><a href="#she-zhi-he-cha-zhao-kuai-jie-jian">设置和查找快捷键</a></li>
<li><a href="#command">Command</a></li>
<li><a href="#option">Option</a></li>
<li><a href="#shift">Shift</a></li>
<li><a href="#comand-option">Comand + Option</a></li>
<li><a href="#command-shift">Command + Shift</a></li>
<li><a href="#option-shift">Option + Shift</a></li>
<li><a href="#command-option-shift">Command + Option + Shift</a></li>
<li><a href="#qi-ta">其他</a></li>
</ul>
</li>
<li><a href="#qi-ta-shi-yong-ji-lu-geng-xin-zhong">其他使用记录（更新中……）</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<p>[toc]</p>
<h1><span id="huan-jing-de-ji-ben-jie-shao">环境的基本介绍</span><a href="#huan-jing-de-ji-ben-jie-shao" class="header-anchor"></a></h1><p>MacOS Catalina + Idea2019.3 Utrl版本[2020年2月记录]</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6nc3kw0jj30j20cejsf.jpg" alt="IDEA图标"></p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6ndfu1zgj30je0cet9d.jpg" alt="MacOS系统"></p>
<h1><span id="xia-zai-an-zhuang-yu-ren-zheng">下载安装与认证</span><a href="#xia-zai-an-zhuang-yu-ren-zheng" class="header-anchor"></a></h1><p>首先，进入<a href="https://www.jetbrains.com/" target="_blank" rel="noopener">jetbrains官网</a>：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc5l00b8tvj31kh0nbq70.jpg" alt="截屏2020-02-22下午11.10.52"></p>
<h2><span id="xue-sheng-ren-zheng">学生认证</span><a href="#xue-sheng-ren-zheng" class="header-anchor"></a></h2><p>这里提供大家一个薅羊毛的好方法，注册账号后进行学生认证，每年通过edu邮箱认证一次，就可以免费使用该系列软件，而你的大学edu邮箱即使毕业后也可以继续使用</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc5llog1ohj316o0kv77f.jpg" alt="学生认证"></p>
<p>之后下载dmg文件或者使用homebrew安装即可，第一次使用需要身份认证，用你已经通过学生认证的账号登陆就可以免费使用几乎所有jetbrains系列的开发神器了！</p>
<h1><span id="zheng-shi-shi-yong-qian-de-xi-guan-she-zhi-yi-ji-jiang-jie">正式使用前的习惯设置以及讲解</span><a href="#zheng-shi-shi-yong-qian-de-xi-guan-she-zhi-yi-ji-jiang-jie" class="header-anchor"></a></h1><h2><span id="ying-yong-de-pei-zhi-wen-jian-shuo-ming">应用的配置文件说明</span><a href="#ying-yong-de-pei-zhi-wen-jian-shuo-ming" class="header-anchor"></a></h2><p>不论使用dmg安装包还是hombrew安装，Mac上idea的使用文件主要有两个：</p>
<ol>
<li><p>/Application下的IntelliJ IDEA.app文件，我们右键–&gt;显示包内容打开后可以看到软件的具体配置（windows下直接进入安装目录即可）。<img src="https://tva1.sinaimg.cn/large/0082zybply1gc6lqz97ijj30h807y3z5.jpg" alt="app包内容">)这里只需要对bin目录下的idea.vmoptions文件进行适当修改即可。<img src="https://tva1.sinaimg.cn/large/0082zybply1gc6lryycroj30ke0oljww.jpg" alt="idea.vmoptions文件"></p>
</li>
<li><p>配置文件路径：用户家目录/Library/Preferences/IntelliJIdea2019.3 /。这个目下存放了所有idea中的用户配置，如果从未打开过，则不会生成，如果之后的使用中有什么问题，删除该目录，即可重新配置idea。<img src="https://tva1.sinaimg.cn/large/0082zybply1gc6lvks7wtj30nt0gkaeu.jpg" alt="idea配置文件路径"></p>
</li>
</ol>
<h2><span id="chu-shi-hua-pei-zhi">初始化配置</span><a href="#chu-shi-hua-pei-zhi" class="header-anchor"></a></h2><p>导入默认设置，如果你以前熟练使用idea并时刻保留着自己独有的一套配置文件，便可以在这里直接选择第一条（config or installation folder）选择你的设置项所在目录导入，快速开发：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc66htvjdhj30es07hjrh.jpg" alt="截屏2020-02-23上午11.34.32"></p>
<p>一系列常规初始化选择，大家可以根据自己的喜好选择设置</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc66lzcqa2j30ph0ltacw.jpg" alt="截屏2020-02-23上午11.36.18"></p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc66pq7g7kj30ph0ltabp.jpg" alt="截屏2020-02-23上午11.39.33"></p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc66rwecx6j30ph0ltq5b.jpg" alt="截屏2020-02-23上午11.43.02"></p>
<p>简单的初始化设置过后，就到了idea软件主界面：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6ihxp89ij30ke0fa0tc.jpg" alt="主界面"></p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6ijv4b31j308v07ymxi.jpg" alt="配置"></p>
<p><strong>注意⚠️：这时还不着急新建项目开发，根据我的习惯，在创建项目前进行良好的设置，非常有助于后面项目的创建、导入和维护。</strong></p>
<h2><span id="kai-fa-qian-de-yi-xie-xi-guan-pei-zhi">开发前的一些习惯配置</span><a href="#kai-fa-qian-de-yi-xie-xi-guan-pei-zhi" class="header-anchor"></a></h2><h3><span id="ji-chu-pei-zhi">基础配置</span><a href="#ji-chu-pei-zhi" class="header-anchor"></a></h3><ul>
<li><h4><span id="she-zhi-zi-ti">设置字体</span><a href="#she-zhi-zi-ti" class="header-anchor"></a></h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6h7hb0o6j30ue0n6q8o.jpg" alt="设置字体"></p>
</li>
<li><h4><span id="she-zhi-gun-lun-gai-bian-zi-ti-da-xiao">设置滚轮改变字体大小</span><a href="#she-zhi-gun-lun-gai-bian-zi-ti-da-xiao" class="header-anchor"></a></h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6bga6inkj30ue0n60vc.jpg" alt="截屏2020-02-23下午2.24.31"></p>
</li>
<li><h4><span id="she-zhi-shu-biao-xuan-ting-ti-shi">设置鼠标悬停提示</span><a href="#she-zhi-shu-biao-xuan-ting-ti-shi" class="header-anchor"></a></h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6bkglhh0j30ue0n640v.jpg" alt="设置鼠标悬停提示"></p>
</li>
<li><h4><span id="she-zhi-xian-shi-xing-hao-he-fen-ge-fu">设置显示行号和分隔符</span><a href="#she-zhi-xian-shi-xing-hao-he-fen-ge-fu" class="header-anchor"></a></h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6h0pf0o0j30ue0n6gr9.jpg" alt="设置显示行号和分隔符"></p>
</li>
<li><h4><span id="you-hua-zi-dong-dao-bao-gong-neng">优化自动导包功能</span><a href="#you-hua-zi-dong-dao-bao-gong-neng" class="header-anchor"></a></h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6gwrbm9vj30ue0n6dls.jpg" alt="优化自动导包功能"></p>
</li>
<li><h4><span id="bian-ma-she-zhi">编码设置：</span><a href="#bian-ma-she-zhi" class="header-anchor"></a></h4><p>都设置为UTF-8对中英文的兼容性最好，由于mac默认的是utf-8，所以不需要再更改了，这里只是记录路径，方便查看。windows端默认是GBK，可以从这里改为utf-8。</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6hbx32qyj30ue0n6q8s.jpg" alt="编码设置"></p>
</li>
<li><h4><span id="zi-dong-bian-yi-she-zhi">自动编译设置：</span><a href="#zi-dong-bian-yi-she-zhi" class="header-anchor"></a></h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6hm8m2u8j30ue0n6wlc.jpg" alt="自动编译"></p>
<p>然后设置registry：（快捷键command+option+shift+/）</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggm4r5n0bvj30lq08gmyk.jpg" alt="打开Registry"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggm4u3snirj31mw0r647m.jpg" alt="配置Registry"></p>
</li>
<li><h4><span id="she-zhi-wen-jian-tab-duo-xing-xian-shi">设置文件tab多行显示</span><a href="#she-zhi-wen-jian-tab-duo-xing-xian-shi" class="header-anchor"></a></h4><p>  在编写项目时，我们经常会打开很多文件进行编辑，不能每次打开编辑后再关闭，需要编辑时再打开，所以idea默认的将文件标签都显示在一行很不利于我们方便切换已打开的文件。</p>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gglope31vmj313w0u0diw.jpg" alt="设置多行文件名"></p>
</li>
<li><h4><span id="she-zhi-wen-jian-hu-lue">设置文件忽略</span><a href="#she-zhi-wen-jian-hu-lue" class="header-anchor"></a></h4><p>  在创建一个项目或者模块后，idea会自带很多开发中用不到的软件配置文件(如xxxx.mvn、xxx.iml、xxxx.idea等），这时候在设置里将这些文件根据后置名忽略掉，就会让项目（projects）界面清爽很多。</p>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gglp1j8pblj313w0u0q6e.jpg" alt="设置文件忽略"></p>
</li>
</ul>
<pre><code>springboot热部署的额外配置：

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用于实现热部署插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>【项目名】<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>​    </p>
<h3><span id="pei-zhi-tomcat-fu-wu-qi">配置tomcat服务器</span><a href="#pei-zhi-tomcat-fu-wu-qi" class="header-anchor"></a></h3><p>主界面配置（Configure）–&gt; 新项目的运行配置模版（Run Configuration Template for New Projects）</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6ktbfgydj30li0js0vq.jpg" alt="Run Templation"></p>
<p>然后根据自己所需创建不同的服务模版，我这里选择的是Tomcat，并添加了本地安装好的Tomcat路径</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6kxy2zlhj30tv0intbi.jpg" alt="截屏2020-02-23下午7.52.19"></p>
<h3><span id="pei-zhi-maven">配置maven：</span><a href="#pei-zhi-maven" class="header-anchor"></a></h3><p>主界面配置（Configuration） –&gt; 偏好设置（Preferences）–&gt;  Build, Execution, Deployment –&gt; Maven</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6a75zg3hj30ue0n6tc2.jpg" alt="截屏2020-02-23上午11.58.32"></p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6k02bwqaj30ue0n6juo.jpg" alt="截屏2020-02-23下午7.19.04"></p>
<h3><span id="pei-zhi-git">配置git</span><a href="#pei-zhi-git" class="header-anchor"></a></h3><p>mac系统自带git命令，所以idea会默认指向系统自带的git命令，而windows中则需要自己写入安装git.exe文件的目录。最后可以先使用Test检查是否能用</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6khnsd6hj30ue0n640x.jpg" alt="git"></p>
<p>登陆github账户以方便操作自己的github上的仓库</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6k47afm1j30r00jw0u8.jpg" alt="github"></p>
<p>好了！这样一来就可以创建一个项目开始工作了！！！！</p>
<h1><span id="kuai-jie-jian">快捷键</span><a href="#kuai-jie-jian" class="header-anchor"></a></h1><h2><span id="she-zhi-he-cha-zhao-kuai-jie-jian">设置和查找快捷键</span><a href="#she-zhi-he-cha-zhao-kuai-jie-jian" class="header-anchor"></a></h2><p>Preferen —&gt; KeyMap</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6m0s9fcuj30ue0n60uk.jpg" alt="快捷键"></p>
<h2><span id="command">Command</span><a href="#command" class="header-anchor"></a></h2><table>
<thead>
<tr>
<th align="left">Win 快捷键</th>
<th align="left">Mac 快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>F</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>F</kbd></td>
<td align="left">在当前文件进行文本查找</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>R</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>R</kbd></td>
<td align="left">在当前文件进行文本替换</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Z</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Z</kbd></td>
<td align="left">撤销</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Y</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Delete</kbd></td>
<td align="left">删除光标所在行 或 删除选中的行</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>D</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>D</kbd></td>
<td align="left">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>W</kbd></td>
<td align="left"><kbd>Option</kbd> + <kbd>方向键上</kbd></td>
<td align="left">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>E</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>E</kbd></td>
<td align="left">显示最近打开的文件记录列表</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>N</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>O</kbd></td>
<td align="left">根据输入的 <strong>类名</strong> 查找类文件</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>J</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>J</kbd></td>
<td align="left">插入自定义动态代码模板</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>P</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>P</kbd></td>
<td align="left">方法参数提示显示</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>U</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>U</kbd></td>
<td align="left">前往当前光标所在的方法的父类的方法 / 接口定义</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>B</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>B</kbd></td>
<td align="left">进入光标所在的方法/变量的接口或是定义处，等效于 <code>Ctrl + 左键单击</code></td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>/</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>/</kbd></td>
<td align="left">注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>F1</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>F1</kbd></td>
<td align="left">在光标所在的错误代码处显示错误信息</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>F11</kbd></td>
<td align="left"><kbd>Option</kbd> + <kbd>F3</kbd></td>
<td align="left">选中文件 / 文件夹，使用助记符设定 / 取消书签</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>F12</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>F12</kbd></td>
<td align="left">弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Space</kbd></td>
<td align="left"><kbd>Control</kbd> + <kbd>Space</kbd></td>
<td align="left">基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl + 逗号</code></td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Delete</kbd></td>
<td align="left"><kbd>Option</kbd> + <kbd>Fn</kbd>+ Delete</td>
<td align="left">删除光标后面的单词或是中文句</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>BackSpace</kbd></td>
<td align="left"><kbd>Option</kbd> + <kbd>Delete</kbd></td>
<td align="left">删除光标前面的单词或是中文句</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>1,2,3...9</kbd></td>
<td align="left"><kbd>Control</kbd> + <kbd>1,2,3...9</kbd></td>
<td align="left">定位到对应数值的书签位置</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>加号</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>加号</kbd></td>
<td align="left">展开代码</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>减号</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>减号</kbd></td>
<td align="left">折叠代码</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>左键单击</kbd></td>
<td align="left"><kbd>Control</kbd> + <kbd>左键单击</kbd></td>
<td align="left">在打开的文件标题上，弹出该文件路径</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>左方向键</kbd></td>
<td align="left"><kbd>Option</kbd> + <kbd>左方向键</kbd></td>
<td align="left">光标跳转到当前单词 / 中文句的左侧开头位置</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>右方向键</kbd></td>
<td align="left"><kbd>Option</kbd> + <kbd>右方向键</kbd></td>
<td align="left">光标跳转到当前单词 / 中文句的右侧开头位置</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>前方向键</kbd></td>
<td align="left">预设中没有该快捷键</td>
<td align="left">等效于鼠标滚轮向前效果</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>后方向键</kbd></td>
<td align="left">预设中没有该快捷键</td>
<td align="left">等效于鼠标滚轮向后效果</td>
</tr>
</tbody></table>
<h2><span id="option">Option</span><a href="#option" class="header-anchor"></a></h2><table>
<thead>
<tr>
<th align="left">Win 快捷键</th>
<th align="left">Mac 快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><kbd>Alt</kbd> + <kbd>`</kbd></td>
<td align="left"><kbd>Control</kbd> + <kbd>V</kbd></td>
<td align="left">显示版本控制常用操作菜单弹出层</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>F1</kbd></td>
<td align="left"><kbd>Option</kbd> + <kbd>F1</kbd></td>
<td align="left">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>F7</kbd></td>
<td align="left"><kbd>Option</kbd> + <kbd>F7</kbd></td>
<td align="left">查询所选对象/变量被引用</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>Enter</kbd></td>
<td align="left"><kbd>Option</kbd> + <kbd>Enter</kbd></td>
<td align="left">IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>Insert</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>N</kbd></td>
<td align="left">代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>左方向键</kbd></td>
<td align="left"><kbd>Control</kbd> + <kbd>左方向键</kbd></td>
<td align="left">切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>右方向键</kbd></td>
<td align="left"><kbd>Control</kbd> + <kbd>右方向键</kbd></td>
<td align="left">切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>前方向键</kbd></td>
<td align="left"><kbd>Control</kbd> + <kbd>前方向键</kbd></td>
<td align="left">当前光标跳转到当前文件的前一个方法名位置</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>后方向键</kbd></td>
<td align="left"><kbd>Control</kbd> + <kbd>后方向键</kbd></td>
<td align="left">当前光标跳转到当前文件的后一个方法名位置</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>1,2,3...9</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>1,2,3...9</kbd></td>
<td align="left">显示对应数值的选项卡，其中 1 是 Project 用得最多</td>
</tr>
</tbody></table>
<h2><span id="shift">Shift</span><a href="#shift" class="header-anchor"></a></h2><table>
<thead>
<tr>
<th align="left">Win 快捷键</th>
<th align="left">Mac 快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><kbd>Shift</kbd> + <kbd>F11</kbd></td>
<td align="left"><kbd>Command + F3</kbd></td>
<td align="left">弹出书签显示层</td>
</tr>
<tr>
<td align="left"><kbd>Shift</kbd> + <kbd>Tab</kbd></td>
<td align="left"><kbd>Shift + Tab</kbd></td>
<td align="left">取消缩进</td>
</tr>
<tr>
<td align="left"><kbd>Shift</kbd> + <kbd>Enter</kbd></td>
<td align="left"><kbd>Shift + Enter</kbd></td>
<td align="left">开始新一行。光标所在行下空出一行，光标定位到新行位置</td>
</tr>
<tr>
<td align="left"><kbd>Shift</kbd> + <kbd>左键单击</kbd></td>
<td align="left"><kbd>Shift + 左键单击</kbd></td>
<td align="left">在打开的文件名上按此快捷键，可以关闭当前打开文件</td>
</tr>
</tbody></table>
<h2><span id="comand-option">Comand + Option</span><a href="#comand-option" class="header-anchor"></a></h2><table>
<thead>
<tr>
<th align="left">Win 快捷键</th>
<th align="left">Mac 快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>L</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>L</kbd></td>
<td align="left">格式化代码，可以对当前文件和整个包目录使用</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>O</kbd></td>
<td align="left"><kbd>Control</kbd> + <kbd>Option</kbd> + <kbd>O</kbd></td>
<td align="left">优化导入的类，可以对当前文件和整个包目录使用</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>T</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>T</kbd></td>
<td align="left">对选中的代码弹出环绕选项弹出层</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>S</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>逗号</kbd></td>
<td align="left">打开 IntelliJ IDEA 系统设置</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>Enter</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>Enter</kbd></td>
<td align="left">光标所在行上空出一行，光标定位到新行</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>左方向键</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>左方向键</kbd></td>
<td align="left">退回到上一个操作的地方</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>右方向键</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>右方向键</kbd></td>
<td align="left">前进到上一个操作的地方</td>
</tr>
</tbody></table>
<h2><span id="command-shift">Command + Shift</span><a href="#command-shift" class="header-anchor"></a></h2><table>
<thead>
<tr>
<th align="left">Win 快捷键</th>
<th align="left">Mac 快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>F</kbd></td>
<td align="left">根据输入内容查找整个项目 或 指定目录内文件</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>R</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>R</kbd></td>
<td align="left">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>J</kbd></td>
<td align="left"><kbd>Control</kbd> + <kbd>Shift</kbd> + <kbd>J</kbd></td>
<td align="left">自动将下一行合并到当前行末尾</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd></td>
<td align="left">取消撤销</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>W</kbd></td>
<td align="left"><kbd>Option</kbd> + <kbd>方向键下</kbd></td>
<td align="left">递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>N</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd></td>
<td align="left">通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd></td>
<td align="left">对选中的代码进行大 / 小写轮流转换</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd></td>
<td align="left">对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd></td>
<td align="left">复制当前文件磁盘路径到剪贴板</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>B</kbd></td>
<td align="left"><kbd>Control</kbd> + <kbd>Shift</kbd> + <kbd>B</kbd></td>
<td align="left">跳转到类型声明处</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>/</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Option</kbd> + <kbd>/</kbd></td>
<td align="left">代码块注释</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>[</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>[</kbd></td>
<td align="left">选中从光标所在位置到它的顶部中括号位置</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>]</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>]</kbd></td>
<td align="left">选中从光标所在位置到它的底部中括号位置</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>加号</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>加号</kbd></td>
<td align="left">展开所有代码</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>减号</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>减号</kbd></td>
<td align="left">折叠所有代码</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F7</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>F7</kbd></td>
<td align="left">高亮显示所有该选中文本，按Esc高亮消失</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F12</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>F12</kbd></td>
<td align="left">编辑器最大化</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Enter</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>Enter</kbd></td>
<td align="left">自动结束代码，行末自动添加分号</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Backspace</kbd></td>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Backspace</kbd></td>
<td align="left">退回到上次修改的地方</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>1,2,3...9</kbd></td>
<td align="left"><kbd>Control</kbd> + <kbd>Shift</kbd> + <kbd>1,2,3...9</kbd></td>
<td align="left">快速添加指定数值的书签</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>左键单击</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>左键单击</kbd></td>
<td align="left">把光标放在某个类变量上，按此快捷键可以直接定位到该类中</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>左方向键</kbd></td>
<td align="left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>左方向键</kbd></td>
<td align="left">在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>右方向键</kbd></td>
<td align="left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>右方向键</kbd></td>
<td align="left">在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>前方向键</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>前方向键</kbd></td>
<td align="left">光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>后方向键</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>后方向键</kbd></td>
<td align="left">光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td>
</tr>
</tbody></table>
<h2><span id="option-shift">Option + Shift</span><a href="#option-shift" class="header-anchor"></a></h2><table>
<thead>
<tr>
<th align="left">Win 快捷键</th>
<th align="left">Mac 快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>N</kbd></td>
<td align="left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>B</kbd></td>
<td align="left">选择 / 添加 task</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>左键双击</kbd></td>
<td align="left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>左键双击</kbd></td>
<td align="left">选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>前方向键</kbd></td>
<td align="left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>前方向键</kbd></td>
<td align="left">移动光标所在行向上移动</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>后方向键</kbd></td>
<td align="left"><kbd>Option</kbd> + <kbd>Shift</kbd> + <kbd>后方向键</kbd></td>
<td align="left">移动光标所在行向下移动</td>
</tr>
</tbody></table>
<h2><span id="command-option-shift">Command + Option + Shift</span><a href="#command-option-shift" class="header-anchor"></a></h2><table>
<thead>
<tr>
<th align="left">Win 快捷键</th>
<th align="left">Mac 快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Alt</kbd> + <kbd>V</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>Option</kbd> + <kbd>V</kbd></td>
<td align="left">无格式黏贴</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Alt</kbd> + <kbd>S</kbd></td>
<td align="left"><kbd>Command</kbd> + <kbd>;</kbd></td>
<td align="left">打开当前项目设置</td>
</tr>
</tbody></table>
<h2><span id="qi-ta">其他</span><a href="#qi-ta" class="header-anchor"></a></h2><table>
<thead>
<tr>
<th align="left">Win 快捷键</th>
<th align="left">Mac 快捷键</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><kbd>F2</kbd></td>
<td align="left"><kbd>F2</kbd></td>
<td align="left">跳转到下一个高亮错误 或 警告位置</td>
</tr>
<tr>
<td align="left"><kbd>F4</kbd></td>
<td align="left"><kbd>F4</kbd></td>
<td align="left">编辑源</td>
</tr>
<tr>
<td align="left"><kbd>F11</kbd></td>
<td align="left"><kbd>F3</kbd></td>
<td align="left">添加书签</td>
</tr>
<tr>
<td align="left"><kbd>F12</kbd></td>
<td align="left"><kbd>F12</kbd></td>
<td align="left">回到前一个工具窗口</td>
</tr>
<tr>
<td align="left"><kbd>Tab</kbd></td>
<td align="left"><kbd>Tab</kbd></td>
<td align="left">缩进</td>
</tr>
<tr>
<td align="left"><kbd>ESC</kbd></td>
<td align="left"><kbd>ESC</kbd></td>
<td align="left">从工具窗口进入代码文件窗口</td>
</tr>
</tbody></table>
<h1><span id="qi-ta-shi-yong-ji-lu-geng-xin-zhong">其他使用记录（更新中……）</span><a href="#qi-ta-shi-yong-ji-lu-geng-xin-zhong" class="header-anchor"></a></h1>]]></content>
      <categories>
        <category>CODING</category>
        <category>零散笔记</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Idea教程</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】Redis面试回答</title>
    <url>/2020/01/01/CODING/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E3%80%90%E8%BD%AC%E3%80%91Redis%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94/</url>
    <content><![CDATA[<blockquote>
<p>转载自微信公众号——Java后端的一篇“Redis面试回答知识点”</p>
</blockquote>
<div class="toc">

<!-- toc -->

<ul>
<li><a href="#redis-shi-shi-me">Redis 是什么</a></li>
<li><a href="#wu-chong-shu-ju-lei-xing">五种数据类型</a></li>
<li><a href="#redis-huan-cun">Redis 缓存</a><ul>
<li><a href="#redistemplate-de-shi-yong-fang-shi"><strong>RedisTemplate 的使用方式</strong></a></li>
<li><a href="#shi-yong-spring-cache-ji-cheng-redis"><strong>使用 Spring Cache 集成 Redis</strong></a></li>
<li><a href="#huan-cun-zhu-jie"><strong>缓存注解</strong></a><ul>
<li><a href="#cacheable"><strong>①@Cacheable</strong></a></li>
<li><a href="#cacheput"><strong>②@CachePut</strong></a></li>
<li><a href="#cacheevict"><strong>③@CacheEvict</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#huan-cun-wen-ti">缓存问题</a></li>
<li><a href="#redis-wei-he-zhe-me-kuai">Redis 为何这么快</a></li>
<li><a href="#redis-he-memcached-de-qu-bie">Redis 和 Memcached 的区别</a></li>
<li><a href="#tao-tai-ce-lue">淘汰策略</a></li>
<li><a href="#chi-jiu-hua">持久化</a></li>
<li><a href="#zhu-cong-fu-zhi">主从复制</a></li>
<li><a href="#shao-bing">哨兵</a></li>
<li><a href="#zong-jie">总结</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<p>[toc]</p>
<h1><span id="redis-shi-shi-me">Redis 是什么</span><a href="#redis-shi-shi-me" class="header-anchor"></a></h1><p><strong>面试官：</strong>你先来说下 Redis 是什么吧！</p>
<p><strong>我：</strong>（这不就是总结下 Redis 的定义和特点嘛）Redis 是 C 语言开发的一个开源的（遵从 BSD 协议）高性能键值对（key-value）的内存数据库，可以用作数据库、缓存、消息中间件等。</p>
<p>它是一种 NoSQL（not-only sql，泛指非关系型数据库）的数据库。</p>
<p>我顿了一下，接着说，Redis 作为一个内存数据库：</p>
<ul>
<li><p>性能优秀，数据在内存中，读写速度非常快，支持并发 10W QPS。</p>
</li>
<li><p>单进程单线程，是线程安全的，采用 IO 多路复用机制。</p>
</li>
<li><p>丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等。</p>
</li>
<li><p>支持数据持久化。</p>
<p>  可以将内存中数据保存在磁盘中，重启时加载。</p>
</li>
<li><p>主从复制，哨兵，高可用。</p>
</li>
<li><p>可以用作分布式锁。</p>
</li>
<li><p>可以作为消息中间件使用，支持发布订阅。</p>
</li>
</ul>
<h1><span id="wu-chong-shu-ju-lei-xing">五种数据类型</span><a href="#wu-chong-shu-ju-lei-xing" class="header-anchor"></a></h1><p><strong>面试官：</strong>总结的不错，看来是早有准备啊。刚来听你提到 Redis 支持五种数据类型，那你能简单说下这五种数据类型吗？</p>
<p><strong>我：</strong>当然可以，但是在说之前，我觉得有必要先来了解下 Redis 内部内存管理是如何描述这 5 种数据类型的。</p>
<p><font color="green">说着，我拿着笔给面试官画了一张图：</font></p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcfkqey6tvj30hs08cjrj.jpg" alt="img"></p>
<p><strong>我：</strong>首先 Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。</p>
<p>redisObject 最主要的信息如上图所示：type 表示一个 value 对象具体是何种数据类型，encoding 是不同数据类型在 Redis 内部的存储方式。</p>
<p>比如：type=string 表示 value 存储的是一个普通字符串，那么 encoding 可以是 raw 或者 int。</p>
<p>我顿了一下，接着说，下面我简单说下 5 种数据类型：</p>
<p>①String 是 Redis 最基本的类型，可以理解成与 Memcached一模一样的类型，一个 Key 对应一个 Value。Value 不仅是 String，也可以是数字。String 类型是二进制安全的，意思是 Redis 的 String 类型可以包含任何数据，比如 jpg 图片或者序列化的对象。String 类型的值最大能存储 512M。</p>
<p>②Hash是一个键值（key-value）的集合。Redis 的 Hash 是一个 String 的 Key 和 Value 的映射表，Hash 特别适合存储对象。常用命令：hget，hset，hgetall 等。</p>
<p>③List 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边） 常用命令：lpush、rpush、lpop、rpop、lrange（获取列表片段）等。应用场景：List 应用场景非常多，也是 Redis 最重要的数据结构之一，比如 Twitter 的关注列表，粉丝列表都可以用 List 结构来实现。</p>
<p>数据结构：List 就是链表，可以用来当消息队列用。Redis 提供了 List 的 Push 和 Pop 操作，还提供了操作某一段的 API，可以直接查询或者删除某一段的元素。</p>
<p>实现方式：Redis List 的是实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销。</p>
<p>④Set 是 String 类型的无序集合。集合是通过 hashtable 实现的。Set 中的元素是没有顺序的，而且是没有重复的。常用命令：sdd、spop、smembers、sunion 等。</p>
<p>应用场景：Redis Set 对外提供的功能和 List 一样是一个列表，特殊之处在于 Set 是自动去重的，而且 Set 提供了判断某个成员是否在一个 Set 集合中。</p>
<p>⑤Zset 和 Set 一样是 String 类型元素的集合，且不允许重复的元素。常用命令：zadd、zrange、zrem、zcard 等。</p>
<p>使用场景：Sorted Set 可以通过用户额外提供一个优先级（score）的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择 Sorted Set 结构。和 Set 相比，Sorted Set关联了一个 Double 类型权重的参数 Score，使得集合中的元素能够按照 Score 进行有序排列，Redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>实现方式：Redis Sorted Set 的内部使用 HashMap 和跳跃表（skipList）来保证数据的存储和有序，HashMap 里放的是成员到 Score 的映射。而跳跃表里存放的是所有的成员，排序依据是 HashMap 里存的 Score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p>
<p>数据类型应用场景总结：</p>
<p><strong><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcflptrq1zj30ik0e40uc.jpg" alt="img">面试</strong></p>
<p><strong>官：</strong>想不到你平时也下了不少工夫，那 Redis 缓存你一定用过的吧？</p>
<p><strong>我：</strong>用过的。</p>
<p><strong>面试官：</strong>那你跟我说下你是怎么用的？</p>
<p><strong>我：</strong>我是结合 Spring Boot 使用的。一般有两种方式，一种是直接通过 RedisTemplate 来使用，另一种是使用 Spring Cache 集成 Redis（也就是注解的方式）。</p>
<h1><span id="redis-huan-cun">Redis 缓存</span><a href="#redis-huan-cun" class="header-anchor"></a></h1><p>直接通过 RedisTemplate 来使用，使用 Spring Cache 集成 Redis pom.xml 中加入以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>spring-boot-starter-data-redis：</strong>在 Spring Boot 2.x 以后底层不再使用 Jedis，而是换成了 Lettuce。</p>
<p><strong>commons-pool2：</strong>用作 Redis 连接池，如不引入启动会报错。</p>
<p><strong>spring-session-data-redis：</strong>Spring Session 引入，用作共享 Session。</p>
<p>配置文件 application.yml 的配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">session:</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">30ms</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="comment"># redis默认情况下有16个分片，这里配置具体使用的分片，默认为0</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment"># 连接池最大连接数(使用负数表示没有限制),默认8</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>



<p>创建实体类 User.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">662692455422902539L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id, String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="redistemplate-de-shi-yong-fang-shi"><strong>RedisTemplate 的使用方式</strong></span><a href="#redistemplate-de-shi-yong-fang-shi" class="header-anchor"></a></h2><p>默认情况下的模板只能支持 RedisTemplate&lt;String, String&gt;，也就是只能存入字符串，所以自定义模板很有必要。</p>
<p>添加配置类 RedisCacheConfig.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(RedisAutoConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RedisCacheConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Serializable&gt; <span class="title">redisCacheTemplate</span><span class="params">(LettuceConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Serializable&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger logger = LogManager.getLogger(UserController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Serializable&gt; redisCacheTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisCacheTemplate.opsForValue().set(<span class="string">"userkey"</span>, <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"张三"</span>, <span class="number">25</span>));</span><br><span class="line">        User user = (User) redisCacheTemplate.opsForValue().get(<span class="string">"userkey"</span>);</span><br><span class="line">        logger.info(<span class="string">"当前获取对象：&#123;&#125;"</span>, user.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>然后在浏览器访问，观察后台日志 <a href="http://localhost:8082/user/test" target="_blank" rel="noopener">http://localhost:8082/user/test</a></p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcflr76yz8j30hs01idfq.jpg" alt="img"></p>
<h2><span id="shi-yong-spring-cache-ji-cheng-redis"><strong>使用 Spring Cache 集成 Redis</strong></span><a href="#shi-yong-spring-cache-ji-cheng-redis" class="header-anchor"></a></h2><p>Spring Cache 具备很好的灵活性，不仅能够使用 SPEL（spring expression language）来定义缓存的 Key 和各种 Condition，还提供了开箱即用的缓存临时存储方案，也支持和主流的专业缓存如 EhCache、Redis、Guava 的集成。</p>
<p>定义接口 UserService.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">get</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接口实现类 UserServiceImpl.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger logger = LogManager.getLogger(UserServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, User&gt; userMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        userMap.put(<span class="number">1</span>, <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"肖战"</span>, <span class="number">25</span>));</span><br><span class="line">        userMap.put(<span class="number">2</span>, <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"王一博"</span>, <span class="number">26</span>));</span><br><span class="line">        userMap.put(<span class="number">3</span>, <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"杨紫"</span>, <span class="number">24</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut</span>(value =<span class="string">"user"</span>, key = <span class="string">"#user.id"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userMap.put(user.getId(), user);</span><br><span class="line">        logger.info(<span class="string">"进入save方法，当前存储对象：&#123;&#125;"</span>, user.toString());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict</span>(value=<span class="string">"user"</span>, key = <span class="string">"#id"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        userMap.remove(id);</span><br><span class="line">        logger.info(<span class="string">"进入delete方法，删除成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable</span>(value = <span class="string">"user"</span>, key = <span class="string">"#id"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"进入get方法，当前获取对象：&#123;&#125;"</span>, userMap.get(id)==<span class="keyword">null</span>?<span class="keyword">null</span>:userMap.get(id).toString());</span><br><span class="line">        <span class="keyword">return</span> userMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便演示数据库的操作，这里直接定义了一个 Map&lt;Integer,User&gt; userMap。</p>
<p>这里的核心是三个注解：</p>
<ul>
<li><strong>@Cachable</strong></li>
<li><strong>@CachePut</strong></li>
<li><strong>@CacheEvict</strong></li>
</ul>
<p>测试类：UserController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger logger = LogManager.getLogger(UserController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Serializable&gt; redisCacheTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisCacheTemplate.opsForValue().set(<span class="string">"userkey"</span>, <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"张三"</span>, <span class="number">25</span>));</span><br><span class="line">        User user = (User) redisCacheTemplate.opsForValue().get(<span class="string">"userkey"</span>);</span><br><span class="line">        logger.info(<span class="string">"当前获取对象：&#123;&#125;"</span>, user.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = userService.save(<span class="keyword">new</span> User(<span class="number">4</span>, <span class="string">"李现"</span>, <span class="number">30</span>));</span><br><span class="line">        logger.info(<span class="string">"添加的用户信息：&#123;&#125;"</span>,user.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/delete"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userService.delete(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> String idStr) <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(idStr)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"id为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Integer id = Integer.parseInt(idStr);</span><br><span class="line">        User user = userService.get(id);</span><br><span class="line">        logger.info(<span class="string">"获取的用户信息：&#123;&#125;"</span>,user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>用缓存要注意，启动类要加上一个注解开启缓存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(exclude=DataSourceAutoConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">EnableCaching</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>①先调用添加接口：<a href="http://localhost:8082/user/add" target="_blank" rel="noopener">http://localhost:8082/user/add</a></p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcflrt0l1aj30hs00yq2r.jpg" alt="img"></p>
<p>②再调用查询接口，查询 id=4 的用户信息：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcflskj2duj30hs00zmwy.jpg" alt="img"></p>
<p>可以看出，这里已经从缓存中获取数据了，因为上一步 add 方法已经把 id=4 的用户数据放入了 Redis 缓存 3、调用删除方法，删除 id=4 的用户信息，同时清除缓存：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcflspqohfj30hs00uwe9.jpg" alt="img"></p>
<p>④再次调用查询接口，查询 id=4 的用户信息：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcflsvebr8j30hs00mq2q.jpg" alt="img"></p>
<p>没有了缓存，所以进入了 get 方法，从 userMap 中获取。</p>
<h2><span id="huan-cun-zhu-jie"><strong>缓存注解</strong></span><a href="#huan-cun-zhu-jie" class="header-anchor"></a></h2><h3><span id="cacheable"><strong>①@Cacheable</strong></span><a href="#cacheable" class="header-anchor"></a></h3><p>根据方法的请求参数对其结果进行缓存：</p>
<ul>
<li><strong>Key：</strong>缓存的 Key，可以为空，如果指定要按照 SPEL 表达式编写，如果不指定，则按照方法的所有参数进行组合。</li>
<li><strong>Value：</strong>缓存的名称，必须指定至少一个（如 @Cacheable (value=’user’)或者 @Cacheable(value={‘user1’,’user2’})）</li>
<li><strong>Condition：</strong>缓存的条件，可以为空，使用 SPEL 编写，返回 true 或者 false，只有为 true 才进行缓存。</li>
</ul>
<h3><span id="cacheput"><strong>②@CachePut</strong></span><a href="#cacheput" class="header-anchor"></a></h3><p>根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用。参数描述见上。</p>
<h3><span id="cacheevict"><strong>③@CacheEvict</strong></span><a href="#cacheevict" class="header-anchor"></a></h3><p><font color="green">根据条件对缓存进行清空：</font></p>
<ul>
<li>Key：同上。</li>
<li>Value：同上。</li>
<li>Condition：同上。</li>
<li>allEntries：是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存。</li>
<li><strong>beforeInvocation：</strong>是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存。缺省情况下，如果方法执行抛出异常，则不会清空缓存。</li>
</ul>
<h1><span id="huan-cun-wen-ti">缓存问题</span><a href="#huan-cun-wen-ti" class="header-anchor"></a></h1><p><strong>面试官：</strong>看了一下你的 Demo，简单易懂。那你在实际项目中使用缓存有遇到什么问题或者会遇到什么问题你知道吗？</p>
<p><strong>我：</strong>缓存和数据库数据一致性问题：分布式环境下非常容易出现缓存和数据库间数据一致性问题，针对这一点，如果项目对缓存的要求是强一致性的，那么就不要使用缓存。</p>
<p>我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。</p>
<p>合适的策略包括合适的缓存更新策略，更新数据库后及时更新缓存、缓存失败时增加重试机制。</p>
<p><strong>面试官：</strong>Redis 雪崩了解吗？</p>
<p><strong>我：</strong>我了解的，目前电商首页以及热点数据都会去做缓存，一般缓存都是定时任务去刷新，或者查不到之后去更新缓存的，定时任务刷新就有一个问题。</p>
<p>举个栗子：如果首页所有 Key 的失效时间都是 12 小时，中午 12 点刷新的，我零点有个大促活动大量用户涌入，假设每秒 6000 个请求，本来缓存可以抗住每秒 5000 个请求，但是缓存中所有 Key 都失效了。</p>
<p>此时 6000 个/秒的请求全部落在了数据库上，数据库必然扛不住，真实情况可能 DBA 都没反应过来直接挂了。此时，如果没什么特别的方案来处理，DBA 很着急，重启数据库，但是数据库立马又被新流量给打死了。这就是我理解的缓存雪崩。</p>
<p><strong>我心想：</strong>同一时间大面积失效，瞬间 Redis 跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的。你想想如果挂的是一个用户服务的库，那其他依赖他的库所有接口几乎都会报错。如果没做熔断等策略基本上就是瞬间挂一片的节奏，你怎么重启用户都会把你打挂，等你重启好的时候，用户早睡觉去了，临睡之前，骂骂咧咧“什么垃圾产品”。</p>
<p><strong>面试官摸摸了自己的头发：</strong>嗯，还不错，那这种情况你都是怎么应对的？</p>
<p><strong>我：</strong>处理缓存雪崩简单，在批量往 Redis 存数据的时候，把每个 Key 的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setRedis（key, value, time+Math.random()*10000）;</span><br></pre></td></tr></table></figure>

<p>如果 Redis 是集群部署，将热点数据均匀分布在不同的 Redis 库中也能避免全部失效。或者设置热点数据永不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就好了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。</p>
<p><strong>面试官：</strong>那你了解缓存穿透和击穿么，可以说说他们跟雪崩的区别吗？</p>
<p><strong>我：</strong>嗯，了解，先说下缓存穿透吧，缓存穿透是指缓存和数据库中都没有的数据，而用户（黑客）不断发起请求。</p>
<p>举个栗子：我们数据库的 id 都是从 1 自增的，如果发起 id=-1 的数据或者 id 特别大不存在的数据，这样的不断攻击导致数据库压力很大，严重会击垮数据库。</p>
<p><strong>我又接着说：</strong>至于缓存击穿嘛，这个跟缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了 DB。而缓存击穿不同的是缓存击穿是指一个 Key 非常热点，在不停地扛着大量的请求，大并发集中对这一个点进行访问，当这个 Key 在失效的瞬间，持续的大并发直接落到了数据库上，就在这个 Key 的点上击穿了缓存。</p>
<p><strong>面试官露出欣慰的眼光：</strong>那他们分别怎么解决？</p>
<p><strong>我：</strong>缓存穿透我会在接口层增加校验，比如用户鉴权，参数做校验，不合法的校验直接 return，比如 id 做基础校验，id&lt;=0 直接拦截。</p>
<p><strong>面试官：</strong>那你还有别的方法吗？</p>
<p><strong>我：</strong>我记得 Redis 里还有一个高级用法布隆过滤器（Bloom Filter）这个也能很好的预防缓存穿透的发生。它的原理也很简单，就是利用高效的数据结构和算法快速判断出你这个 Key 是否在数据库中存在，不存在你 return 就好了，存在你就去查 DB 刷新 KV 再 return。缓存击穿的话，设置热点数据永不过期，或者加上互斥锁就搞定了。作为暖男，代码给你准备好了，拿走不谢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getData</span><span class="params">(String key)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//从Redis查询数据</span></span><br><span class="line">        String result = getDataByKV(key);</span><br><span class="line">        <span class="comment">//参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(result)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获得锁</span></span><br><span class="line">                <span class="keyword">if</span> (reenLock.tryLock()) &#123;</span><br><span class="line">                    <span class="comment">//去数据库查询</span></span><br><span class="line">                    result = getDataByDB(key);</span><br><span class="line">                    <span class="comment">//校验</span></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotBlank(result)) &#123;</span><br><span class="line">                        <span class="comment">//插进缓存</span></span><br><span class="line">                        setDataToKV(key, result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//睡一会再拿</span></span><br><span class="line">                    Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">                    result = getData(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                reenLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>面试官：</strong>嗯嗯，还不错。</p>
<h1><span id="redis-wei-he-zhe-me-kuai">Redis 为何这么快</span><a href="#redis-wei-he-zhe-me-kuai" class="header-anchor"></a></h1><p><strong>面试官：</strong>Redis 作为缓存大家都在用，那 Redis 一定很快咯？</p>
<p><strong>我：</strong>当然了，官方提供的数据可以达到 100000+ 的 QPS（每秒内的查询次数），这个数据不比 Memcached 差！</p>
<p><strong>面试官：</strong>Redis 这么快，它的“多线程模型”你了解吗？（露出邪魅一笑）</p>
<p><strong>我：</strong>您是想问 Redis 这么快，为什么还是单线程的吧。Redis 确实是单进程单线程的模型，因为 Redis 完全是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。</p>
<p>既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章的采用单线程的方案了（毕竟采用多线程会有很多麻烦）。</p>
<p><strong>面试官：</strong>嗯，是的。那你能说说 Redis 是单线程的，为什么还能这么快吗？</p>
<p><strong>我：</strong>可以这么说吧，总结一下有如下四点：</p>
<ul>
<li>Redis 完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度是 O(1)。</li>
<li>数据结构简单，对数据操作也简单。</li>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的 CPU 切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。</li>
<li>使用多路复用 IO 模型，非阻塞 IO。</li>
</ul>
<h1><span id="redis-he-memcached-de-qu-bie">Redis 和 Memcached 的区别</span><a href="#redis-he-memcached-de-qu-bie" class="header-anchor"></a></h1><p><strong>面试官：</strong>嗯嗯，说的很详细。那你为什么选择 Redis 的缓存方案而不用 Memcached 呢？</p>
<p><strong>我：</strong>原因有如下四点：</p>
<ul>
<li><strong>存储方式上：</strong>Memcache 会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis 有部分数据存在硬盘上，这样能保证数据的持久性。</li>
<li><strong>数据支持类型上：</strong>Memcache 对数据类型的支持简单，只支持简单的 key-value，，而 Redis 支持五种数据类型。</li>
<li><strong>使用底层模型不同：</strong>它们之间底层实现方式以及与客户端之间通信的应用协议不一样。Redis 直接自己构建了 VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li>
<li><strong>Value 的大小：</strong>Redis 可以达到 1GB，而 Memcache 只有 1MB。</li>
</ul>
<h1><span id="tao-tai-ce-lue">淘汰策略</span><a href="#tao-tai-ce-lue" class="header-anchor"></a></h1><p><strong>面试官：</strong>那你说说你知道的 Redis 的淘汰策略有哪些？</p>
<p><strong>我：</strong>Redis 有六种淘汰策略，如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcfmjip7x5j30gy0a3jsc.jpg" alt="img"></p>
<p><strong>补充一下：</strong>Redis 4.0 加入了 LFU（least frequency use）淘汰策略，包括 volatile-lfu 和 allkeys-lfu，通过统计访问频率，将访问频率最少，即最不经常使用的 KV 淘汰。</p>
<h1><span id="chi-jiu-hua">持久化</span><a href="#chi-jiu-hua" class="header-anchor"></a></h1><p><strong>面试官：</strong>你对 Redis 的持久化机制了解吗？能讲一下吗？</p>
<p><strong>我：</strong>Redis 为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。</p>
<p><font color="green">Redis 的持久化策略有两种：</font></p>
<ul>
<li><strong>RDB：</strong>快照形式是直接把内存中的数据保存到一个 dump 的文件中，定时保存，保存策略。</li>
<li><strong>AOF：</strong>把所有的对 Redis 的服务器进行修改的命令都存到一个文件里，命令的集合。Redis 默认是快照 RDB 的持久化方式。</li>
</ul>
<p>当 Redis 重启的时候，它会优先使用 AOF 文件来还原数据集，因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存。</p>
<p><strong>面试官：</strong>那你再说下 RDB 是怎么工作的？</p>
<p><strong>我：</strong>默认 Redis 是会以快照”RDB”的形式将数据持久化到磁盘的一个二进制文件 dump.rdb。</p>
<p>工作原理简单说一下：当 Redis 需要做持久化时，Redis 会 fork 一个子进程，子进程将数据写到磁盘上一个临时 RDB 文件中。当子进程完成写临时文件后，将原来的 RDB 替换掉，这样的好处是可以 copy-on-write。</p>
<p><strong>我：</strong>RDB 的优点是：这种文件非常适合用于备份：比如，你可以在最近的 24 小时内，每小时备份一次，并且在每个月的每一天也备份一个 RDB 文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB 非常适合灾难恢复。</p>
<p>RDB 的缺点是：如果你需要尽量避免在服务器故障时丢失数据，那么RDB不合适你。</p>
<p><strong>面试官：</strong>那你要不再说下 AOF？</p>
<p><strong>我：</strong>（说就一起说下吧）使用 AOF 做持久化，每一个写命令都通过 write 函数追加到 appendonly.aof 中，配置方式如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">appendfsync yes   </span><br><span class="line">appendfsync always     #每次有数据修改发生时都会写入AOF文件。</span><br><span class="line">appendfsync everysec   #每秒钟同步一次，该策略为AOF的缺省策略。</span><br></pre></td></tr></table></figure>

<p>AOF 可以做到全程持久化，只需要在配置中开启 appendonly yes。这样 Redis 每执行一个修改数据的命令，都会把它添加到 AOF 文件中，当 Redis 重启时，将会读取 AOF 文件进行重放，恢复到 Redis 关闭前的最后时刻。</p>
<p>我顿了一下，继续说：使用 AOF 的<strong>优点</strong>是会让 Redis 变得非常耐久。可以设置不同的 Fsync 策略，AOF的默认策略是每秒钟 Fsync 一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。<strong>缺点</strong>是对于相同的数据集来说，AOF 的文件体积通常要大于 RDB 文件的体积。根据所使用的 Fsync 策略，AOF 的速度可能会慢于 RDB。</p>
<p><strong>面试官又问：</strong>你说了这么多，那我该用哪一个呢？</p>
<p><strong>我：</strong>如果你非常关心你的数据，但仍然可以承受数分钟内的数据丢失，那么可以额只使用 RDB 持久。AOF 将 Redis 执行的每一条命令追加到磁盘中，处理巨大的写入会降低Redis的性能，不知道你是否可以接受。</p>
<p>数据库备份和灾难恢复：定时生成 RDB 快照非常便于进行数据库备份，并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度快。</p>
<p>当然了，Redis 支持同时开启 RDB 和 AOF，系统重启后，Redis 会优先使用 AOF 来恢复数据，这样丢失的数据会最少。</p>
<h1><span id="zhu-cong-fu-zhi">主从复制</span><a href="#zhu-cong-fu-zhi" class="header-anchor"></a></h1><p><strong>面试官：</strong>Redis 单节点存在单点故障问题，为了解决单点问题，一般都需要对 Redis 配置从节点，然后使用哨兵来监听主节点的存活状态，如果主节点挂掉，从节点能继续提供缓存功能，你能说说 Redis 主从复制的过程和原理吗？</p>
<p>我有点懵，这个说来就话长了。但幸好提前准备了：主从配置结合哨兵模式能解决单点故障问题，提高 Redis 可用性。从节点仅提供读操作，主节点提供写操作。对于读多写少的状况，可给主节点配置多个从节点，从而提高响应效率。</p>
<p><strong>我顿了一下，接着说：</strong>关于复制过程，是这样的：</p>
<ul>
<li>从节点执行 slaveof[masterIP][masterPort]，保存主节点信息。</li>
<li>从节点中的定时任务发现主节点信息，建立和主节点的 Socket 连接。</li>
<li>从节点发送 Ping 信号，主节点返回 Pong，两边能互相通信。</li>
<li>连接建立后，主节点将所有数据发送给从节点（数据同步）。</li>
<li>主节点把当前的数据同步给从节点后，便完成了复制的建立过程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。</li>
</ul>
<p><strong>面试官：</strong>那你能详细说下数据同步的过程吗？</p>
<p>（我心想：这也问的太细了吧）我：可以。Redis 2.8 之前使用 sync[runId][offset] 同步命令，Redis 2.8 之后使用 psync[runId][offset] 命令。两者不同在于，Sync 命令仅支持全量复制过程，Psync 支持全量和部分复制。</p>
<p>介绍同步之前，先介绍几个概念：</p>
<ul>
<li><p><strong>runId：</strong>每个 Redis 节点启动都会生成唯一的 uuid，每次 Redis 重启后，runId 都会发生变化。</p>
</li>
<li><p><strong>offset：</strong>主节点和从节点都各自维护自己的主从复制偏移量 offset，当主节点有写入命令时，offset=offset+命令的字节长度。</p>
<p>  从节点在收到主节点发送的命令后，也会增加自己的 offset，并把自己的 offset 发送给主节点。</p>
<p>  这样，主节点同时保存自己的 offset 和从节点的 offset，通过对比 offset 来判断主从节点数据是否一致。</p>
</li>
<li><p><strong>repl_backlog_size：</strong>保存在主节点上的一个固定长度的先进先出队列，默认大小是 1MB。</p>
</li>
</ul>
<p>主节点发送数据给从节点过程中，主节点还会进行一些写操作，这时候的数据存储在复制缓冲区中。</p>
<p>从节点同步主节点数据完成后，主节点将缓冲区的数据继续发送给从节点，用于部分复制。</p>
<p>主节点响应写命令时，不但会把命名发送给从节点，还会写入复制积压缓冲区，用于复制命令丢失的数据补救。</p>
<p>!<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcfmm89d20j30ck08rjre.jpg" alt="img"></p>
<p>上面是 Psync 的执行流程，从节点发送 psync[runId][offset] 命令，主节点有三种响应：</p>
<ul>
<li><strong>FULLRESYNC：</strong>第一次连接，进行全量复制</li>
<li><strong>CONTINUE：</strong>进行部分复制</li>
<li><strong>ERR：</strong>不支持 psync 命令，进行全量复制</li>
</ul>
<p><strong>面试官：</strong>很好，那你能具体说下全量复制和部分复制的过程吗？</p>
<p><strong>我：</strong>可以！</p>
<p>!<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcfmmemu1xj30g70cxmxc.jpg" alt="img"></p>
<p>上面是全量复制的流程。主要有以下几步：</p>
<ul>
<li>从节点发送 psync ? -1 命令（因为第一次发送，不知道主节点的 runId，所以为?，因为是第一次复制，所以 offset=-1）。</li>
<li>主节点发现从节点是第一次复制，返回 FULLRESYNC {runId} {offset}，runId 是主节点的 runId，offset 是主节点目前的 offset。</li>
<li>从节点接收主节点信息后，保存到 info 中。</li>
<li>主节点在发送 FULLRESYNC 后，启动 bgsave 命令，生成 RDB 文件（数据持久化）。</li>
<li>主节点发送 RDB 文件给从节点。到从节点加载数据完成这段期间主节点的写命令放入缓冲区。</li>
<li>从节点清理自己的数据库数据。</li>
<li>从节点加载 RDB 文件，将数据保存到自己的数据库中。如果从节点开启了 AOF，从节点会异步重写 AOF 文件。</li>
</ul>
<p>关于部分复制有以下几点说明：</p>
<p>①部分复制主要是 Redis 针对全量复制的过高开销做出的一种优化措施，使用 psync[runId][offset] 命令实现。</p>
<p>当从节点正在复制主节点时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向主节点要求补发丢失的命令数据，主节点的复制积压缓冲区将这部分数据直接发送给从节点。这样就可以保持主从节点复制的一致性。补发的这部分数据一般远远小于全量数据。</p>
<p>②主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内的复制积压缓冲区依然可以保存最近一段时间的写命令数据。</p>
<p>③当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行 ID。因此会把它们当做 psync 参数发送给主节点，要求进行部分复制。</p>
<p>④主节点接收到 psync 命令后首先核对参数 runId 是否与自身一致，如果一致，说明之前复制的是当前主节点。之后根据参数 offset 在复制积压缓冲区中查找，如果 offset 之后的数据存在，则对从节点发送+COUTINUE 命令，表示可以进行部分复制。因为缓冲区大小固定，若发生缓冲溢出，则进行全量复制。</p>
<p>⑤主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</p>
<h1><span id="shao-bing">哨兵</span><a href="#shao-bing" class="header-anchor"></a></h1><p><strong>面试官：</strong>那主从复制会存在哪些问题呢？</p>
<p><strong>我：</strong>主从复制会存在以下问题：</p>
<ul>
<li><p>一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。</p>
</li>
<li><p>主节点的写能力受到单机的限制。</p>
</li>
<li><p>主节点的存储能力受到单机的限制。</p>
</li>
<li><p>原生复制的弊端在早期的版本中也会比较突出，比如：Redis 复制中断后，从节点会发起 psync。</p>
<p>  此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。</p>
</li>
</ul>
<p><strong>面试官：</strong>那比较主流的解决方案是什么呢？</p>
<p><strong>我：</strong>当然是哨兵啊。</p>
<p><strong>面试官：</strong>那么问题又来了。那你说下哨兵有哪些功能？</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcfmn9awbej30da0fajrq.jpg" alt="img"></p>
<p><strong>我：</strong>如图，是 Redis Sentinel（哨兵）的架构图。Redis Sentinel（哨兵）主要功能包括主节点存活检测、主从运行情况检测、自动故障转移、主从切换。</p>
<p>Redis Sentinel 最小配置是一主一从。Redis 的 Sentinel 系统可以用来管理多个 Redis 服务器。</p>
<p>该系统可以执行以下四个任务：</p>
<ul>
<li><strong>监控：</strong>不断检查主服务器和从服务器是否正常运行。</li>
<li><strong>通知：</strong>当被监控的某个 Redis 服务器出现问题，Sentinel 通过 API 脚本向管理员或者其他应用程序发出通知。</li>
<li><strong>自动故障转移：</strong>当主节点不能正常工作时，Sentinel 会开始一次自动的故障转移操作，它会将与失效主节点是主从关系的其中一个从节点升级为新的主节点，并且将其他的从节点指向新的主节点，这样人工干预就可以免了。</li>
<li><strong>配置提供者：</strong>在 Redis Sentinel 模式下，客户端应用在初始化时连接的是 Sentinel 节点集合，从中获取主节点的信息。</li>
</ul>
<p><strong>面试官：</strong>那你能说下哨兵的工作原理吗？</p>
<p><strong>我：</strong>话不多说，直接上图：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcfmo27og0j30hs0co3yz.jpg" alt="img"></p>
<p>①每个 Sentinel 节点都需要定期执行以下任务：每个 Sentinel 以每秒一次的频率，向它所知的主服务器、从服务器以及其他的 Sentinel 实例发送一个 PING 命令。（如上图）</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcfmoanq0bj30hs0deq3g.jpg" alt="img"></p>
<p>②如果一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 所指定的值，那么这个实例会被 Sentinel 标记为主观下线。（如上图）</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcfmohmkdlj30hs0de74t.jpg" alt="img"></p>
<p>③如果一个主服务器被标记为主观下线，那么正在监视这个服务器的所有 Sentinel 节点，要以每秒一次的频率确认主服务器的确进入了主观下线状态。</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcfmomu9s7j30hs0dedgd.jpg" alt="img"></p>
<p>④如果一个主服务器被标记为主观下线，并且有足够数量的 Sentinel（至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断，那么这个主服务器被标记为客观下线。</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcfmossm10j30hs0c3wf1.jpg" alt="img"></p>
<p>⑤一般情况下，每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO 命令。</p>
<p>当一个主服务器被标记为客观下线时，Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率，会从 10 秒一次改为每秒一次。</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcfmp3ntqgj30hs0dg74s.jpg" alt="img"></p>
<p>⑥Sentinel 和其他 Sentinel 协商客观下线的主节点的状态，如果处于 SDOWN 状态，则投票自动选出新的主节点，将剩余从节点指向新的主节点进行数据复制。</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcfmp8p9nvj30hs06t3yq.jpg" alt="img"></p>
<p>⑦当没有足够数量的 Sentinel 同意主服务器下线时，主服务器的客观下线状态就会被移除。当主服务器重新向 Sentinel 的 PING 命令返回有效回复时，主服务器的主观下线状态就会被移除。</p>
<p><strong>面试官：</strong>不错，面试前没少下工夫啊，今天 Redis 这关你过了，明天找个时间我们再聊聊其他的。（露出欣慰的微笑）</p>
<p><strong>我：</strong>没问题。</p>
<h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h1><p>本文在一次面试的过程中讲述了 Redis 是什么，Redis 的特点和功能，Redis 缓存的使用，Redis 为什么能这么快，Redis 缓存的淘汰策略，持久化的两种方式，Redis 高可用部分的主从复制和哨兵的基本原理。</p>
<p>只要功夫深，铁杵磨成针，平时准备好，面试不用慌。虽然面试不一定是这样问的，但万变不离其“宗”。</p>
]]></content>
      <categories>
        <category>CODING</category>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】redis.conf配置文件中文版</title>
    <url>/2020/01/01/CODING/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E3%80%90%E8%AF%91%E3%80%91redis.conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E6%96%87%E7%89%88/</url>
    <content><![CDATA[<blockquote>
<p>我将Redis.conf配置文件通过Google翻译成中文，在查看使用时进行一定的修改校准，以便配置参考</p>
</blockquote>
<div class="toc">

<!-- toc -->



<!-- tocstop -->

</div>
<a id="more"></a>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">＃Redis配置文件示例。</span><br><span class="line">＃</span><br><span class="line">＃注意，为了读取配置文件，Redis必须是</span><br><span class="line">＃以文件路径作为第一个参数开头：</span><br><span class="line">＃</span><br><span class="line">＃.&#x2F;redis-server &#x2F;path&#x2F;to&#x2F;redis.conf</span><br><span class="line"></span><br><span class="line">＃关于单位的注释：需要内存大小时，可以指定</span><br><span class="line">＃以通常的1k 5GB 4M格式，依此类推：</span><br><span class="line">＃</span><br><span class="line">＃1k &#x3D;&gt; 1000字节</span><br><span class="line">＃1kb &#x3D;&gt; 1024字节</span><br><span class="line">＃1m &#x3D;&gt; 1000000字节</span><br><span class="line">＃1mb &#x3D;&gt; 1024 * 1024字节</span><br><span class="line">＃1g &#x3D;&gt; 1000000000字节</span><br><span class="line">＃1gb &#x3D;&gt; 1024 * 1024 * 1024字节</span><br><span class="line">＃</span><br><span class="line">＃单位不区分大小写，因此1GB 1Gb 1gB都相同。</span><br><span class="line"></span><br><span class="line">############################### INCLUDES ###################################</span><br><span class="line"></span><br><span class="line">＃在此处包含一个或多个其他配置文件。如果您</span><br><span class="line">＃具有可用于所有Redis服务器的标准模板，但也需要</span><br><span class="line">＃自定义一些每服务器设置。包含文件可以包括</span><br><span class="line">＃个其他文件，因此请明智地使用此文件。</span><br><span class="line">＃</span><br><span class="line">＃注意选项“ include”不会被命令“ CONFIG REWRITE”重写</span><br><span class="line">＃来自admin或Redis Sentinel。由于Redis始终使用最后处理的</span><br><span class="line">＃将line作为配置指令的值，最好将include</span><br><span class="line">＃在此文件的开头，以避免在运行时覆盖配置更改。</span><br><span class="line">＃</span><br><span class="line">＃如果您有兴趣使用include覆盖配置</span><br><span class="line">＃选项，最好使用include作为最后一行。</span><br><span class="line">＃</span><br><span class="line">＃包括&#x2F;path&#x2F;to&#x2F;local.conf</span><br><span class="line">＃包括&#x2F;path&#x2F;to&#x2F;other.conf</span><br><span class="line"></span><br><span class="line">#################################模块############### ######################</span><br><span class="line"></span><br><span class="line">＃在启动时加载模块。如果服务器无法加载模块</span><br><span class="line">＃它会中止。可以使用多个loadmodule指令。</span><br><span class="line">＃</span><br><span class="line">＃loadmodule &#x2F;path&#x2F;to&#x2F;my_module.so</span><br><span class="line">＃loadmodule &#x2F;path&#x2F;to&#x2F;other_module.so</span><br><span class="line"></span><br><span class="line">################################ NETWORK ############### ######################</span><br><span class="line"></span><br><span class="line">＃默认情况下，如果未指定“ bind”配置指令，则Redis侦听</span><br><span class="line">＃用于来自服务器上所有可用网络接口的连接。</span><br><span class="line">＃使用以下命令可以只收听一个或多个选定的接口</span><br><span class="line">＃“ bind”配置指令，后接一个或多个IP地址。</span><br><span class="line">＃</span><br><span class="line">＃ 例子：</span><br><span class="line">＃</span><br><span class="line">＃绑定192.168.1.100 10.0.0.1</span><br><span class="line">＃绑定127.0.0.1 :: 1</span><br><span class="line">＃</span><br><span class="line">＃~~~警告~~~如果运行Redis的计算机直接暴露于</span><br><span class="line">＃互联网，绑定到所有接口都是危险的，并且会暴露</span><br><span class="line">＃实例给互联网上的所有人。因此，默认情况下，我们取消注释</span><br><span class="line">＃遵循bind指令，这将强制Redis仅侦听</span><br><span class="line">＃IPv4环回接口地址（这意味着Redis将能够</span><br><span class="line">＃只接受来自同一台计算机上运行的客户端的连接</span><br><span class="line">＃ 在跑）。</span><br><span class="line">＃</span><br><span class="line">＃如果您确定要实例化来监听所有接口</span><br><span class="line">＃只需注意以下几行。</span><br><span class="line">＃~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">绑定127.0.0.1</span><br><span class="line"></span><br><span class="line">＃保护模式是一层安全保护，以避免</span><br><span class="line">＃可以访问和利用Internet上打开的Redis实例。</span><br><span class="line">＃</span><br><span class="line">＃启用保护模式时，如果：</span><br><span class="line">＃</span><br><span class="line">＃1）服务器未使用以下命令明确绑定到一组地址</span><br><span class="line">＃“ bind”指令。</span><br><span class="line">＃2）未配置密码。</span><br><span class="line">＃</span><br><span class="line">＃服务器仅接受来自客户端的连接，该客户端从</span><br><span class="line">＃IPv4和IPv6回送地址127.0.0.1和:: 1，并且来自Unix域</span><br><span class="line">＃个套接字。</span><br><span class="line">＃</span><br><span class="line">＃默认情况下启用保护模式。只有在以下情况下才应禁用它</span><br><span class="line">＃您确定要让其他主机的客户端连接到Redis</span><br><span class="line">＃即使未配置身份验证，也没有特定的接口集</span><br><span class="line">＃使用“ bind”指令显式列出。</span><br><span class="line">保护模式是</span><br><span class="line"></span><br><span class="line">＃接受指定端口上的连接，默认值为6379（IANA＃815344）。</span><br><span class="line">＃如果指定了端口0，则Redis将不会在TCP套接字上侦听。</span><br><span class="line">端口6379</span><br><span class="line"></span><br><span class="line">＃TCP listen（）积压。</span><br><span class="line">＃</span><br><span class="line">＃在每秒请求数很高的环境中，您需要大量积压订单</span><br><span class="line">＃避免客户端连接速度慢的问题。注意Linux内核</span><br><span class="line">＃将默默地将其截断为&#x2F; proc &#x2F; sys &#x2F; net &#x2F; core &#x2F; somaxconn的值，因此</span><br><span class="line">＃确保同时提高somaxconn和tcp_max_syn_backlog的值</span><br><span class="line">＃以获得预期的效果。</span><br><span class="line">tcp积压511</span><br><span class="line"></span><br><span class="line">＃Unix套接字。</span><br><span class="line">＃</span><br><span class="line">＃指定用于监听的Unix套接字的路径</span><br><span class="line">＃传入连接。没有默认设置，因此Redis不会收听</span><br><span class="line">＃如果未指定，则在UNIX套接字上。</span><br><span class="line">＃</span><br><span class="line">＃unixsocket &#x2F;tmp&#x2F;redis.sock</span><br><span class="line">＃unixsocketperm 700</span><br><span class="line"></span><br><span class="line">＃客户端闲置N秒后关闭连接（0禁用）</span><br><span class="line">超时0</span><br><span class="line"></span><br><span class="line">＃TCP保持活动状态。</span><br><span class="line">＃</span><br><span class="line">＃如果不为零，请使用SO_KEEPALIVE向不存在的客户端发送TCP ACK</span><br><span class="line">通信数量。这很有用，原因有两个：</span><br><span class="line">＃</span><br><span class="line">＃1）检测死亡的同伴。</span><br><span class="line">＃2）从网络角度使连接活跃起来</span><br><span class="line">＃设备在中间。</span><br><span class="line">＃</span><br><span class="line">＃在Linux上，指定的值（以秒为单位）是用于发送ACK的时间段。</span><br><span class="line">＃请注意，关闭连接需要两倍的时间。</span><br><span class="line">＃在其他内核上，期限取决于内核配置。</span><br><span class="line">＃</span><br><span class="line">＃此选项的合理值为300秒，这是新的</span><br><span class="line">＃Redis默认从Redis 3.2.1开始。</span><br><span class="line">tcp-keepalive 300</span><br><span class="line"></span><br><span class="line">＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃ 一般 ＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃ #####################</span><br><span class="line"></span><br><span class="line">＃默认情况下，Redis不会作为守护程序运行。如果需要，请使用“是”。</span><br><span class="line">＃请注意，Redis守护进程将在&#x2F;var&#x2F;run&#x2F;redis.pid中写入一个pid文件。</span><br><span class="line">守护是</span><br><span class="line"></span><br><span class="line">＃如果您是从upstart或systemd运行Redis，则Redis可以与您的</span><br><span class="line">＃监督树。选项：</span><br><span class="line">＃无监督-无监督互动</span><br><span class="line">＃受监督的新贵-通过将Redis置于SIGSTOP模式来指示新贵</span><br><span class="line">＃受监督的systemd-通过将READY &#x3D; 1写入$ NOTIFY_SOCKET来发出信号systemd</span><br><span class="line">＃有监督的自动-基于以下命令检测暴发户或系统方法</span><br><span class="line">＃UPSTART_JOB或NOTIFY_SOCKET环境变量</span><br><span class="line">＃注意：这些监视方法仅表示“过程已准备就绪”。</span><br><span class="line">＃他们无法使您的主管连续不断地进行ping操作。</span><br><span class="line">有监督</span><br><span class="line"></span><br><span class="line">＃如果指定了pid文件，则Redis会在启动时将其写入指定位置</span><br><span class="line">＃并在出口处将其删除。</span><br><span class="line">＃</span><br><span class="line">＃当服务器以非守护进程运行时，如果没有，则不创建pid文件</span><br><span class="line">＃在配置中指定。守护服务器时，pid文件</span><br><span class="line">即使未指定，也使用＃，默认为“ &#x2F;var&#x2F;run&#x2F;redis.pid”。</span><br><span class="line">＃</span><br><span class="line">＃尽力创建一个pid文件：如果Redis无法创建它</span><br><span class="line">＃一切正常，服务器将启动并正常运行。</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid</span><br><span class="line"></span><br><span class="line">＃指定服务器的详细级别。</span><br><span class="line">＃这可以是以下之一：</span><br><span class="line">＃调试（很多信息，对于开发&#x2F;测试很有用）</span><br><span class="line">＃详细（很多很少有用的信息，但不会像调试级别那样混乱）</span><br><span class="line">＃通知（适度冗长，可能在生产中需要什么）</span><br><span class="line">＃警告（仅记录非常重要&#x2F;重要的消息）</span><br><span class="line">日志级别通知</span><br><span class="line"></span><br><span class="line">＃指定日志文件名。也可以使用空字符串强制</span><br><span class="line">＃Redis登录到标准输出。请注意，如果您使用标准</span><br><span class="line">＃输出用于日志记录但要守护进程，日志将发送到&#x2F; dev &#x2F; null</span><br><span class="line">日志文件“”</span><br><span class="line"></span><br><span class="line">＃要启用到系统记录器的日志记录，只需将&#39;syslog-enabled&#39;设置为yes，</span><br><span class="line">＃并根据需要更新其他syslog参数。</span><br><span class="line">＃启用syslog否</span><br><span class="line"></span><br><span class="line">＃指定系统日志标识。</span><br><span class="line">＃syslog-ident redis</span><br><span class="line"></span><br><span class="line">＃指定系统日志工具。必须是USER或LOCAL0-LOCAL7之间。</span><br><span class="line">＃syslog-facility local0</span><br><span class="line"></span><br><span class="line">＃设置数据库数量。默认数据库为DB 0，可以选择</span><br><span class="line">＃使用SELECT &lt;dbid&gt;在每个连接的基础上不同</span><br><span class="line">＃dbid是介于0和&#39;databases&#39;-1之间的数字</span><br><span class="line">数据库16</span><br><span class="line"></span><br><span class="line">＃默认情况下，Redis仅在开始登录时才显示ASCII艺术徽标。</span><br><span class="line">＃标准输出，如果标准输出是TTY。基本上这意味着</span><br><span class="line">＃通常徽标仅在交互式会话中显示。</span><br><span class="line">＃</span><br><span class="line">＃但是可以强制4.0之前的行为并始终显示</span><br><span class="line">＃通过将以下选项设置为yes，在启动日志中使用ASCII艺术徽标。</span><br><span class="line">总是显示徽标是</span><br><span class="line"></span><br><span class="line">##############################快照################# ###############</span><br><span class="line">＃</span><br><span class="line">＃将数据库保存在磁盘上：</span><br><span class="line">＃</span><br><span class="line">＃保存&lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">＃</span><br><span class="line">＃如果给定的秒数和给定的秒数都将保存数据库</span><br><span class="line">＃针对数据库的写入操作数。</span><br><span class="line">＃</span><br><span class="line">＃在下面的示例中，行为将是保存：</span><br><span class="line">＃在900秒（15分钟）后，如果至少更改了1个键</span><br><span class="line">＃300秒（5分钟）后，如果至少更改了10个按键</span><br><span class="line">＃60秒后，如果至少更改了10000个键</span><br><span class="line">＃</span><br><span class="line">＃注意：您可以通过注释掉所有“保存”行来完全禁用保存。</span><br><span class="line">＃</span><br><span class="line">＃也可以删除所有先前配置的保存</span><br><span class="line">＃通过添加带有单个空字符串参数的save指令来积分</span><br><span class="line">＃如以下示例所示：</span><br><span class="line">＃</span><br><span class="line">＃   保存 ””</span><br><span class="line"></span><br><span class="line">节省900 1</span><br><span class="line">节省300 10</span><br><span class="line">节省60 10000</span><br><span class="line"></span><br><span class="line">＃默认情况下，如果启用RDB快照，Redis将停止接受写入</span><br><span class="line">＃（至少一个保存点），并且最新的后台保存失败。</span><br><span class="line">＃这将使用户（很难）意识到数据没有持久化</span><br><span class="line">＃正确地放在磁盘上，否则没有人会注意到，有的机会</span><br><span class="line">＃灾难将会发生。</span><br><span class="line">＃</span><br><span class="line">＃如果后台保存过程将再次开始工作，则Redis将</span><br><span class="line">＃自动允许再次写入。</span><br><span class="line">＃</span><br><span class="line">＃但是，如果您已经设置了对Redis服务器的适当监视</span><br><span class="line">＃和持久性，您可能要禁用此功能，以便Redis将</span><br><span class="line">＃即使磁盘出现问题，仍继续照常工作，</span><br><span class="line">＃权限，依此类推。</span><br><span class="line">停止写在bgsave错误是</span><br><span class="line"></span><br><span class="line">＃转储.rdb数据库时使用LZF压缩字符串对象？</span><br><span class="line">＃默认情况下将其设置为“是”，因为它几乎总是胜利。</span><br><span class="line">＃如果要在保存子项中保存一些CPU，请将其设置为&#39;no&#39;，但是</span><br><span class="line">＃如果您具有可压缩的值或键，则数据集可能会更大。</span><br><span class="line">rdbcompression是</span><br><span class="line"></span><br><span class="line">＃从RDB版本5开始，在文件末尾放置了CRC64校验和。</span><br><span class="line">＃这样可以使格式更耐腐败，但性能</span><br><span class="line">＃在保存和加载RDB文件时点击支付（大约10％），因此您可以将其禁用</span><br><span class="line">＃以获得最佳性能。</span><br><span class="line">＃</span><br><span class="line">＃在禁用校验和的情况下创建的RDB文件的校验和为零，这将使</span><br><span class="line">＃告诉加载代码跳过检查。</span><br><span class="line">rdbchecksum是</span><br><span class="line"></span><br><span class="line">＃转储数据库的文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">＃工作目录。</span><br><span class="line">＃</span><br><span class="line">＃数据库将被写入此目录，并指定文件名</span><br><span class="line">＃以上使用&#39;dbfilename&#39;配置指令。</span><br><span class="line">＃</span><br><span class="line">＃也将在此目录中创建仅附加文件。</span><br><span class="line">＃</span><br><span class="line">＃请注意，您必须在此处指定目录，而不是文件名。</span><br><span class="line">目录.&#x2F;</span><br><span class="line"></span><br><span class="line">############################### REPLICATION ################ #################</span><br><span class="line"></span><br><span class="line">＃主副本复制。使用copyof作为Redis实例的副本</span><br><span class="line">＃另一个Redis服务器。尽快了解有关Redis复制的几件事。</span><br><span class="line">＃</span><br><span class="line">＃+ ------------------ + + --------------- +</span><br><span class="line">＃|硕士---&gt; |复制品|</span><br><span class="line">＃| （接收写入）| | （精确副本）|</span><br><span class="line">＃+ ------------------ + + --------------- +</span><br><span class="line">＃</span><br><span class="line">＃1）Redis复制是异步的，但是您可以将master配置为</span><br><span class="line">＃如果至少看起来没有连接，则停止接受写入</span><br><span class="line">＃给定数量的副本。</span><br><span class="line">＃2）Redis副本能够与以下组件执行部分重新同步</span><br><span class="line">＃master（如果复制链接丢失了相对较少的数量）</span><br><span class="line">＃    时间。您可能需要配置复制积压大小（请参阅下一个</span><br><span class="line">此文件的＃个部分），根据您的需要具有合理的价值。</span><br><span class="line">＃3）复制是自动的，不需要用户干预。之后</span><br><span class="line">＃网络分区副本自动尝试重新连接到主数据库</span><br><span class="line">＃并与它们重新同步。</span><br><span class="line">＃</span><br><span class="line">＃复制&lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line">＃如果主服务器受密码保护（使用“ requirepass”配置）</span><br><span class="line">下面的＃指令）可以告诉副本在进行身份验证之前</span><br><span class="line">＃启动复制同步过程，否则主服务器将</span><br><span class="line">＃拒绝副本请求。</span><br><span class="line">＃</span><br><span class="line">＃masterauth &lt;主密码&gt;</span><br><span class="line"></span><br><span class="line">＃副本失去与主数据库的连接或复制时</span><br><span class="line">＃仍在进行中，副本可以以两种不同的方式起作用：</span><br><span class="line">＃</span><br><span class="line">＃1）如果复制副本服务过时数据设置为“是”（默认值），则复制副本将</span><br><span class="line">＃仍然会回复客户的请求，可能包含过期的数据，或者</span><br><span class="line">如果这是第一次同步，则＃数据集可能只是空的。</span><br><span class="line">＃</span><br><span class="line">＃2）如果复制副本服务过时数据设置为“否”，复制副本将回复</span><br><span class="line">＃对所有类型的命令均出现错误“正在与主机进行同步”</span><br><span class="line">＃，但要设置为INFO，replicaOF，AUTH，PING，SHUTDOWN，REPLCONF，ROLE，CONFIG，</span><br><span class="line">＃SUBSCRIBE，UNSUBSCRIBE，PSUBSCRIBE，PUNSUBSCRIBE，PUBLISH，PUBSUB，</span><br><span class="line">＃COMMAND，POST，HOST：和延迟。</span><br><span class="line">＃</span><br><span class="line">复制服务过时数据是</span><br><span class="line"></span><br><span class="line">＃您可以配置副本实例以接受或不接受写入。反对</span><br><span class="line">＃复制副本实例可能有助于存储一些临时数据（因为数据</span><br><span class="line">与主服务器重新同步后，写在副本上的＃将很容易删除），但是</span><br><span class="line">如果客户由于以下原因写信，＃也会引起问题。</span><br><span class="line">＃配置错误。</span><br><span class="line">＃</span><br><span class="line">＃由于Redis 2.6默认情况下，副本是只读的。</span><br><span class="line">＃</span><br><span class="line">＃注意：只读副本并非旨在向不受信任的客户端公开</span><br><span class="line">＃ 在网上。它只是防止实例滥用的保护层。</span><br><span class="line">＃默认仍然是只读副本导出所有管理命令</span><br><span class="line">＃，例如CONFIG，DEBUG等。在一定程度上您可以改善</span><br><span class="line">＃使用&#39;rename-command&#39;隐藏所有副本的只读副本的安全性</span><br><span class="line">＃行政&#x2F;危险命令。</span><br><span class="line">副本只读是</span><br><span class="line"></span><br><span class="line">＃复制同步策略：磁盘或套接字。</span><br><span class="line">＃</span><br><span class="line">＃------------------------------------------------- ------</span><br><span class="line">＃警告：目前，抄袭是实验性的</span><br><span class="line">＃------------------------------------------------- ------</span><br><span class="line">＃</span><br><span class="line">＃无法继续复制的新副本和重新连接的副本</span><br><span class="line">＃过程刚刚收到差异，需要做的是所谓的“充分”</span><br><span class="line">＃同步”。RDB文件从主数据库传输到副本。</span><br><span class="line">＃传输可以两种不同的方式发生：</span><br><span class="line">＃</span><br><span class="line">＃1）支持磁盘：Redis主服务器创建一个新过程，该过程写入RDB</span><br><span class="line">＃文件在磁盘上。之后文件由父级传输</span><br><span class="line">＃逐步处理副本。</span><br><span class="line">＃2）无盘：Redis主服务器创建一个新进程，该进程直接写入</span><br><span class="line">＃将RDB文件复制到副本套接字，而完全不接触磁盘。</span><br><span class="line">＃</span><br><span class="line">＃使用磁盘支持的复制时，在生成RDB文件时，会有更多副本</span><br><span class="line">当前子项产生后，＃可以排队并与RDB文件一起使用</span><br><span class="line">＃RDB文件完成工作。使用无盘复制一次</span><br><span class="line">＃传输开始，新副本将进入队列，并且新传输</span><br><span class="line">＃将在当前终止时开始。</span><br><span class="line">＃</span><br><span class="line">＃使用无盘复制时，主服务器等待可配置数量的</span><br><span class="line">＃开始传输之前的时间（以秒为单位），希望有多个副本</span><br><span class="line">＃将到达，传输可以并行化。</span><br><span class="line">＃</span><br><span class="line">＃使用慢速磁盘和快速（大带宽）网络，进行无盘复制</span><br><span class="line">＃效果更好。</span><br><span class="line">repl-diskless-sync否</span><br><span class="line"></span><br><span class="line">＃启用无盘复制后，可以配置延迟</span><br><span class="line">＃服务器等待以生成通过套接字传输RDB的子代</span><br><span class="line">＃复制到副本。</span><br><span class="line">＃</span><br><span class="line">＃这很重要，因为一旦转移开始，就无法提供服务</span><br><span class="line">＃个新副本到达，将排队等待下一次RDB传输，因此服务器</span><br><span class="line">＃等待延迟以便让更多副本到达。</span><br><span class="line">＃</span><br><span class="line">＃延迟以秒为单位指定，默认为5秒。禁用</span><br><span class="line">＃完全将其设置为0秒，传输将尽快开始。</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line">＃副本以预定义的时间间隔将PING发送到服务器。有可能改变</span><br><span class="line">＃使用repl_ping_replica_period选项设置此间隔。预设值为10</span><br><span class="line">＃秒。</span><br><span class="line">＃</span><br><span class="line">＃repl-ping-replica-period 10</span><br><span class="line"></span><br><span class="line">＃以下选项为以下项设置复制超时：</span><br><span class="line">＃</span><br><span class="line">＃1）从副本的角度来看，在SYNC期间进行批量传输I &#x2F; O。</span><br><span class="line">＃2）从副本（数据，ping）的角度来看，主超时。</span><br><span class="line">＃3）从主服务器的角度来看副本超时（REPLCONF ACK ping）。</span><br><span class="line">＃</span><br><span class="line">＃重要的是要确保该值大于该值</span><br><span class="line">＃为repl-ping-replica-period指定，否则将检测到超时</span><br><span class="line">＃每次主服务器和副本服务器之间的流量较低时。</span><br><span class="line">＃</span><br><span class="line">＃repl-timeout 60</span><br><span class="line"></span><br><span class="line">＃在SYNC之后禁用副本套接字上的TCP_NODELAY？</span><br><span class="line">＃</span><br><span class="line">＃如果选择“是”，则Redis将使用较少数量的TCP数据包，并且</span><br><span class="line">＃减少将数据发送到副本的带宽。但这可能会增加</span><br><span class="line">＃出现在副本端的数据，最长40毫秒，</span><br><span class="line">＃Linux内核使用默认配置。</span><br><span class="line">＃</span><br><span class="line">＃如果选择“否”，则数据在副本端出现的延迟将</span><br><span class="line">＃减少但更多带宽将用于复制。</span><br><span class="line">＃</span><br><span class="line">＃默认情况下，我们针对低延迟进行了优化，但在流量非常高的情况下</span><br><span class="line">＃或在距离主副本和副本很多跳的情况下，将其设置为“是”可能</span><br><span class="line">＃成为一个好主意。</span><br><span class="line">repl-disable-tcp-nodelay否</span><br><span class="line"></span><br><span class="line">＃设置复制积压大小。积压是积累的缓冲区</span><br><span class="line">＃副本断开连接一段时间后的副本数据，因此当副本</span><br><span class="line">＃想重新连接，通常不需要完全重新同步，但需要部分重新同步</span><br><span class="line">＃resync就足够了，只需传递副本中丢失的部分数据</span><br><span class="line">＃断开连接。</span><br><span class="line">＃</span><br><span class="line">＃复制待办事项越大，副本可以停留的时间越长</span><br><span class="line">＃已断开连接，以后可以执行部分​​重新同步。</span><br><span class="line">＃</span><br><span class="line">＃仅在至少有一个副本连接后才分配积压。</span><br><span class="line">＃</span><br><span class="line">＃repl-backlog-size 1mb</span><br><span class="line"></span><br><span class="line">＃在主服务器一段时间不再连接副本后，积压</span><br><span class="line">＃将被释放。以下选项配置了秒数</span><br><span class="line">从最后一个副本断开连接的时间开始需要＃</span><br><span class="line">＃待释放的待办事项缓冲区。</span><br><span class="line">＃</span><br><span class="line">＃请注意，副本永远不会释放积压超时，因为它们可能是</span><br><span class="line">＃稍后晋升为大师，应该能够正确地“部分</span><br><span class="line">＃resyncize”与副本：因此它们应始终积累积压。</span><br><span class="line">＃</span><br><span class="line">＃值0表示从不释放积压。</span><br><span class="line">＃</span><br><span class="line">＃repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line">＃副本优先级是Redis在INFO输出中发布的整数。</span><br><span class="line">＃Redis Sentinel使用它来选择要升级为副本的副本。</span><br><span class="line">＃master（如果主机不再正常工作）。</span><br><span class="line">＃</span><br><span class="line">＃优先级低的副本更适合升级，因此</span><br><span class="line">＃例如，如果有三个副本的优先级分别为10、100、25，Sentinel将</span><br><span class="line">＃选择一个优先级为10的优先级最低的优先级。</span><br><span class="line">＃</span><br><span class="line">＃但是，特殊优先级0表示副本无法执行</span><br><span class="line">＃为主角色，因此优先级为0的副本永远不会被</span><br><span class="line">＃Redis前哨升级。</span><br><span class="line">＃</span><br><span class="line">＃默认情况下，优先级为100。</span><br><span class="line">副本优先级100</span><br><span class="line"></span><br><span class="line">＃如果少于以下数量，则主服务器可能会停止接受写入</span><br><span class="line">已连接N个副本，延迟小于或等于M秒。</span><br><span class="line">＃</span><br><span class="line">＃N个副本必须处于“联机”状态。</span><br><span class="line">＃</span><br><span class="line">＃必须以秒为单位的滞后时间必须小于等于指定值，计算公式为</span><br><span class="line">＃从副本接收到的最后ping，通常每秒发送一次。</span><br><span class="line">＃</span><br><span class="line">＃此选项不能保证N个副本将接受写入，但是</span><br><span class="line">＃如果副本数量不足，则会限制丢失写入的窗口</span><br><span class="line">＃可用，以指定的秒数为单位。</span><br><span class="line">＃</span><br><span class="line">＃例如，要求至少3个副本的延迟&lt;&#x3D; 10秒，请使用：</span><br><span class="line">＃</span><br><span class="line">＃min-replicas-to-write 3</span><br><span class="line">＃min-replicas-max-lag 10</span><br><span class="line">＃</span><br><span class="line">＃将一个或另一个设置为0将禁用该功能。</span><br><span class="line">＃</span><br><span class="line">＃默认情况下，min-replicas-to-write设置为0（禁用功能），并且</span><br><span class="line">＃min-replicas-max-lag设置为10。</span><br><span class="line"></span><br><span class="line">＃Redis主服务器能够列出连接的地址和端口</span><br><span class="line">＃以不同方式复制。例如，“ INFO复制”部分</span><br><span class="line">＃提供此信息，除其他工具外，该信息由</span><br><span class="line">＃Redis Sentinel以发现副本实例。</span><br><span class="line">＃此信息可用的另一个地方是</span><br><span class="line">＃主机的“ ROLE”命令。</span><br><span class="line">＃</span><br><span class="line">＃获取通常由副本报告的列出的IP和地址</span><br><span class="line">＃以下列方式：</span><br><span class="line">＃</span><br><span class="line">＃IP：通过检查对等地址自动检测到该地址</span><br><span class="line">副本用于与主服务器连接的套接字的编号。</span><br><span class="line">＃</span><br><span class="line">＃端口：端口在复制过程中由副本进行通信</span><br><span class="line">＃握手，通常是副本使用的端口</span><br><span class="line">＃监听连接。</span><br><span class="line">＃</span><br><span class="line">＃但是，当端口转发或网络地址转换（NAT）为</span><br><span class="line">＃使用，副本实际上可以通过不同的IP和端口访问</span><br><span class="line">＃对。副本可以使用以下两个选项，以便</span><br><span class="line">＃向其主控报告一组特定的IP和端口，以便双方</span><br><span class="line">＃和ROLE将报告这些值。</span><br><span class="line">＃</span><br><span class="line">＃如果您只需要覆盖两个选项，则无需同时使用这两个选项</span><br><span class="line">＃端口或IP地址。</span><br><span class="line">＃</span><br><span class="line">＃副本公告IP 5.5.5.5</span><br><span class="line">＃副本通告端口1234</span><br><span class="line"></span><br><span class="line">################################# SECURITY ################ ####################</span><br><span class="line"></span><br><span class="line">＃要求客户端在处理其他任何内容之前发出AUTH &lt;PASSWORD&gt;</span><br><span class="line">＃条命令。这在您不信任的环境中可能很有用</span><br><span class="line">＃其他有权访问运行redis-server的主机。</span><br><span class="line">＃</span><br><span class="line">＃为了保持向后兼容性，应该保留此注释，因为大多数</span><br><span class="line">＃个人不需要身份验证（例如，他们运行自己的服务器）。</span><br><span class="line">＃</span><br><span class="line">＃警告：由于Redis相当快，外部用户可以尝试</span><br><span class="line">＃一个好的盒子每秒可输入150k密码。这意味着你应该</span><br><span class="line">＃使用非常强的密码，否则将很容易被破解。</span><br><span class="line">＃</span><br><span class="line">＃requirepass foobared</span><br><span class="line"></span><br><span class="line">＃命令重命名。</span><br><span class="line">＃</span><br><span class="line">＃可以在共享中更改危险命令的名称</span><br><span class="line">＃ 环境。例如，可以将CONFIG命令重命名为某些内容</span><br><span class="line">＃难以猜测，因此仍可供内部使用工具使用</span><br><span class="line">＃但不适用于一般客户。</span><br><span class="line">＃</span><br><span class="line">＃示例：</span><br><span class="line">＃</span><br><span class="line">＃重命名命令CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line">＃</span><br><span class="line">＃也可以通过将命令重命名为命令来完全杀死命令</span><br><span class="line">＃一个空字符串：</span><br><span class="line">＃</span><br><span class="line">＃重命名命令CONFIG“”</span><br><span class="line">＃</span><br><span class="line">＃请注意，更改登录到</span><br><span class="line">＃AOF文件或传输到副本可能会导致问题。</span><br><span class="line"></span><br><span class="line">################################# CLIENTS ############### ######################</span><br><span class="line"></span><br><span class="line">＃设置同时连接的最大客户端数。默认情况下</span><br><span class="line">＃此限制设置为10000个客户端，但是如果Redis服务器不是</span><br><span class="line">＃能够配置进程文件限制以允许指定的限制</span><br><span class="line">＃允许的最大客户端数量设置为当前文件限制</span><br><span class="line">＃减32（因为Redis保留了一些文件描述符供内部使用）。</span><br><span class="line">＃</span><br><span class="line">＃一旦达到限制，Redis将关闭所有新发送的连接</span><br><span class="line">＃错误“达到最大客户端数”。</span><br><span class="line">＃</span><br><span class="line">＃maxclients 10000</span><br><span class="line"></span><br><span class="line">＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃ 内存管理 ＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃ ##############</span><br><span class="line"></span><br><span class="line">＃设置内存使用限制为指定的字节数。</span><br><span class="line">＃当达到内存限制时，Redis将尝试删除密钥</span><br><span class="line">＃根据选择的搬迁策略（请参阅maxmemory-policy）。</span><br><span class="line">＃</span><br><span class="line">＃如果Redis无法根据策略删除密钥，或者策略为</span><br><span class="line">＃设置为&#39;noeviction&#39;，Redis将开始回复命令错误</span><br><span class="line">＃将使用更多的内存，例如SET，LPUSH等，并将继续</span><br><span class="line">＃回复诸如GET之类的只读命令。</span><br><span class="line">＃</span><br><span class="line">＃当将Redis用作LRU或LFU缓存或将</span><br><span class="line">＃设置实例的硬盘限制（使用“ noeviction”策略）。</span><br><span class="line">＃</span><br><span class="line">＃警告：如果您将副本附加到实例上且具有maxmemory，</span><br><span class="line">＃减去提供副本所需的输出缓冲区的大小</span><br><span class="line">＃从已用的内存数量开始，以便网络问题&#x2F;重新同步</span><br><span class="line">＃不触发退出键的循环，反过来输出</span><br><span class="line">＃副本缓冲区已满，有逐出的DEL键触发删除</span><br><span class="line">＃更多密钥，依此类推，直到数据库完全清空。</span><br><span class="line">＃</span><br><span class="line">＃简而言之...如果您附加了副本，建议您设置一个较低的</span><br><span class="line">＃maxmaxmory的限制，以便系统上有一些可用的RAM用于复制</span><br><span class="line">＃个输出缓冲区（但是，如果策略为“ noeviction”，则不需要这样做）。</span><br><span class="line">＃</span><br><span class="line">＃maxmemory &lt;字节&gt;</span><br><span class="line"></span><br><span class="line">＃MAXMEMORY POLICY：当maxmemory时，Redis如何选择要删除的内容</span><br><span class="line">＃ 到达了。您可以选择以下五种行为：</span><br><span class="line">＃</span><br><span class="line">＃volatile-lru-&gt;使用具有过期集的密钥中的近似LRU进行驱逐。</span><br><span class="line">＃allkeys-lru-&gt;使用近似的LRU退出任何密​​钥。</span><br><span class="line">＃volatile-lfu-&gt;使用具有过期集的键中的近似LFU退出。</span><br><span class="line">＃allkeys-lfu-&gt;使用近似的LFU退出任何密​​钥。</span><br><span class="line">＃volatile-random-&gt;从具有过期集的密钥中删除一个随机密钥。</span><br><span class="line">＃allkeys-random-&gt;删除随机密钥，任何密钥。</span><br><span class="line">＃volatile-ttl-&gt;删除最接近到期​​时间（较小的TTL）的密钥</span><br><span class="line">＃noeviction-&gt;不要逐出任何东西，只需在写操作中返回错误。</span><br><span class="line">＃</span><br><span class="line">＃LRU表示最近最少使用</span><br><span class="line">＃LFU表示最少使用</span><br><span class="line">＃</span><br><span class="line">＃LRU，LFU和volatile-ttl均使用近似值实现</span><br><span class="line">＃随机算法。</span><br><span class="line">＃</span><br><span class="line">＃注意：使用上述任何策略，Redis都会在写入时返回错误</span><br><span class="line">＃操作，如果没有合适的退出键。</span><br><span class="line">＃</span><br><span class="line">＃在撰写本文时，这些命令是：set setnx setex append</span><br><span class="line">＃incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><br><span class="line">＃sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><br><span class="line">＃zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><br><span class="line">＃getset mset msetnx exec排序</span><br><span class="line">＃</span><br><span class="line">＃默认为：</span><br><span class="line">＃</span><br><span class="line">＃maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line">＃LRU，LFU和最小TTL算法不是精确算法，而是近似算法</span><br><span class="line">＃算法（以节省内存），因此您可以对其进行调整以提高速度或</span><br><span class="line">＃ 准确性。默认情况下，Redis将检查五个键并选择一个</span><br><span class="line">＃使用较少，您可以使用以下方法更改样本大小</span><br><span class="line">＃配置指令。</span><br><span class="line">＃</span><br><span class="line">＃默认值5产生足够好的结果。 10非常接近</span><br><span class="line">＃真正的LRU，但消耗更多的CPU。 3更快，但不是很准确。</span><br><span class="line">＃</span><br><span class="line">＃maxmemory-samples 5</span><br><span class="line"></span><br><span class="line">＃从Redis 5开始，默认情况下副本将忽略其maxmemory设置</span><br><span class="line">＃（除非在故障转移后或手动提升为主节点）。它的意思是</span><br><span class="line">＃退出密钥将仅由主机处理，发送</span><br><span class="line">＃DEL命令作为副本在主控端退出到副本。</span><br><span class="line">＃</span><br><span class="line">＃此行为可确保母版和副本保持一致，并且通常</span><br><span class="line">＃您想要的内容，但是如果副本是可写的，或者您希望副本具有</span><br><span class="line">＃不同的内存设置，并且可以确定所有写入</span><br><span class="line">＃复制品是幂等的，那么您可以更改此默认值（但一定要了解</span><br><span class="line">＃ 你在做什么）。</span><br><span class="line">＃</span><br><span class="line">＃请注意，由于默认情况下该副本不会退出，因此可能会使用更多副本</span><br><span class="line">＃内存比通过maxmemory设置的内存多（某些缓冲区可能</span><br><span class="line">＃在副本上更大，否则数据结构有时会占用更多内存，因此</span><br><span class="line">＃ 向前）。因此，请确保您监视副本并确保副本足够</span><br><span class="line">＃内存永远不会在主机命中之前达到真正的内存不足状态</span><br><span class="line">＃配置的最大内存设置。</span><br><span class="line">＃</span><br><span class="line">＃复制副本忽略最大内存是</span><br><span class="line"></span><br><span class="line">############################ LAZY FREEING #################### #################</span><br><span class="line"></span><br><span class="line">＃Redis有两个删除键的原语。一个叫做DEL，是一个阻塞</span><br><span class="line">＃删除对象。这意味着服务器停止处理新命令</span><br><span class="line">＃为了在同步中回收与对象关联的所有内存</span><br><span class="line">＃ 办法。如果删除的键与小对象相关联，则需要时间</span><br><span class="line">＃为了执行DEL命令非常小，可与大多数其他设备相比</span><br><span class="line">＃Redis中的O（1）或O（log_N）命令。但是，如果密钥与</span><br><span class="line">＃包含数百万个元素的聚合值，服务器可以阻止</span><br><span class="line">＃长时间（甚至几秒钟）以完成操作。</span><br><span class="line">＃</span><br><span class="line">＃由于上述原因，Redis还提供了非阻塞删除原语</span><br><span class="line">＃，例如UNLINK（非阻塞DEL）和FLUSHALL的ASYNC选项，以及</span><br><span class="line">＃FLUSHDB命令，以便在后台回收内存。这些命令</span><br><span class="line">＃在固定时间内执行。另一个线程将逐步释放</span><br><span class="line">＃尽可能快地在后台对象。</span><br><span class="line">＃</span><br><span class="line">＃FLUSHALL和FLUSHDB的DEL，UNLINK和ASYNC选项是用户控制的。</span><br><span class="line">＃由应用程序的设计来了解何时是一个好的选择</span><br><span class="line">＃使用一个或另一个的想法。但是，Redis服务器有时必须</span><br><span class="line">＃删除键或刷新整个数据库，这是其他操作的副作用。</span><br><span class="line">＃特别是Redis会独立于用户调用中的对象删除对象</span><br><span class="line">＃以下方案：</span><br><span class="line">＃</span><br><span class="line">＃1）驱逐时，由于maxmemory和maxmemory策略配置，</span><br><span class="line">＃以便为新数据腾出空间，而无需遍历指定的</span><br><span class="line">＃内存限制。</span><br><span class="line">＃2）由于过期：当一个密钥具有关联的生存时间（请参见</span><br><span class="line">＃EXPIRE命令）必须从内存中删除。</span><br><span class="line">＃3）由于将数据存储在键上的命令的副作用，该键可能会</span><br><span class="line">＃    已经存在。例如，RENAME命令可能会删除旧密钥</span><br><span class="line">＃内容被另一个替换时。同样的SUNIONSTORE</span><br><span class="line">＃或带有STORE选项的SORT可能会删除现有密钥。 SET命令</span><br><span class="line">＃本身会删除指定密钥的所有旧内容以进行替换</span><br><span class="line">＃使用指定的字符串。</span><br><span class="line">＃4）在复制过程中，当副本执行完全重新同步时，</span><br><span class="line">＃它的主人，整个数据库的内容被删除以便</span><br><span class="line">＃加载刚传输的RDB文件。</span><br><span class="line">＃</span><br><span class="line">＃在上述所有情况下，默认设置都是以阻止方式删除对象，</span><br><span class="line">＃就像是否调用了DEL。但是，您可以专门配置每种情况</span><br><span class="line">＃以便以非阻塞方式释放内存，例如UNLINK</span><br><span class="line">使用以下配置指令调用了＃：</span><br><span class="line"></span><br><span class="line">懒惰-懒惰驱逐</span><br><span class="line">lazyfree-lazyexpire否</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">副本懒惰刷新否</span><br><span class="line"></span><br><span class="line">############################ APPEND ON MODE ################# ##############</span><br><span class="line"></span><br><span class="line">＃默认情况下，Redis异步将数据集转储到磁盘上。此模式是</span><br><span class="line">＃在许多应用程序中都足够好，但是Redis进程或</span><br><span class="line">＃停电可能会导致几分钟的写入丢失（取决于</span><br><span class="line">＃配置的保存点）。</span><br><span class="line">＃</span><br><span class="line">＃仅附加文件是一种替代的持久性模式，可提供</span><br><span class="line">＃更好的耐久性。例如使用默认数据fsync策略</span><br><span class="line">＃（请参阅配置文件中的后面部分），Redis可能仅丢失一秒钟的写操作。</span><br><span class="line">＃戏剧性事件，例如服务器断电，或者一次写入（如果有的话）</span><br><span class="line">＃Redis进程本身发生了错误，但是操作系统是</span><br><span class="line">＃仍能正常运行。</span><br><span class="line">＃</span><br><span class="line">＃可以同时启用AOF和RDB持久性，而不会出现问题。</span><br><span class="line">＃如果启动时启用了AOF，则Redis将加载AOF，即文件</span><br><span class="line">＃具有更好的耐用性保证。</span><br><span class="line">＃</span><br><span class="line">＃请检查http:&#x2F;&#x2F;redis.io&#x2F;topics&#x2F;persistence以获取更多信息。</span><br><span class="line"></span><br><span class="line">appendonly否</span><br><span class="line"></span><br><span class="line">＃仅附加文件的名称（默认值：“ appendonly.aof”）</span><br><span class="line"></span><br><span class="line">appendfilename“ appendonly.aof”</span><br><span class="line"></span><br><span class="line">＃fsync（）调用告诉操作系统实际在磁盘上写入数据</span><br><span class="line">＃而不是等待输出缓冲区中的更多数据。某些操作系统会真正刷新</span><br><span class="line">＃磁盘上的数据，其他一些操作系统将尝试尽快执行。</span><br><span class="line">＃</span><br><span class="line">＃Redis支持三种不同的模式：</span><br><span class="line">＃</span><br><span class="line">＃否：不要fsync，只要让OS在需要时刷新数据即可。快点。</span><br><span class="line">＃always：每次写入仅附加日志后执行fsync。慢，最安全。</span><br><span class="line">＃everysec：每秒仅同步一次fsync。妥协。</span><br><span class="line">＃</span><br><span class="line">＃默认为“ everysec”，因为通常是</span><br><span class="line">＃速度和数据安全。您可以自行决定是否可以放松</span><br><span class="line">＃“ no”将使操作系统在以下情况时刷新输出缓冲区</span><br><span class="line">＃它希望获得更好的性能（但如果您能够接受</span><br><span class="line">＃一些数据丢失会考虑默认的持久化模式（即快照），</span><br><span class="line">＃或相反，请使用“总是”，该速度非常慢，但比</span><br><span class="line">＃每秒钟。</span><br><span class="line">＃</span><br><span class="line">＃更多详细信息，请查看以下文章：</span><br><span class="line">＃http:&#x2F;&#x2F;antirez.com&#x2F;post&#x2F;redis-persistence-demystified.html</span><br><span class="line">＃</span><br><span class="line">＃如果不确定，请使用“ everysec”。</span><br><span class="line"></span><br><span class="line">#appendfsync总是</span><br><span class="line">appendfsync everysec</span><br><span class="line">＃appendfsync否</span><br><span class="line"></span><br><span class="line">＃当AOF fsync策略设置为always或everysec，并且有一个背景时</span><br><span class="line">＃保存过程（后台保存或AOF日志后台重写）为</span><br><span class="line">＃在某些Linux配置中，对磁盘执行大量I &#x2F; O</span><br><span class="line">＃Redis可能在fsync（）调用中阻塞的时间过长。请注意，没有针对</span><br><span class="line">＃当前，因为即使在其他线程中执行fsync也会阻塞</span><br><span class="line">＃我们的同步write（2）调用。</span><br><span class="line">＃</span><br><span class="line">＃为了减轻此问题，可以使用以下选项</span><br><span class="line">＃可以防止在主进程中调用fsync（）时</span><br><span class="line">＃BGSAVE或BGREWRITEAOF正在进行中。</span><br><span class="line">＃</span><br><span class="line">＃这意味着当另一个孩子在保存时，Redis的持久性是</span><br><span class="line">＃与“ appendfsync none”相同。实际上，这意味着</span><br><span class="line">＃在最坏的情况下可能会丢失多达30秒的日志记录（使用</span><br><span class="line">＃默认Linux设置）。</span><br><span class="line">＃</span><br><span class="line">＃如果您有延迟问题，请将其设为“是”。否则将其保留为</span><br><span class="line">从耐久性的角度来看，“＃”是最安全的选择。</span><br><span class="line"></span><br><span class="line">no-appendfsync-on-rewrite否</span><br><span class="line"></span><br><span class="line">＃自动重写仅附加文件。</span><br><span class="line">＃Redis能够自动重写隐式调用的日志文件</span><br><span class="line">当AOF日志大小增加指定的百分比时，使用＃BGREWRITEAOF。</span><br><span class="line">＃</span><br><span class="line">＃这是这样的：Redis会记住AOF文件的大小。</span><br><span class="line">＃最新重写（如果自重新启动以来未发生任何重写，则为</span><br><span class="line">＃使用启动时的AOF）。</span><br><span class="line">＃</span><br><span class="line">＃将此基本大小与当前大小进行比较。如果当前大小是</span><br><span class="line">＃大于指定的百分比，将触发重写。也</span><br><span class="line">＃您需要为要重写的AOF文件指定最小大小，这</span><br><span class="line">＃有助于避免重写AOF文件（即使百分比增加）</span><br><span class="line">＃已达到，但仍然很小。</span><br><span class="line">＃</span><br><span class="line">＃指定零百分比以禁用自动AOF</span><br><span class="line">＃重写功能。</span><br><span class="line"></span><br><span class="line">自动改写百分比100</span><br><span class="line">自动改写最小大小64mb</span><br><span class="line"></span><br><span class="line">＃在Redis的最后发现AOF文件被截断</span><br><span class="line">＃启动过程，当AOF数据重新加载到内存中时。</span><br><span class="line">＃当运行Redis的系统时可能会发生</span><br><span class="line">＃崩溃，尤其是在没有安装ext4文件系统的情况下</span><br><span class="line">＃data &#x3D; ordered选项（但是Redis本身不会发生这种情况</span><br><span class="line">＃崩溃或中止，但操作系统仍可正常运行）。</span><br><span class="line">＃</span><br><span class="line">＃Redis可以在发生这种情况时退出并显示错误，也可以加载尽可能多的内容</span><br><span class="line">＃尽可能的数据（现在为默认值），如果找到AOF文件则开始</span><br><span class="line">＃在末尾被截断。以下选项控制此行为。</span><br><span class="line">＃</span><br><span class="line">＃如果aof-load-truncated设置为yes，则会加载截短的AOF文件并</span><br><span class="line">＃Redis服务器开始发出日志以通知用户该事件。</span><br><span class="line">＃否则，如果该选项设置为no，服务器将中止并显示错误</span><br><span class="line">＃并拒绝启动。当选项设置为no时，用户要求</span><br><span class="line">＃在重新启动之前使用“ redis-check-aof”实用程序修复AOF文件</span><br><span class="line">＃ 服务器。</span><br><span class="line">＃</span><br><span class="line">＃请注意，如果在中间发现AOF文件已损坏</span><br><span class="line">＃服务器仍将退出并出现错误。此选项仅在以下情况下适用</span><br><span class="line">＃Redis将尝试从AOF文件中读取更多数据，但字节数不足</span><br><span class="line">＃将被发现。</span><br><span class="line">aof负载截断是</span><br><span class="line"></span><br><span class="line">＃重写AOF文件时，Redis可以使用RDB前导中的</span><br><span class="line">＃AOF文件可加快重写和恢复速度。启用此选项时</span><br><span class="line">重写的AOF文件上的＃由两个不同的节组成：</span><br><span class="line">＃</span><br><span class="line">＃[RDB文件] [AOF尾巴]</span><br><span class="line">＃</span><br><span class="line">＃加载时，Redis会识别AOF文件以“ REDIS”开头</span><br><span class="line">＃字符串并加载带前缀的RDB文件，并继续加载AOF</span><br><span class="line">＃ 尾巴。</span><br><span class="line">aof-use-rdb-preamble是</span><br><span class="line"></span><br><span class="line">############################## LUA SCRIPTING ################ ###############</span><br><span class="line"></span><br><span class="line">＃Lua脚本的最大执行时间（以毫秒为单位）。</span><br><span class="line">＃</span><br><span class="line">＃如果达到了最大执行时间，Redis将记录脚本是</span><br><span class="line">＃在最长允许时间后仍在执行，并将开始执行</span><br><span class="line">＃回复有错误的查询。</span><br><span class="line">＃</span><br><span class="line">＃当长时间运行的脚本超过最大执行时间时，仅</span><br><span class="line">＃SCRIPT KILL和SHUTDOWN NOSAVE命令可用。第一个可以是</span><br><span class="line">＃用于停止尚未调用写命令的脚本。第二</span><br><span class="line">＃是在执行写命令的情况下关闭服务器的唯一方法</span><br><span class="line">＃已由脚本发出，但用户不想等待自然</span><br><span class="line">＃终止脚本。</span><br><span class="line">＃</span><br><span class="line">＃将其设置为0或负值以无警告地无限执行。</span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line">############################### REDIS CLUSTER ################ ###############</span><br><span class="line"></span><br><span class="line">＃普通Redis实例不能属于Redis集群；仅是</span><br><span class="line">＃在集群节点可以的情况下启动。为了启动一个Redis实例</span><br><span class="line">＃cluster node使群集支持取消注释以下内容：</span><br><span class="line">＃</span><br><span class="line">＃启用集群</span><br><span class="line"></span><br><span class="line">＃每个群集节点都有一个群集配置文件。该文件不是</span><br><span class="line">＃旨在手工编辑。它由Redis节点创建和更新。</span><br><span class="line">＃每个Redis群集节点都需要一个不同的群集配置文件。</span><br><span class="line">＃确保在同一系统上运行的实例没有</span><br><span class="line">＃重叠的集群配置文件名。</span><br><span class="line">＃</span><br><span class="line">＃cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line">＃群集节点超时是节点必须无法访问的毫秒数</span><br><span class="line">＃将其视为处于故障状态。</span><br><span class="line">＃其他大多数内部时间限制是节点超时的倍数。</span><br><span class="line">＃</span><br><span class="line">＃cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line">＃发生故障的主服务器的副本将避免在其数据出现时启动故障转移</span><br><span class="line">＃看起来太旧了。</span><br><span class="line">＃</span><br><span class="line">＃没有简单的方法可以使副本实际具有精确的度量</span><br><span class="line">＃它的“数据年龄”，因此执行以下两项检查：</span><br><span class="line">＃</span><br><span class="line">＃1）如果有多个副本可以进行故障转移，它们将交换消息</span><br><span class="line">＃为了尝试使副本具有最佳优势</span><br><span class="line">＃复制偏移量（已处理来自主服务器的更多数据）。</span><br><span class="line">＃副本将尝试按偏移量获取排名，并应用于开始</span><br><span class="line">故障转移的数量与它们的等级成正比的延迟。</span><br><span class="line">＃</span><br><span class="line">＃2）每个副本都计算与</span><br><span class="line">＃它的主人。这可以是最后收到的ping或命令（如果主服务器</span><br><span class="line">＃仍处于“已连接”状态），或者自</span><br><span class="line">＃与主服务器断开连接（如果复制链接当前断开）。</span><br><span class="line">＃如果最后一次交互太旧，副本将不会尝试故障转移</span><br><span class="line">＃。</span><br><span class="line">＃</span><br><span class="line">＃用户可以调整点“ 2”。具体来说，副本将无法执行</span><br><span class="line">＃故障转移（如果自从与主机进行最后一次交互以来）</span><br><span class="line">＃经过的次数大于：</span><br><span class="line">＃</span><br><span class="line">＃（节点超时*复制有效性因子）+ repl-ping-replica-period</span><br><span class="line">＃</span><br><span class="line">＃例如，如果node-timeout为30秒，并且副本有效性因子</span><br><span class="line">＃为10，并假设默认的repl-ping-replica-period为10秒，则</span><br><span class="line">＃副本如果无法与主服务器通信，将不会尝试故障转移</span><br><span class="line">＃超过310秒。</span><br><span class="line">＃</span><br><span class="line">＃较大的副本有效性因素可能会使数据过旧的副本进行故障转移</span><br><span class="line">＃主机，但值太小可能会阻止群集</span><br><span class="line">＃完全选择一个副本。</span><br><span class="line">＃</span><br><span class="line">＃为了获得最大可用性，可以设置副本有效性因子</span><br><span class="line">＃的值为0，这意味着副本将始终尝试对</span><br><span class="line">＃master，无论他们上次与master互动的时间如何。</span><br><span class="line">＃（但是，他们将始终尝试按比例分配延迟</span><br><span class="line">＃偏移排名）。</span><br><span class="line">＃</span><br><span class="line">＃零是唯一能够保证所有分区恢复正常的值</span><br><span class="line">＃群集将始终能够继续。</span><br><span class="line">＃</span><br><span class="line">＃cluster-replica-validity-factor 10</span><br><span class="line"></span><br><span class="line">＃群集副本能够迁移到孤立的主数据库（即主数据库）</span><br><span class="line">＃没有可用的副本。这提高了集群能力</span><br><span class="line">＃抵制故障，因为否则孤立的主节点无法进行故障转移</span><br><span class="line">＃如果没有可用的副本，则在失败的情况下。</span><br><span class="line">＃</span><br><span class="line">＃仅当仍然存在至少一个副本时，副本服务器才会迁移到孤立的主服务器</span><br><span class="line">＃给定其旧主副本的其他工作副本的数量。这个号码</span><br><span class="line">＃是“移民壁垒”。迁移障碍为1表示副本</span><br><span class="line">＃仅在其主数据库至少有其他1个工作副本时才会迁移</span><br><span class="line">＃依此类推。它通常反映出每个副本所需的副本数</span><br><span class="line">＃集群中的master。</span><br><span class="line">＃</span><br><span class="line">＃默认为1（仅当其主服务器保持至少</span><br><span class="line">＃个副本）。要禁用迁移，只需将其设置为非常大的值即可。</span><br><span class="line">＃可以设置为0，但仅在调试和危险时有用</span><br><span class="line">＃生产中。</span><br><span class="line">＃</span><br><span class="line">＃cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line">＃默认情况下，Redis群集节点如果检测到它们，则停止接受查询</span><br><span class="line">＃至少是一个未显示的哈希槽（没有可用节点为其提供服务）。</span><br><span class="line">＃如果集群部分处于关闭状态（例如，一定范围的哈希槽）</span><br><span class="line">＃不再涵盖）所有群集最终将变得不可用。</span><br><span class="line">＃重新覆盖所有插槽后，它将自动返回可用状态。</span><br><span class="line">＃</span><br><span class="line">＃但是有时您希望集群的一部分工作，</span><br><span class="line">＃继续接受对仍然存在的键空间部分的查询</span><br><span class="line">＃覆盖。为此，只需设置cluster-require-full-coverage</span><br><span class="line">＃选项为否。</span><br><span class="line">＃</span><br><span class="line">＃cluster-require-full-coverage是</span><br><span class="line"></span><br><span class="line">＃此选项设置为yes时，可防止副本尝试对其进行故障转移</span><br><span class="line">＃在主服务器故障期间的主服务器。但是主控仍然可以执行</span><br><span class="line">＃手动故障转移（如果被迫这样做）。</span><br><span class="line">＃</span><br><span class="line">＃这在不同的情况下很有用，尤其是在多个情况下</span><br><span class="line">＃数据中心操作，如果不希望的话，我们希望一侧永远不会升级</span><br><span class="line">＃如果发生直流故障。</span><br><span class="line">＃</span><br><span class="line">＃cluster-replica-no-failover否</span><br><span class="line"></span><br><span class="line">＃为了设置您的集群，请确保阅读文档</span><br><span class="line">＃可从http:&#x2F;&#x2F;redis.io网站获得。</span><br><span class="line"></span><br><span class="line">######################### CLUSTER DOCKER &#x2F; NAT支持################### #####</span><br><span class="line"></span><br><span class="line">＃在某些部署中，Redis群集节点地址发现失败，因为</span><br><span class="line">＃个地址是NAT-ted或因为端口已转发（典型情况是</span><br><span class="line">＃Docker和其他容器）。</span><br><span class="line">＃</span><br><span class="line">＃为了使Redis Cluster在这样的环境中工作，</span><br><span class="line">＃每个节点都知道需要其公共地址的配置。的</span><br><span class="line">＃以下两个选项用于此范围，分别是：</span><br><span class="line">＃</span><br><span class="line">＃*集群公告IP</span><br><span class="line">＃* cluster-announce-port</span><br><span class="line">＃*集群公告总线端口</span><br><span class="line">＃</span><br><span class="line">＃每个命令都会向节点指示其地址，客户端端口和集群消息</span><br><span class="line">＃总线端口。然后将信息发布在总线数据包的标题中</span><br><span class="line">＃，以便其他节点能够正确映射该节点的地址</span><br><span class="line">＃发布信息。</span><br><span class="line">＃</span><br><span class="line">＃如果未使用上述选项，则正常的Redis群集自动检测</span><br><span class="line">＃将代替使用。</span><br><span class="line">＃</span><br><span class="line">＃请注意，重新映射后，总线端口可能不在的固定偏移量</span><br><span class="line">＃客户端端口+ 10000，因此您可以根据需要指定任何端口和总线端口</span><br><span class="line">＃如何重新映射它们。如果未设置总线端口，则固定偏移量为</span><br><span class="line">＃10000将照常使用。</span><br><span class="line">＃</span><br><span class="line">＃示例：</span><br><span class="line">＃</span><br><span class="line">＃cluster-announce-ip 10.1.1.5</span><br><span class="line">＃cluster-announce-port 6379</span><br><span class="line">＃cluster-announce-bus-port 6380</span><br><span class="line"></span><br><span class="line">################################ SLOW LOG ############### #####################</span><br><span class="line"></span><br><span class="line">＃Redis Slow Log是用于记录超过指定数量的查询的系统</span><br><span class="line">＃ 执行时间处理时间。执行时间不包括I &#x2F; O操作</span><br><span class="line">＃喜欢与客户交谈，发送回复等，</span><br><span class="line">＃但仅是实际执行命令所需的时间（这是唯一的时间</span><br><span class="line">＃执行命令的阶段，其中线程被阻塞并且无法服务</span><br><span class="line">同时＃个其他请求）。</span><br><span class="line">＃</span><br><span class="line">＃您可以使用以下两个参数配置慢速日志：一个告诉Redis</span><br><span class="line">＃为了使执行时间超出多少时间（以微秒为单位）</span><br><span class="line">＃命令获取日志，另一个参数是长度</span><br><span class="line">＃慢日志。记录新命令时，最旧的命令将从</span><br><span class="line">＃已记录命令的队列。</span><br><span class="line"></span><br><span class="line">＃以下时间以微秒表示，因此1000000等价</span><br><span class="line">＃一秒钟。请注意，负数将禁用慢速日志，而</span><br><span class="line">＃零值将强制记录每个命令。</span><br><span class="line">slowlog日志慢于10000</span><br><span class="line"></span><br><span class="line">＃此长度没有限制。请注意，它将消耗内存。</span><br><span class="line">＃您可以使用SLOWLOG RESET回收慢速日志使用的内存。</span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line">############################## LATENCY MONITOR ################ ##############</span><br><span class="line"></span><br><span class="line">＃Redis延迟监控子系统对不同的操作进行采样</span><br><span class="line">＃在运行时收集与可能的来源有关的数据</span><br><span class="line">＃Redis实例的延迟。</span><br><span class="line">＃</span><br><span class="line">＃通过LATENCY命令，该信息对用户可用</span><br><span class="line">＃打印图形并获取报告。</span><br><span class="line">＃</span><br><span class="line">＃系统仅记录在等于或等于时间的时间内执行的操作</span><br><span class="line">＃大于通过指定的毫秒数</span><br><span class="line">＃delay-monitor-threshold配置指令。设置其值时</span><br><span class="line">＃设置为零，等待时间监视器关闭。</span><br><span class="line">＃</span><br><span class="line">＃默认情况下，延迟监视是禁用的，因为它几乎不需要</span><br><span class="line">＃如果您没有延迟问题，并且收集数据可以提高性能</span><br><span class="line">＃冲击虽然很小，但可以在大负载下测量。潜伏</span><br><span class="line">使用以下命令可以轻松地在运行时启用＃监视</span><br><span class="line">＃“如果需要，请配置配置延迟监视器阈值&lt;毫秒”。</span><br><span class="line">等待时间监控器阈值0</span><br><span class="line"></span><br><span class="line">########################### EVENT NOTIFICATION #################### ###########</span><br><span class="line"></span><br><span class="line">＃Redis可以将关键空间中发生的事件通知给发布&#x2F;订阅客户端。</span><br><span class="line">＃此功能记录在http:&#x2F;&#x2F;redis.io&#x2F;topics&#x2F;notifications</span><br><span class="line">＃</span><br><span class="line">＃例如，如果启用了键空间事件通知，并且客户端</span><br><span class="line">＃对数据库0中存储的键“ foo”执行DEL操作，两个</span><br><span class="line">＃条消息将通过发布&#x2F;订阅发布：</span><br><span class="line">＃</span><br><span class="line">＃发布__keyspace @ 0 __：foo del</span><br><span class="line">＃发布__keyevent @ 0 __：del foo</span><br><span class="line">＃</span><br><span class="line">＃可以在一组中选择Redis将通知的事件</span><br><span class="line">类数。每个类都由一个字符标识：</span><br><span class="line">＃</span><br><span class="line">＃K个键空间事件，以__keyspace @ &lt;db&gt; __前缀发布。</span><br><span class="line">＃E Keyevent事件，以__keyevent @ &lt;db&gt; __前缀发布。</span><br><span class="line">＃g通用命令（非类型专用），例如DEL，EXPIRE，RENAME，...</span><br><span class="line">＃$字符串命令</span><br><span class="line">＃l列出命令</span><br><span class="line">＃s设置命令</span><br><span class="line">＃h哈希命令</span><br><span class="line">＃z排序集命令</span><br><span class="line">＃x过期事件（每次密钥过期时生成的事件）</span><br><span class="line">＃e驱逐事件（驱逐密钥以获取最大内存时生成的事件）</span><br><span class="line">＃g $ lshzxe的别名，以便“ AKE”字符串表示所有事件。</span><br><span class="line">＃</span><br><span class="line">＃“ notify-keyspace-events”将由组成的字符串作为参数</span><br><span class="line">零个或多个字符的数量。空字符串表示通知</span><br><span class="line">＃被禁用。</span><br><span class="line">＃</span><br><span class="line">＃示例：从列表的角度启用列表和一般事件</span><br><span class="line">＃事件名称，使用：</span><br><span class="line">＃</span><br><span class="line">＃notify-keyspace-events Elg</span><br><span class="line">＃</span><br><span class="line">＃示例2：获取订阅频道的过期密钥流</span><br><span class="line">＃名称__keyevent @ 0__：过期使用：</span><br><span class="line">＃</span><br><span class="line">＃notify-keyspace-events Ex</span><br><span class="line">＃</span><br><span class="line">＃默认情况下，所有通知都被禁用，因为大多数用户不需要</span><br><span class="line">＃此功能，该功能有一些开销。请注意，如果您不</span><br><span class="line">＃指定K或E中的至少一个，不会传递任何事件。</span><br><span class="line">notify-keyspace-events“”</span><br><span class="line"></span><br><span class="line">############################## ADVANCED CONFIG ################# ##############</span><br><span class="line"></span><br><span class="line">＃当散列具有</span><br><span class="line">＃条目数量少，最大条目不超过给定</span><br><span class="line">＃门槛。可以使用以下指令配置这些阈值。</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">＃列表也以特殊方式编码，以节省大量空间。</span><br><span class="line">＃可以指定每个内部列表节点允许的条目数</span><br><span class="line">＃作为固定的最大大小或最大元素数。</span><br><span class="line">＃对于固定的最大大小，请使用-5到-1，表示：</span><br><span class="line">＃-5：最大大小：64 Kb &lt;-不建议用于正常工作负载</span><br><span class="line">＃-4：最大大小：32 Kb &lt;-不推荐</span><br><span class="line">＃-3：最大大小：16 Kb &lt;-可能不建议</span><br><span class="line">＃-2：最大大小：8 Kb &lt;-好</span><br><span class="line">＃-1：最大大小：4 Kb &lt;-好</span><br><span class="line">＃正数表示最多存储_exactly_个元素</span><br><span class="line">＃每个列表节点。</span><br><span class="line">＃最高性能的选项通常是-2（8 Kb大小）或-1（4 Kb大小），</span><br><span class="line">＃但如果您的用例是唯一的，请根据需要调整设置。</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line"></span><br><span class="line">＃列表也可能被压缩。</span><br><span class="line">＃压缩深度是从*每个*侧面开始的快速列表ziplist节点的数量</span><br><span class="line">＃要从压缩中“排除”的列表。列表的首尾</span><br><span class="line">＃始终未压缩以进行快速推入&#x2F;弹出操作。设置为：</span><br><span class="line">＃0：禁用所有列表压缩</span><br><span class="line">＃1：深度1表示“直到列表中的1个节点之后才开始压缩，</span><br><span class="line">＃从头到尾”</span><br><span class="line">＃因此：[head]-&gt; node-&gt; node-&gt; ...-&gt; node-&gt; [tail]</span><br><span class="line">＃[head]，[tail]将始终未压缩；内部节点将压缩。</span><br><span class="line">＃2：[head]-&gt; [next]-&gt; node-&gt; node-&gt; ...-&gt; node-&gt; [prev]-&gt; [tail]</span><br><span class="line">这里的＃2表示：请勿压缩head或head-&gt; next或tail-&gt; prev或tail，</span><br><span class="line">＃但压缩它们之间的所有节点。</span><br><span class="line">＃3：[head]-&gt; [next]-&gt; [next]-&gt; node-&gt; node-&gt; ...-&gt; node-&gt; [prev]-&gt; [prev]-&gt; [tail]</span><br><span class="line">＃等</span><br><span class="line">list-compress-depth 0</span><br><span class="line"></span><br><span class="line">＃集合在一种情况下具有特殊的编码：组成集合时</span><br><span class="line">恰好是基数10范围内的整数的字符串的数量</span><br><span class="line">64位带符号整数的数量。</span><br><span class="line">＃以下配置设置设置了大小限制</span><br><span class="line">＃设置为使用此特殊的内存保存编码。</span><br><span class="line">设置最大整数条目512</span><br><span class="line"></span><br><span class="line">＃与散列和列表类似，排序后的集合也专门编码为</span><br><span class="line">＃为了节省很多空间。仅当长度和</span><br><span class="line">排序集中的＃个元素低于以下限制：</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">＃HyperLogLog稀疏表示字节数限制。该限制包括</span><br><span class="line">＃16个字节的标头。当使用稀疏表示的HyperLogLog交叉时</span><br><span class="line">＃此限制，它将转换为密集表示形式。</span><br><span class="line">＃</span><br><span class="line">＃大于16000的值完全没有用，因为此时</span><br><span class="line">＃密集表示可提高内存效率。</span><br><span class="line">＃</span><br><span class="line">＃为了获得以下好处，建议值是〜3000</span><br><span class="line">＃节省空间的编码，且不会减慢PFADD，</span><br><span class="line">＃是稀疏编码的O（N）。该值可以提高到</span><br><span class="line">＃〜10000，当CPU不是问题，而是空间，并且数据集为</span><br><span class="line">＃由许多基数在0-15000之间的HyperLogLog组成。</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line">＃流宏节点的最大大小&#x2F;项目。流数据结构是一个基数</span><br><span class="line">＃大节点树，对内部的多个项目进行编码。使用此配置</span><br><span class="line">＃可以配置单个节点的字节数，并且</span><br><span class="line">＃在以下情况下切换到新节点之前可能包含的最大项目数：</span><br><span class="line">＃附加新的流条目。如果以下任何设置被设置为</span><br><span class="line">＃零，限制被忽略，因此例如可以设置一个</span><br><span class="line">＃通过将max-bytes设置为0并将max-entries设置为所需的最大整数限制</span><br><span class="line">＃值。</span><br><span class="line">流节点最大字节数4096</span><br><span class="line">流节点最大条目数100</span><br><span class="line"></span><br><span class="line">＃主动重新哈希处理每100毫秒CPU时间使用1毫秒</span><br><span class="line">＃为了帮助重新哈希主Redis哈希表（一个映射顶层）</span><br><span class="line">＃个值键）。 Redis使用的哈希表实现（请参见dict.c）</span><br><span class="line">＃执行一次懒散的重新哈希处理：您在哈希表中运行的操作更多</span><br><span class="line">＃正在重新哈希化，则执行更多的重新哈希化“步骤”，因此，如果</span><br><span class="line">＃服务器空闲，重新哈希处理从未完成，并且使用了更多内存</span><br><span class="line">＃通过哈希表。</span><br><span class="line">＃</span><br><span class="line">＃默认值是每秒使用此毫秒数10次，以便</span><br><span class="line">＃主动重新哈希主字典，并在可能的情况下释放内存。</span><br><span class="line">＃</span><br><span class="line">＃如果不确定：</span><br><span class="line">＃如果您有严格的延迟要求，请使用“ activerehashing no”</span><br><span class="line">＃在您的环境中，Redis可以不时回复，这不是一件好事</span><br><span class="line">＃以2毫秒的延迟查询。</span><br><span class="line">＃</span><br><span class="line">＃如果您没有如此严格的要求，请使用“ activerehashing yes”</span><br><span class="line">＃希望在可能的情况下尽快释放内存。</span><br><span class="line">主动重新哈希是</span><br><span class="line"></span><br><span class="line">＃客户端输出缓冲区限制可用于强制断开客户端连接</span><br><span class="line">＃由于某种原因没有足够快地从服务器读取数据（a</span><br><span class="line">＃常见的原因是发布&#x2F;订阅客户端无法像使用邮件一样快地消费邮件</span><br><span class="line">＃发布者可以制作它们）。</span><br><span class="line">＃</span><br><span class="line">＃可以为三种不同类别的客户端设置不同的限制：</span><br><span class="line">＃</span><br><span class="line">＃普通-&gt;普通客户端，包括MONITOR客户端</span><br><span class="line">＃副本-&gt;副本客户端</span><br><span class="line">＃pubsub-&gt;客户端至少订阅了一个pubsub频道或模式</span><br><span class="line">＃</span><br><span class="line">＃每个client-output-buffer-limit指令的语法如下：</span><br><span class="line">＃</span><br><span class="line">＃client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br><span class="line">＃</span><br><span class="line">＃一旦达到硬限制，或者如果</span><br><span class="line">＃达到软限制，并在指定数量的范围内保持达到</span><br><span class="line">＃秒（连续）。</span><br><span class="line">＃例如，如果硬限制为32 MB，软限制为</span><br><span class="line">＃16兆字节&#x2F; 10秒，客户端将立即断开连接</span><br><span class="line">＃如果输出缓冲区的大小达到32兆字节，但也会</span><br><span class="line">＃如果客户端达到16兆字节并不断克服，则断开连接</span><br><span class="line">＃10秒的限制。</span><br><span class="line">＃</span><br><span class="line">＃默认情况下，普通客户端不受限制，因为它们不接收数据</span><br><span class="line">＃不询问（以推送方式），而是在请求之后，因此仅</span><br><span class="line">＃异步客户端可能会创建一种场景，在这种情况下，数据请求速度更快</span><br><span class="line">＃比它能读的多。</span><br><span class="line">＃</span><br><span class="line">＃相反，对于pubsub和副本客户端没有默认限制，因为</span><br><span class="line">＃个订户和副本以推送方式接收数据。</span><br><span class="line">＃</span><br><span class="line">＃可以通过将硬限制或软限制设置为零来禁用它们。</span><br><span class="line">客户端输出缓冲区限制正常0 0 0</span><br><span class="line">客户端输出缓冲区限制副本256mb 64mb 60</span><br><span class="line">客户端输出缓冲区限制pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line">＃客户端查询缓冲区累积新命令。它们仅限于固定</span><br><span class="line">默认情况下为＃数量，以避免协议失步（对于</span><br><span class="line">＃实例（由于客户端中的错误）会导致未绑定的内存使用情况</span><br><span class="line">＃查询缓冲区。但是，如果您有特殊要求，可以在此处进行配置</span><br><span class="line">＃需求，例如我们巨大的multi &#x2F; exec请求等等。</span><br><span class="line">＃</span><br><span class="line">＃client-query-buffer-limit 1gb</span><br><span class="line"></span><br><span class="line">＃在Redis协议中，批量请求即表示单个请求的元素</span><br><span class="line">＃个字符串，通常限制为512 mb以上。但是，您可以更改此限制</span><br><span class="line">＃ 这里。</span><br><span class="line">＃</span><br><span class="line">＃proto-max-bulk-len 512mb</span><br><span class="line"></span><br><span class="line">＃Redis调用内部函数来执行许多后台任务，例如</span><br><span class="line">＃在超时时关闭客户端连接，清除已过期的密钥</span><br><span class="line">＃从未提出要求，依此类推。</span><br><span class="line">＃</span><br><span class="line">＃并非所有任务都以相同的频率执行，但是Redis会检查</span><br><span class="line">＃根据指定的“ hz”值执行的任务。</span><br><span class="line">＃</span><br><span class="line">＃默认情况下，“ hz”设置为10。</span><br><span class="line">＃Redis处于空闲状态，但同时会使Redis在</span><br><span class="line">＃有许多键同时到期，并且可能超时</span><br><span class="line">＃更精确地处理。</span><br><span class="line">＃</span><br><span class="line">＃范围在1到500之间，但是通常不超过100</span><br><span class="line">＃ 一个好主意。大多数用户应使用默认值10并将其提高到</span><br><span class="line">＃100仅在要求极低延迟的环境中使用。</span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line">＃通常，将HZ值与</span><br><span class="line">＃连接的客户端数。这很有用，例如</span><br><span class="line">＃避免为每个后台任务调用处理过多的客户端</span><br><span class="line">＃为了避免延迟尖峰。</span><br><span class="line">＃</span><br><span class="line">＃由于默认的默认HZ值保守地设置为10，因此Redis</span><br><span class="line">＃提供并默认启用使用自适应HZ值的功能</span><br><span class="line">＃当有许多连接的客户端时，它将暂时提高。</span><br><span class="line">＃</span><br><span class="line">＃启用动态HZ时，实际配置的HZ将用作</span><br><span class="line">＃作为基准，但实际配置的HZ值的倍数将是</span><br><span class="line">＃在连接更多客户端后根据需要使用。这样闲置</span><br><span class="line">＃实例将使用很少的CPU时间，而忙碌的实例将</span><br><span class="line">＃更灵敏。</span><br><span class="line">动态HZ是</span><br><span class="line"></span><br><span class="line">＃当孩子重写AOF文件时，如果启用以下选项</span><br><span class="line">＃每生成32 MB的数据，文件就会进行同步处理。这很有用</span><br><span class="line">＃为了将文件更多地提交到磁盘并避免</span><br><span class="line">＃大的延迟峰值。</span><br><span class="line">aof-rewrite-incremental-fsync是</span><br><span class="line"></span><br><span class="line">＃Redis保存RDB文件时，如果启用以下选项</span><br><span class="line">＃每生成32 MB的数据，文件就会进行同步处理。这很有用</span><br><span class="line">＃为了将文件更多地提交到磁盘并避免</span><br><span class="line">＃大的延迟峰值。</span><br><span class="line">rdb-save-incremental-fsync是</span><br><span class="line"></span><br><span class="line">＃可以调整Redis LFU收回（请参阅maxmemory设置）。但是，这是一个很好的</span><br><span class="line">＃从默认设置开始的想法，只有在调查后才能更改它们</span><br><span class="line">＃如何改善性能以及LFU的关键随时间如何变化，其中</span><br><span class="line">＃可以通过OBJECT FREQ命令检查。</span><br><span class="line">＃</span><br><span class="line">＃Redis LFU实现中有两个可调参数：</span><br><span class="line">＃计数器对数因子和计数器衰减时间。重要的是要</span><br><span class="line">＃在更改它们之前了解两个参数的含义。</span><br><span class="line">＃</span><br><span class="line">＃LFU计数器每个密钥只有8位，最大值为255，因此Redis</span><br><span class="line">＃使用具有对数行为的概率增量。赋予价值</span><br><span class="line">＃旧计数器的编号，当访问一个键时，该计数器递增</span><br><span class="line">＃ 这条路：</span><br><span class="line">＃</span><br><span class="line">＃1.提取介于0和1之间的随机数R。</span><br><span class="line">＃2。将概率P计算为1 &#x2F;（old_value * lfu_log_factor + 1）。</span><br><span class="line">＃3.仅当R &lt;P时，计数器才会递增。</span><br><span class="line">＃</span><br><span class="line">＃默认的lfu-log-factor是10。这是一个频率表</span><br><span class="line">＃计数器随着访问次数的不同而变化，且访问次数不同</span><br><span class="line">＃对数因子：</span><br><span class="line">＃</span><br><span class="line">＃+ -------- + ------------ + ------------ + ------------ + ------------ + ------------ +</span><br><span class="line">＃|因素100点击| 1000点击| 10万点击| 1M点击| 1000万次点击|</span><br><span class="line">＃+ -------- + ------------ + ------------ + ------------ + ------------ + ------------ +</span><br><span class="line">＃| 0 | 104 | 255 | 255 | 255 | 255 |</span><br><span class="line">＃+ -------- + ------------ + ------------ + ------------ + ------------ + ------------ +</span><br><span class="line">＃| 1 | 18 | 49 | 255 | 255 | 255 |</span><br><span class="line">＃+ -------- + ------------ + ------------ + ------------ + ------------ + ------------ +</span><br><span class="line">＃| 10 | 10 | 18 | 142 | 255 | 255 |</span><br><span class="line">＃+ -------- + ------------ + ------------ + ------------ + ------------ + ------------ +</span><br><span class="line">＃| 100 | 8 | 11 | 49 | 143 | 255 |</span><br><span class="line">＃+ -------- + ------------ + ------------ + ------------ + ------------ + ------------ +</span><br><span class="line">＃</span><br><span class="line">＃注意：上表是通过运行以下命令获得的：</span><br><span class="line">＃</span><br><span class="line">＃redis-benchmark -n 1000000 incr foo</span><br><span class="line">＃redis-cli对象freq foo</span><br><span class="line">＃</span><br><span class="line">＃注意2：计数器的初始值为5，以便为新对象提供机会</span><br><span class="line">＃累积点击数。</span><br><span class="line">＃</span><br><span class="line">＃计数器衰减时间是按顺序必须经过的时间（以分钟为单位）</span><br><span class="line">＃将密钥计数器除以2（如果有值则减1</span><br><span class="line">＃小于&lt;&#x3D; 10）。</span><br><span class="line">＃</span><br><span class="line">＃lfu-decay-time的默认值为1。特殊值0表示</span><br><span class="line">＃每次碰巧扫描计数器时都会使其衰减。</span><br><span class="line">＃</span><br><span class="line">＃lfu-log-factor 10</span><br><span class="line">＃lfu-decay-time 1</span><br><span class="line"></span><br><span class="line">##########################活动碎片###################### ##</span><br><span class="line">＃</span><br><span class="line">＃警告此功能是实验性的。然而，这是经过压力测试的</span><br><span class="line">＃甚至在生产中，并由多名工程师手动测试</span><br><span class="line">＃ 时间。</span><br><span class="line">＃</span><br><span class="line">＃什么是主动碎片整理？</span><br><span class="line">＃-------------------------------</span><br><span class="line">＃</span><br><span class="line">＃主动（在线）碎片整理允许Redis服务器压缩</span><br><span class="line">＃在内存中的小量分配和释放之间留有空格，</span><br><span class="line">＃因此可以回收内存。</span><br><span class="line">＃</span><br><span class="line">＃碎片是每个分配器都会发生的自然过程（但</span><br><span class="line">＃幸运的是，Jemalloc和某些工作负载更少。通常是一台服务器</span><br><span class="line">＃重新启动是为了减少碎片或至少冲洗</span><br><span class="line">＃删除所有数据并再次创建。但是由于这个功能</span><br><span class="line">＃由Oran Agra针对Redis 4.0实施，此过程可以在运行时发生</span><br><span class="line">＃在服务器运行时以“热”方式。</span><br><span class="line">＃</span><br><span class="line">＃基本上在碎片超过一定水平时（请参阅</span><br><span class="line">＃下面的配置选项），Redis将开始创建新的副本</span><br><span class="line">通过利用某些特定的Jemalloc在连续内存区域中的＃个值</span><br><span class="line">＃功能（以了解分配是否引起碎片</span><br><span class="line">＃并将其分配到一个更好的位置），同时将释放</span><br><span class="line">＃数据的旧副本。对所有键逐步重复此过程</span><br><span class="line">＃将导致碎片恢复到正常值。</span><br><span class="line">＃</span><br><span class="line">＃重要事项：</span><br><span class="line">＃</span><br><span class="line">＃1.此功能默认情况下处于禁用状态，仅在编译Redis时有效</span><br><span class="line">＃使用我们随附Redis源代码的Jemalloc副本。</span><br><span class="line">＃这是Linux构建的默认设置。</span><br><span class="line">＃</span><br><span class="line">＃2.如果没有碎片，则无需启用此功能</span><br><span class="line">＃个问题。</span><br><span class="line">＃</span><br><span class="line">＃3.遇到碎片之后，您可以在以下情况下启用此功能：</span><br><span class="line">＃需要使用命令“ CONFIG SET activedefrag yes”。</span><br><span class="line">＃</span><br><span class="line">＃配置参数能够微调</span><br><span class="line">＃碎片整理过程。如果您不确定它们是什么意思</span><br><span class="line">＃保持默认值不变的好主意。</span><br><span class="line"></span><br><span class="line">＃启用主动碎片整理</span><br><span class="line">＃activedefrag是</span><br><span class="line"></span><br><span class="line">＃启动主动碎片整理的最小碎片浪费</span><br><span class="line">＃active-defrag-ignore-bytes 100mb</span><br><span class="line"></span><br><span class="line">＃启动活动碎片整理的最小碎片百分比</span><br><span class="line">＃active-defrag-threshold-lower 10</span><br><span class="line"></span><br><span class="line">＃我们最大程度地努力下的最大碎片百分比</span><br><span class="line">＃active-defrag-threshold-upper 100</span><br><span class="line"></span><br><span class="line">＃减少CPU碎片整理的工作量</span><br><span class="line">＃active-defrag-cycle-min 5</span><br><span class="line"></span><br><span class="line">＃尽最大努力整理CPU百分比</span><br><span class="line">＃active-defrag-cycle-max 75</span><br><span class="line"></span><br><span class="line">＃将要处理的set &#x2F; hash &#x2F; zset &#x2F; list字段的最大数量</span><br><span class="line">＃主字典扫描</span><br><span class="line">＃active-defrag-max-scan-fields 1000</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CODING</category>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
